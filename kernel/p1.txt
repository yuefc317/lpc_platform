From 264c3a317dd3c60ec1eef24f15354c4a7b6b3053 Mon Sep 17 00:00:00 2001
From: Bangaragiri G <bangaragiri.g@nxp.com>
Date: Wed, 24 Aug 2011 09:51:57 +0000
Subject: [PATCH 01/10] arm:lpc32x0:LPC32XX support changes

Including support for LPC32XX MCUs

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 arch/arm/configs/ea3250_defconfig                | 1718 ++++++++++++
 arch/arm/configs/fdi3250_defconfig               | 1623 +++++++++++
 arch/arm/configs/phy3250_defconfig               | 1667 +++++++++++
 arch/arm/mach-lpc32xx/Kconfig                    |  104 +-
 arch/arm/mach-lpc32xx/Makefile                   |    6 +-
 arch/arm/mach-lpc32xx/clock.c                    |  171 +-
 arch/arm/mach-lpc32xx/common.c                   |  157 ++
 arch/arm/mach-lpc32xx/common.h                   |   12 +
 arch/arm/mach-lpc32xx/dma.c                      |  761 +++++
 arch/arm/mach-lpc32xx/ea3250.c                   | 1019 +++++++
 arch/arm/mach-lpc32xx/fdi3250.c                  |  602 ++++
 arch/arm/mach-lpc32xx/gpiolib.c                  |   22 +-
 arch/arm/mach-lpc32xx/include/mach/board.h       |   86 +
 arch/arm/mach-lpc32xx/include/mach/debug-macro.S |   29 +
 arch/arm/mach-lpc32xx/include/mach/dma.h         |  116 +
 arch/arm/mach-lpc32xx/include/mach/dmac.h        |  285 ++
 arch/arm/mach-lpc32xx/include/mach/gpio.h        |    2 +-
 arch/arm/mach-lpc32xx/include/mach/i2s.h         |  156 ++
 arch/arm/mach-lpc32xx/include/mach/irqs.h        |   19 +-
 arch/arm/mach-lpc32xx/include/mach/platform.h    |   56 +-
 arch/arm/mach-lpc32xx/include/mach/sdcard.h      |  177 ++
 arch/arm/mach-lpc32xx/include/mach/slcnand.h     |  103 +
 arch/arm/mach-lpc32xx/include/mach/uncompress.h  |   23 +
 arch/arm/mach-lpc32xx/include/mach/usbd.h        |  291 ++
 arch/arm/mach-lpc32xx/irq.c                      |  295 ++-
 arch/arm/mach-lpc32xx/phy3250.c                  |  330 +++-
 arch/arm/mach-lpc32xx/pm.c                       |   69 +-
 arch/arm/mach-lpc32xx/serial.c                   |  183 +-
 arch/arm/mach-lpc32xx/suspend.S                  |   25 +-
 arch/arm/mach-lpc32xx/timer.c                    |   46 +-
 arch/arm/tools/mach-types                        |    3 +
 arch/arm/vfp/vfpmodule.c                         |    6 +-
 drivers/i2c/busses/i2c-pnx.c                     |  434 +++-
 drivers/input/keyboard/Kconfig                   |    9 +
 drivers/input/keyboard/Makefile                  |    1 +
 drivers/input/keyboard/lpc32xx_keys.c            |  293 ++
 drivers/input/touchscreen/lpc32xx_ts.c           |  414 ++--
 drivers/mmc/host/mmci.c                          |  318 +++-
 drivers/mtd/nand/Kconfig                         |    7 +
 drivers/mtd/nand/Makefile                        |    1 +
 drivers/mtd/nand/lpc32xx_nand.c                  | 1098 ++++++++
 drivers/net/Kconfig                              |    8 +
 drivers/net/Makefile                             |    1 +
 drivers/net/lpc_eth.c                            | 1346 +++++++++
 drivers/net/lpc_eth.h                            |  317 +++
 drivers/rtc/rtc-lpc32xx.c                        |   20 +-
 drivers/tty/serial/8250.c                        |   14 +-
 drivers/tty/serial/Kconfig                       |   16 +
 drivers/tty/serial/Makefile                      |    1 +
 drivers/tty/serial/lpc32xx_hs.c                  |  768 ++++++
 drivers/usb/gadget/Kconfig                       |   10 +
 drivers/usb/gadget/Makefile                      |    1 +
 drivers/usb/gadget/gadget_chips.h                |    6 +
 drivers/usb/gadget/lpc32xx_udc.c                 | 3194 ++++++++++++++++++++++
 drivers/usb/gadget/lpc32xx_udc.h                 |  174 ++
 drivers/usb/host/ohci-hcd.c                      |    5 +
 drivers/usb/host/ohci-pnx4008.c                  |   65 +
 drivers/video/amba-clcd.c                        |   37 +-
 include/linux/amba/clcd.h                        |   25 +-
 include/linux/i2c-pnx.h                          |   20 +
 init/main.c                                      |    2 +-
 sound/soc/Kconfig                                |    1 +
 sound/soc/Makefile                               |    1 +
 sound/soc/codecs/uda1380.c                       |   55 +
 sound/soc/lpc3xxx/Kconfig                        |   55 +
 sound/soc/lpc3xxx/Makefile                       |   10 +
 sound/soc/lpc3xxx/lpc3xxx-i2s.c                  |  639 +++++
 sound/soc/lpc3xxx/lpc3xxx-i2s.h                  |   53 +
 sound/soc/lpc3xxx/lpc3xxx-pcm.c                  |  534 ++++
 sound/soc/lpc3xxx/lpc3xxx-pcm.h                  |   29 +
 sound/soc/lpc3xxx/lpc3xxx-uda1380.c              |  227 ++
 71 files changed, 19858 insertions(+), 513 deletions(-)
 create mode 100644 arch/arm/configs/ea3250_defconfig
 create mode 100644 arch/arm/configs/fdi3250_defconfig
 create mode 100644 arch/arm/configs/phy3250_defconfig
 create mode 100644 arch/arm/mach-lpc32xx/dma.c
 create mode 100644 arch/arm/mach-lpc32xx/ea3250.c
 create mode 100644 arch/arm/mach-lpc32xx/fdi3250.c
 create mode 100644 arch/arm/mach-lpc32xx/include/mach/board.h
 create mode 100644 arch/arm/mach-lpc32xx/include/mach/dma.h
 create mode 100644 arch/arm/mach-lpc32xx/include/mach/dmac.h
 create mode 100644 arch/arm/mach-lpc32xx/include/mach/i2s.h
 create mode 100644 arch/arm/mach-lpc32xx/include/mach/sdcard.h
 create mode 100644 arch/arm/mach-lpc32xx/include/mach/slcnand.h
 create mode 100644 arch/arm/mach-lpc32xx/include/mach/usbd.h
 create mode 100644 drivers/input/keyboard/lpc32xx_keys.c
 create mode 100644 drivers/mtd/nand/lpc32xx_nand.c
 create mode 100644 drivers/net/lpc_eth.c
 create mode 100644 drivers/net/lpc_eth.h
 create mode 100644 drivers/tty/serial/lpc32xx_hs.c
 create mode 100644 drivers/usb/gadget/lpc32xx_udc.c
 create mode 100644 drivers/usb/gadget/lpc32xx_udc.h
 create mode 100644 sound/soc/lpc3xxx/Kconfig
 create mode 100644 sound/soc/lpc3xxx/Makefile
 create mode 100644 sound/soc/lpc3xxx/lpc3xxx-i2s.c
 create mode 100644 sound/soc/lpc3xxx/lpc3xxx-i2s.h
 create mode 100644 sound/soc/lpc3xxx/lpc3xxx-pcm.c
 create mode 100644 sound/soc/lpc3xxx/lpc3xxx-pcm.h
 create mode 100644 sound/soc/lpc3xxx/lpc3xxx-uda1380.c

diff --git a/arch/arm/configs/ea3250_defconfig b/arch/arm/configs/ea3250_defconfig
new file mode 100644
index 0000000..3c37e03
--- /dev/null
+++ b/arch/arm/configs/ea3250_defconfig
@@ -0,0 +1,1718 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.34
+# Thu Apr  7 11:26:32 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+CONFIG_ARCH_LPC32XX=y
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_MACH_PHY3250 is not set
+CONFIG_MACH_EA3250=y
+# CONFIG_MACH_FDI3250 is not set
+
+#
+# Embedded Artists Display Selection
+#
+CONFIG_EA3250_QVGA_3_2_LCD=y
+# CONFIG_EA3250_QVGA_2_8_OLED is not set
+
+#
+# Standard UARTS
+#
+# CONFIG_ARCH_LPC32XX_UART3_SELECT is not set
+# CONFIG_ARCH_LPC32XX_UART4_SELECT is not set
+CONFIG_ARCH_LPC32XX_UART5_SELECT=y
+# CONFIG_ARCH_LPC32XX_UART6_SELECT is not set
+
+#
+# High speed UARTS
+#
+# CONFIG_ARCH_LPC32XX_HSUART1_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART2_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART7_SELECT is not set
+
+#
+# LPC32XX chip components
+#
+# CONFIG_ARCH_LPC32XX_IRAM_FOR_NET is not set
+# CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n81 root=/dev/ram0"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM_OPS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_MUSEUM_IDS=y
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_SLC_LPC32XX=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+CONFIG_NATIONAL_PHY=y
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_LPC_ENET=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=240
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=320
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LPC32XX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_LPC32XX is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_HS_LPC32XX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_PNX4008_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_AB4500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_LPC3XXX_SOC=y
+CONFIG_SND_LPC3XXX_SOC_I2S_UDA1380=y
+CONFIG_SND_LPC32XX_USEI2S1=y
+# CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODETX is not set
+# CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODERX is not set
+CONFIG_SND_LPC32XX_SLAVE_TX_CLK_TO_RX=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_UDA1380=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_3M_PCT is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MOSART is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_STANTUM is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+CONFIG_LEDS_PCA9532=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_LPC32XX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
diff --git a/arch/arm/configs/fdi3250_defconfig b/arch/arm/configs/fdi3250_defconfig
new file mode 100644
index 0000000..a895abc
--- /dev/null
+++ b/arch/arm/configs/fdi3250_defconfig
@@ -0,0 +1,1623 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.34
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+CONFIG_ARCH_LPC32XX=y
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_MACH_PHY3250 is not set
+# CONFIG_MACH_EA3250 is not set
+CONFIG_MACH_FDI3250=y
+CONFIG_SOM9DIMM3250_LCD_PANEL=y
+CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35=y
+# CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35 is not set
+
+#
+# Standard UARTS
+#
+# CONFIG_ARCH_LPC32XX_UART3_SELECT is not set
+# CONFIG_ARCH_LPC32XX_UART4_SELECT is not set
+CONFIG_ARCH_LPC32XX_UART5_SELECT=y
+# CONFIG_ARCH_LPC32XX_UART6_SELECT is not set
+
+#
+# High speed UARTS
+#
+CONFIG_ARCH_LPC32XX_HSUART1_SELECT=y
+# CONFIG_ARCH_LPC32XX_HSUART2_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART7_SELECT is not set
+
+#
+# LPC32XX chip components
+#
+# CONFIG_ARCH_LPC32XX_IRAM_FOR_NET is not set
+# CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyTX0,115200n81 init=/sbin/init"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM_OPS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_MUSEUM_IDS=y
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_SLC_LPC32XX=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_PLATFORM=y
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_LPC_ENET=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=640
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+CONFIG_TOUCHSCREEN_LPC32XX=y
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+CONFIG_SERIAL_HS_LPC32XX=y
+CONFIG_SERIAL_HS_LPC32XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_PNX4008_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_AB4500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_3M_PCT is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MOSART is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_STANTUM is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_LPC32XX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_AUTOFS_FS=y
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_ALGAPI2=m
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=m
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
diff --git a/arch/arm/configs/phy3250_defconfig b/arch/arm/configs/phy3250_defconfig
new file mode 100644
index 0000000..b87b75e
--- /dev/null
+++ b/arch/arm/configs/phy3250_defconfig
@@ -0,0 +1,1667 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.34
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+# CONFIG_NAMESPACES is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+CONFIG_ARCH_LPC32XX=y
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+CONFIG_MACH_PHY3250=y
+# CONFIG_MACH_EA3250 is not set
+# CONFIG_MACH_FDI3250 is not set
+
+#
+# Standard UARTS
+#
+# CONFIG_ARCH_LPC32XX_UART3_SELECT is not set
+# CONFIG_ARCH_LPC32XX_UART4_SELECT is not set
+CONFIG_ARCH_LPC32XX_UART5_SELECT=y
+# CONFIG_ARCH_LPC32XX_UART6_SELECT is not set
+
+#
+# High speed UARTS
+#
+# CONFIG_ARCH_LPC32XX_HSUART1_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART2_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART7_SELECT is not set
+
+#
+# LPC32XX chip components
+#
+# CONFIG_ARCH_LPC32XX_IRAM_FOR_NET is not set
+# CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+CONFIG_COMMON_CLKDEV=y
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n81 root=/dev/ram0"
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_APM_EMULATION is not set
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM_OPS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_MUSEUM_IDS=y
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_SLC_LPC32XX=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_LPC_ENET=y
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=240
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=320
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LPC32XX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+CONFIG_TOUCHSCREEN_LPC32XX=y
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_HS_LPC32XX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+
+#
+# AC97 GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_PNX4008_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13783 is not set
+# CONFIG_AB3100_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_AB4500_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_LPC3XXX_SOC=y
+CONFIG_SND_LPC3XXX_SOC_I2S_UDA1380=y
+CONFIG_SND_LPC32XX_USEI2S1=y
+# CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODETX is not set
+# CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODERX is not set
+CONFIG_SND_LPC32XX_SLAVE_TX_CLK_TO_RX=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_UDA1380=y
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_LPC32XX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+
+#
+# TI VLYNQ
+#
+# CONFIG_STAGING is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_JFFS2_FS_WBUF_VERIFY=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_PAGE_POISONING is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+CONFIG_DEBUG_ERRORS=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
diff --git a/arch/arm/mach-lpc32xx/Kconfig b/arch/arm/mach-lpc32xx/Kconfig
index fde6635..16f0f8c 100644
--- a/arch/arm/mach-lpc32xx/Kconfig
+++ b/arch/arm/mach-lpc32xx/Kconfig
@@ -1,6 +1,71 @@
 if ARCH_LPC32XX
 
-menu "Individual UART enable selections"
+choice
+    prompt "LPC32XX SoC based board implementations"
+    default MACH_PHY3250
+    help
+        This menu selects the LPC3250 board to support for this build
+
+    config MACH_PHY3250
+        bool "Phytec 3250 development board"
+        help
+            Support for the Phytec 3250 development board
+
+    config MACH_EA3250
+        bool "Embedded Artists LPC3250 Developer's Kit"
+        help
+            Support for the Embedded Artists LPC3250 Developer's Kit
+
+    config MACH_FDI3250
+        bool "Future Designs LPC3250 Touch screen kit"
+        help
+            Support for the Future Designs LPC3250 Touch screen kit
+
+endchoice
+
+menu "Embedded Artists Display Selection"
+	depends on MACH_EA3250
+
+config EA3250_QVGA_3_2_LCD
+	bool "3.2 inch QVGA LCD display (RGB565)"
+	help
+	  Use 3.2 inch QVGA LCD display
+
+config EA3250_QVGA_2_8_OLED
+	bool "2.8 inch QVGA OLED display (RGB565)"
+	help
+	  Use 2.8 inch QVGA OLED display
+
+endmenu
+
+
+config SOM9DIMM3250_LCD_PANEL
+	bool "Enables support for SOM9DIMM-LPC3250 (FDI board) LCDs"
+	depends on MACH_FDI3250
+	default TRUE
+	help
+	  Say Y here to enable QVGA/VGA panel support
+	  
+choice
+    prompt "FDI LCD Display"
+    depends on SOM9DIMM3250_LCD_PANEL
+    default SOM9DIMM3250_LCD_OKAYA_VGA
+    help
+        Select type of LCD display to be used.
+
+config SOM9DIMM3250_LCD_OKAYA_VGA_35
+    bool "OKAYA VGA LCD on 3-5 LCD CARRIER board"
+    help
+      Select this option if you are using an OKAYA RV640480T on a FDI 3-5 LCD CARRIER board
+      
+config SOM9DIMM3250_LCD_TOSHIBA_QVGA_35
+    bool "Toshiba QVGA LCD on 3-5 LCD CARRIER board"
+    help
+      Select this option if you are using a Toshiba LTA057A347F on a FDI 3-5 LCD CARRIER board
+
+endchoice
+
+menu "Standard UARTS"
 
 config ARCH_LPC32XX_UART3_SELECT
 	bool "Add support for standard UART3"
@@ -29,5 +94,42 @@ config ARCH_LPC32XX_UART6_SELECT
 
 endmenu
 
+menu "High speed UARTS"
+
+config ARCH_LPC32XX_HSUART1_SELECT
+        bool "Add support for high speed UART1"
+        help
+                Enables high speed UART1 as a TTYSx device
+
+config ARCH_LPC32XX_HSUART2_SELECT
+        bool "Add support for high speed UART2"
+        help
+                Enables high speed UART2 as a TTYSx device
+
+config ARCH_LPC32XX_HSUART7_SELECT
+        bool "Add support for high speed UART7"
+        help
+                Enables high speed UART7 as a TTYSx device
+
+endmenu
+
+menu "LPC32XX chip components"
+
+config ARCH_LPC32XX_IRAM_FOR_NET
+        bool "Use IRAM for network buffers"
+        help
+          If the total combined required buffer sizes is larger than the
+          size of IRAM, then SDRAM will be used instead.
+
+config ARCH_LPC32XX_MII_SUPPORT
+        bool "Check to enable MII support or leave disabled for RMII support"
+        default FALSE
+        help
+          Say Y here to enable MII support, or N to RMII support. Regardless of
+          which support is selected, the ethernet interface driver needs to be
+          selected in the device driver networking section.
+
+endmenu
+
 endif
 
diff --git a/arch/arm/mach-lpc32xx/Makefile b/arch/arm/mach-lpc32xx/Makefile
index a5fc5d0..44721a6 100644
--- a/arch/arm/mach-lpc32xx/Makefile
+++ b/arch/arm/mach-lpc32xx/Makefile
@@ -3,6 +3,8 @@
 #
 
 obj-y	:= timer.o irq.o common.o serial.o clock.o
-obj-y	+= gpiolib.o pm.o suspend.o
-obj-y	+= phy3250.o
+obj-y	+=  dma.o gpiolib.o pm.o suspend.o
+obj-$(CONFIG_MACH_PHY3250)	+= phy3250.o
+obj-$(CONFIG_MACH_EA3250)	+= ea3250.o
+obj-$(CONFIG_MACH_FDI3250)	+= fdi3250.o
 
diff --git a/arch/arm/mach-lpc32xx/clock.c b/arch/arm/mach-lpc32xx/clock.c
index da0e649..de47ace 100644
--- a/arch/arm/mach-lpc32xx/clock.c
+++ b/arch/arm/mach-lpc32xx/clock.c
@@ -86,6 +86,7 @@
 #include <linux/list.h>
 #include <linux/errno.h>
 #include <linux/device.h>
+#include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/amba/bus.h>
@@ -97,9 +98,12 @@
 #include "clock.h"
 #include "common.h"
 
+static DEFINE_SPINLOCK(global_clkregs_lock);
+
+static int usb_pll_enable, usb_pll_valid;
+
 static struct clk clk_armpll;
 static struct clk clk_usbpll;
-static DEFINE_MUTEX(clkm_lock);
 
 /*
  * Post divider values for PLLs based on selected register value
@@ -127,7 +131,7 @@ static struct clk osc_32KHz = {
 static int local_pll397_enable(struct clk *clk, int enable)
 {
 	u32 reg;
-	unsigned long timeout = 1 + msecs_to_jiffies(10);
+	unsigned long timeout = jiffies + msecs_to_jiffies(10);
 
 	reg = __raw_readl(LPC32XX_CLKPWR_PLL397_CTRL);
 
@@ -156,7 +160,7 @@ static int local_pll397_enable(struct clk *clk, int enable)
 static int local_oscmain_enable(struct clk *clk, int enable)
 {
 	u32 reg;
-	unsigned long timeout = 1 + msecs_to_jiffies(10);
+	unsigned long timeout = jiffies + msecs_to_jiffies(10);
 
 	reg = __raw_readl(LPC32XX_CLKPWR_MAIN_OSC_CTRL);
 
@@ -382,30 +386,63 @@ static u32 local_clk_usbpll_setup(struct clk_pll_setup *pHCLKPllSetup)
 static int local_usbpll_enable(struct clk *clk, int enable)
 {
 	u32 reg;
-	int ret = -ENODEV;
-	unsigned long timeout = 1 + msecs_to_jiffies(10);
+	int ret = 0;
+	unsigned long timeout = jiffies + msecs_to_jiffies(20);
 
 	reg = __raw_readl(LPC32XX_CLKPWR_USB_CTRL);
 
-	if (enable == 0) {
-		reg &= ~(LPC32XX_CLKPWR_USBCTRL_CLK_EN1 |
-			LPC32XX_CLKPWR_USBCTRL_CLK_EN2);
-		__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
-	} else if (reg & LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP) {
+	__raw_writel(reg & ~(LPC32XX_CLKPWR_USBCTRL_CLK_EN2 |
+		LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP),
+		LPC32XX_CLKPWR_USB_CTRL);
+	__raw_writel(reg & ~LPC32XX_CLKPWR_USBCTRL_CLK_EN1,
+		LPC32XX_CLKPWR_USB_CTRL);
+
+	if (enable && usb_pll_valid && usb_pll_enable) {
+		ret = -ENODEV;
+		/*
+		 * If the PLL rate has been previously set, then the rate
+		 * in the PLL register is valid and can be enabled here.
+		 * Otherwise, it needs to be enabled as part of setrate.
+		 */
+
+		/*
+		 * Gate clock into PLL
+		 */
 		reg |= LPC32XX_CLKPWR_USBCTRL_CLK_EN1;
 		__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
 
-		/* Wait for PLL lock */
-		while ((timeout > jiffies) & (ret == -ENODEV)) {
+		/*
+		 * Enable PLL
+		 */
+		reg |= LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP;
+		__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
+
+		/*
+		 * Wait for PLL to lock
+		 */
+		while ((timeout > jiffies) && (ret == -ENODEV)) {
 			reg = __raw_readl(LPC32XX_CLKPWR_USB_CTRL);
 			if (reg & LPC32XX_CLKPWR_USBCTRL_PLL_STS)
 				ret = 0;
+			else
+				udelay(10);
 		}
 
+		/*
+		 * Gate clock from PLL if PLL is locked
+		 */
 		if (ret == 0) {
-			reg |= LPC32XX_CLKPWR_USBCTRL_CLK_EN2;
-			__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
+			__raw_writel(reg | LPC32XX_CLKPWR_USBCTRL_CLK_EN2,
+				LPC32XX_CLKPWR_USB_CTRL);
+		}
+		else {
+			__raw_writel(reg & ~(LPC32XX_CLKPWR_USBCTRL_CLK_EN1 |
+				LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP),
+				LPC32XX_CLKPWR_USB_CTRL);
 		}
+	} else if ((enable == 0) && usb_pll_valid  && usb_pll_enable) {
+		usb_pll_valid = 0;
+		usb_pll_enable = 0;
 	}
 
 	return ret;
@@ -423,7 +460,7 @@ static unsigned long local_usbpll_round_rate(struct clk *clk,
 	 */
 	rate = rate * 1000;
 
-	clkin = clk->parent->rate;
+	clkin = clk->get_rate(clk);
 	usbdiv = (__raw_readl(LPC32XX_CLKPWR_USBCLK_PDIV) &
 		LPC32XX_CLKPWR_USBPDIV_PLL_MASK) + 1;
 	clkin = clkin / usbdiv;
@@ -437,7 +474,8 @@ static unsigned long local_usbpll_round_rate(struct clk *clk,
 
 static int local_usbpll_set_rate(struct clk *clk, unsigned long rate)
 {
-	u32 clkin, reg, usbdiv;
+	int ret = -ENODEV;
+	u32 clkin, usbdiv;
 	struct clk_pll_setup pllsetup;
 
 	/*
@@ -446,7 +484,7 @@ static int local_usbpll_set_rate(struct clk *clk, unsigned long rate)
 	 */
 	rate = rate * 1000;
 
-	clkin = clk->get_rate(clk);
+	clkin = clk->get_rate(clk->parent);
 	usbdiv = (__raw_readl(LPC32XX_CLKPWR_USBCLK_PDIV) &
 		LPC32XX_CLKPWR_USBPDIV_PLL_MASK) + 1;
 	clkin = clkin / usbdiv;
@@ -455,22 +493,25 @@ static int local_usbpll_set_rate(struct clk *clk, unsigned long rate)
 	if (local_clk_find_pll_cfg(clkin, rate, &pllsetup) == 0)
 		return -EINVAL;
 
+	/*
+	 * Disable PLL clocks during PLL change
+	 */
 	local_usbpll_enable(clk, 0);
-
-	reg = __raw_readl(LPC32XX_CLKPWR_USB_CTRL);
-	reg |= LPC32XX_CLKPWR_USBCTRL_CLK_EN1;
-	__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
-
-	pllsetup.analog_on = 1;
+	pllsetup.analog_on = 0;
 	local_clk_usbpll_setup(&pllsetup);
 
-	clk->rate = clk_check_pll_setup(clkin, &pllsetup);
+	/*
+	 * Start USB PLL and check PLL status
+	 */
 
-	reg = __raw_readl(LPC32XX_CLKPWR_USB_CTRL);
-	reg |= LPC32XX_CLKPWR_USBCTRL_CLK_EN2;
-	__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
+	usb_pll_valid = 1;
+	usb_pll_enable = 1;
 
-	return 0;
+	ret = local_usbpll_enable(clk, 1);
+	if (ret >= 0)
+		clk->rate = clk_check_pll_setup(clkin, &pllsetup);
+
+	return ret;
 }
 
 static struct clk clk_usbpll = {
@@ -730,6 +771,10 @@ static int mmc_onoff_enable(struct clk *clk, int enable)
 	if (enable != 0)
 		tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_EN;
 
+	/* Start clock at highest rate */
+	if (!(tmp & LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(0xF)))
+		tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(1);
+
 	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
 
 	return 0;
@@ -737,14 +782,9 @@ static int mmc_onoff_enable(struct clk *clk, int enable)
 
 static unsigned long mmc_get_rate(struct clk *clk)
 {
-	u32 div, rate, oldclk;
+	u32 div, rate;
 
-	/* The MMC clock must be on when accessing an MMC register */
-	oldclk = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
-	__raw_writel(oldclk | LPC32XX_CLKPWR_MSCARD_SDCARD_EN,
-		LPC32XX_CLKPWR_MS_CTRL);
 	div = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
-	__raw_writel(oldclk, LPC32XX_CLKPWR_MS_CTRL);
 
 	/* Get the parent clock rate */
 	rate = clk->parent->get_rate(clk->parent);
@@ -772,12 +812,19 @@ static unsigned long mmc_round_rate(struct clk *clk, unsigned long rate)
 	if (div > 0xf)
 		div = 0xf;
 
+	/*
+	 * The divider is forced to 1 to keep the SD clock granularity
+	 * good. Using a non-0 divider will limit the SD card clock rates
+	 * the SD driver can generate. Remove it if your feeling crazy.
+	 */
+	div = 1;
+
 	return prate / div;
 }
 
 static int mmc_set_rate(struct clk *clk, unsigned long rate)
 {
-	u32 oldclk, tmp;
+	u32 tmp;
 	unsigned long prate, div, crate = mmc_round_rate(clk, rate);
 
 	prate = clk->parent->get_rate(clk->parent);
@@ -785,19 +832,17 @@ static int mmc_set_rate(struct clk *clk, unsigned long rate)
 	div = prate / crate;
 
 	/* The MMC clock must be on when accessing an MMC register */
-	oldclk = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
-	__raw_writel(oldclk | LPC32XX_CLKPWR_MSCARD_SDCARD_EN,
-		LPC32XX_CLKPWR_MS_CTRL);
 	tmp = __raw_readl(LPC32XX_CLKPWR_MS_CTRL) &
 		~LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(0xf);
 	tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(div);
 	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
 
-	__raw_writel(oldclk, LPC32XX_CLKPWR_MS_CTRL);
-
 	return 0;
 }
 
+/*
+ * This is the MMC IP clock, not the MMC CLK signal rate!
+ */
 static struct clk clk_mmc = {
 	.parent		= &clk_armpll,
 	.set_rate	= mmc_set_rate,
@@ -891,19 +936,9 @@ static struct clk clk_lcd = {
 	.enable_mask	= LPC32XX_CLKPWR_LCDCTRL_CLK_EN,
 };
 
-static inline void clk_lock(void)
-{
-	mutex_lock(&clkm_lock);
-}
-
-static inline void clk_unlock(void)
-{
-	mutex_unlock(&clkm_lock);
-}
-
 static void local_clk_disable(struct clk *clk)
 {
-	WARN_ON(clk->usecount == 0);
+	// WARN_ON(clk->usecount == 0);
 
 	/* Don't attempt to disable clock if it has no users */
 	if (clk->usecount > 0) {
@@ -947,10 +982,11 @@ static int local_clk_enable(struct clk *clk)
 int clk_enable(struct clk *clk)
 {
 	int ret;
+	unsigned long flags;
 
-	clk_lock();
+	spin_lock_irqsave(&global_clkregs_lock, flags);
 	ret = local_clk_enable(clk);
-	clk_unlock();
+	spin_unlock_irqrestore(&global_clkregs_lock, flags);
 
 	return ret;
 }
@@ -961,9 +997,11 @@ EXPORT_SYMBOL(clk_enable);
  */
 void clk_disable(struct clk *clk)
 {
-	clk_lock();
+	unsigned long flags;
+
+	spin_lock_irqsave(&global_clkregs_lock, flags);
 	local_clk_disable(clk);
-	clk_unlock();
+	spin_unlock_irqrestore(&global_clkregs_lock, flags);
 }
 EXPORT_SYMBOL(clk_disable);
 
@@ -972,13 +1010,7 @@ EXPORT_SYMBOL(clk_disable);
  */
 unsigned long clk_get_rate(struct clk *clk)
 {
-	unsigned long rate;
-
-	clk_lock();
-	rate = clk->get_rate(clk);
-	clk_unlock();
-
-	return rate;
+	return clk->get_rate(clk);
 }
 EXPORT_SYMBOL(clk_get_rate);
 
@@ -994,11 +1026,8 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	 * the actual rate set as part of the peripheral dividers
 	 * instead of high level clock control
 	 */
-	if (clk->set_rate) {
-		clk_lock();
+	if (clk->set_rate)
 		ret = clk->set_rate(clk, rate);
-		clk_unlock();
-	}
 
 	return ret;
 }
@@ -1009,15 +1038,11 @@ EXPORT_SYMBOL(clk_set_rate);
  */
 long clk_round_rate(struct clk *clk, unsigned long rate)
 {
-	clk_lock();
-
 	if (clk->round_rate)
 		rate = clk->round_rate(clk, rate);
 	else
 		rate = clk->get_rate(clk);
 
-	clk_unlock();
-
 	return rate;
 }
 EXPORT_SYMBOL(clk_round_rate);
@@ -1075,10 +1100,10 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("dev:ssp1", NULL, clk_ssp1)
 	_REGISTER_CLOCK("lpc32xx_keys.0", NULL, clk_kscan)
 	_REGISTER_CLOCK("lpc32xx-nand.0", "nand_ck", clk_nand)
-	_REGISTER_CLOCK("tbd", "i2s0_ck", clk_i2s0)
-	_REGISTER_CLOCK("tbd", "i2s1_ck", clk_i2s1)
+	_REGISTER_CLOCK(NULL, "i2s0_ck", clk_i2s0)
+	_REGISTER_CLOCK(NULL, "i2s1_ck", clk_i2s1)
 	_REGISTER_CLOCK("lpc32xx-ts", NULL, clk_tsc)
-	_REGISTER_CLOCK("dev:mmc0", "MCLK", clk_mmc)
+	_REGISTER_CLOCK("dev:mmc0", NULL, clk_mmc)
 	_REGISTER_CLOCK("lpc-net.0", NULL, clk_net)
 	_REGISTER_CLOCK("dev:clcd", NULL, clk_lcd)
 	_REGISTER_CLOCK("lpc32xx_udc", "ck_usbd", clk_usbd)
diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index ee24dc2..5b357e3 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -30,6 +30,7 @@
 #include <mach/i2c.h>
 #include <mach/hardware.h>
 #include <mach/platform.h>
+#include <mach/board.h>
 #include "common.h"
 
 /*
@@ -51,6 +52,28 @@ struct platform_device lpc32xx_watchdog_device = {
 };
 
 /*
+ * Real Time Clock
+ */
+static struct resource rtc_resources[] = {
+	[0] = {
+		.start = LPC32XX_RTC_BASE,
+		.end = LPC32XX_RTC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_RTC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lpc32xx_rtc_device = {
+	.name =  "rtc-lpc32xx",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(rtc_resources),
+	.resource = rtc_resources,
+};
+
+/*
  * I2C busses
  */
 static struct i2c_pnx_data i2c0_data = {
@@ -96,6 +119,140 @@ struct platform_device lpc32xx_i2c2_device = {
 };
 
 /*
+ * Touch Screen support
+ */
+static struct resource tsc_resources[] = {
+	[0] = {
+		.start = LPC32XX_ADC_BASE,
+		.end = LPC32XX_ADC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_TS_IRQ,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+struct platform_device lpc32xx_tsc_device = {
+	.name =  "lpc32xx-ts",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(tsc_resources),
+	.resource = tsc_resources,
+};
+
+#if defined (CONFIG_USB_OHCI_HCD)
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32) 0;
+static struct resource ohci_resources[] = {
+	{
+		.start = IO_ADDRESS(LPC32XX_USB_BASE),
+		.end = IO_ADDRESS(LPC32XX_USB_BASE + 0x100),
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = IRQ_LPC32XX_USB_HOST,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+struct platform_device lpc32xx_ohci_device = {
+	.name = "usb-ohci",
+	.id = -1,
+	.dev = {
+		.dma_mask = &ohci_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+	.num_resources = ARRAY_SIZE(ohci_resources),
+	.resource = ohci_resources,
+};
+#endif
+
+
+#if defined(CONFIG_USB_GADGET_LPC32XX)
+static void phy3250_usbd_conn_chg(int conn) {
+	/* Do nothing, it might be nice to enable an LED
+	 * based on conn state being !0 */
+}
+
+static void phy3250_usbd_susp_chg(int susp) {
+    /* Device suspend if susp != 0 */
+}
+
+static void phy3250_rmwkup_chg(int remote_wakup_enable) {
+    /* Enable or disable USB remote wakeup */
+}
+
+struct lpc32xx_usbd_cfg lpc32xx_usbddata = {
+	.vbus_drv_pol = 1,
+	.conn_chgb = &phy3250_usbd_conn_chg,
+	.susp_chgb = &phy3250_usbd_susp_chg,
+	.rmwk_chgb = &phy3250_rmwkup_chg,
+};
+
+/* The dmamask must be set for OHCI to work, align to 128 bytes */
+static u64 usbd_dmamask = ~(u32) 0x7F;
+static struct resource usbd_resources[] = {
+	{
+		.start = LPC32XX_USB_BASE,
+		.end = LPC32XX_USB_BASE + 0x100,
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = IRQ_LPC32XX_USB_DEV_LP,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.start = IRQ_LPC32XX_USB_DEV_HP,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.start = IRQ_LPC32XX_USB_DEV_DMA,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.start = IRQ_LPC32XX_USB_OTG_ATX,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lpc32xx_usbd_device = {
+	.name = "lpc32xx_udc",
+	.id = -1,
+	.dev = {
+		.dma_mask = &usbd_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		.platform_data  = &lpc32xx_usbddata,
+	},
+	.num_resources = ARRAY_SIZE(usbd_resources),
+	.resource = usbd_resources,
+};
+#endif
+
+/*
+ * I2S
+ */
+static struct resource i2s_resources[] = {
+	[0] = {
+		.start = LPC32XX_I2S0_BASE,
+		.end = LPC32XX_I2S0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = LPC32XX_I2S1_BASE,
+		.end = LPC32XX_I2S1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device lpc32xx_i2s_device = {
+	.name = "lpc3xxx-i2s",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(i2s_resources),
+	.resource = i2s_resources,
+};
+
+/*
+ * ASOC platform device
+ */
+struct platform_device lpc32xx_asoc_plat_device = {
+	.name = "lpc3xxx-audio",
+	.id = 0,
+};
+
+/*
  * Returns the unique ID for the device
  */
 void lpc32xx_get_uid(u32 devid[4])
diff --git a/arch/arm/mach-lpc32xx/common.h b/arch/arm/mach-lpc32xx/common.h
index f82211f..7cf0a3f 100644
--- a/arch/arm/mach-lpc32xx/common.h
+++ b/arch/arm/mach-lpc32xx/common.h
@@ -19,6 +19,8 @@
 #ifndef __LPC32XX_COMMON_H
 #define __LPC32XX_COMMON_H
 
+#include <linux/pm.h>
+#include <linux/suspend.h>
 #include <linux/platform_device.h>
 
 /*
@@ -28,6 +30,12 @@ extern struct platform_device lpc32xx_watchdog_device;
 extern struct platform_device lpc32xx_i2c0_device;
 extern struct platform_device lpc32xx_i2c1_device;
 extern struct platform_device lpc32xx_i2c2_device;
+extern struct platform_device lpc32xx_tsc_device;
+extern struct platform_device lpc32xx_rtc_device;
+extern struct platform_device lpc32xx_ohci_device;
+extern struct platform_device lpc32xx_usbd_device;
+extern struct platform_device lpc32xx_i2s_device;
+extern struct platform_device lpc32xx_asoc_plat_device;
 
 /*
  * Other arch specific structures and functions
@@ -64,6 +72,10 @@ extern void lpc32xx_get_uid(u32 devid[4]);
 extern void lpc32xx_watchdog_reset(void);
 extern u32 lpc32xx_return_iram_size(void);
 
+/* Power Management functions */
+extern void lpc32xx_irq_suspend(suspend_state_t state);
+extern void lpc32xx_irq_resume(suspend_state_t state);
+
 /*
  * Pointers used for sizing and copying suspend function data
  */
diff --git a/arch/arm/mach-lpc32xx/dma.c b/arch/arm/mach-lpc32xx/dma.c
new file mode 100644
index 0000000..3dfec4b
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/dma.c
@@ -0,0 +1,761 @@
+/*
+ *  linux/arch/arm/mach-lpc32xx/ma-lpc32xx.c
+ *
+ *  Copyright (C) 2008 NXP Semiconductors
+ *  (Based on parts of the PNX4008 DMA driver)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <asm/dma-mapping.h>
+#include <asm/io.h>
+#include <mach/dma.h>
+#include <mach/dmac.h>
+
+#define DMAIOBASE io_p2v(LPC32XX_DMA_BASE)
+#define VALID_CHANNEL(c) (((c) >= 0) && ((c) < MAX_DMA_CHANNELS))
+
+static DEFINE_SPINLOCK(dma_lock);
+
+struct dma_linked_list {
+	u32 src;
+	u32 dest;
+	u32 next_lli;
+	u32 ctrl;
+};
+
+/* For DMA linked list operation, a linked list of DMA descriptors
+   is maintained along with some data to manage the list in software. */
+struct dma_list_ctrl {
+	struct dma_linked_list dmall; /* DMA list descriptor */
+	struct dma_list_ctrl *next_list_addr;   /* Virtual address to next list entry */
+        struct dma_list_ctrl *prev_list_addr;   /* Virtual address to previous list entry */
+	u32 next_list_phy;    /* Physical address to next list entry */
+        u32 prev_list_phy;    /* Physical address to previous list entry */
+};
+
+/* Each DMA channel has one of these structures */
+struct dma_channel {
+	char *name;
+	void (*irq_handler) (int, int, void *);
+	void *data;
+	struct dma_config *dmacfg;
+	u32 control;
+	u32 config;
+	u32 config_int_mask;
+
+	int list_entries; /* Number of list entries */
+	u32 list_size; /* Total size of allocated list in bytes */
+	u32 list_vstart; /* Allocated (virtual) address of list */
+	u32 list_pstart; /* Allocated (physical) address of list */
+	int free_entries; /* Number of free descriptors */
+	struct dma_list_ctrl *list_head, *list_tail, *list_curr;
+};
+
+struct dma_control {
+	struct clk *clk;
+	int num_clks;
+	struct dma_channel dma_channels[MAX_DMA_CHANNELS];
+};
+static struct dma_control dma_ctrl;
+static unsigned long flags;
+
+static inline void __dma_regs_lock(void)
+{
+	spin_lock_irqsave(&dma_lock, flags);
+}
+
+static inline void __dma_regs_unlock(void)
+{
+	spin_unlock_irqrestore(&dma_lock, flags);
+}
+
+static inline void __dma_enable(int ch) {
+	u32 ch_cfg = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	ch_cfg |= DMAC_CHAN_ENABLE;
+	__raw_writel(ch_cfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+}
+
+static inline void __dma_disable(int ch) {
+	u32 ch_cfg = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	ch_cfg &= ~DMAC_CHAN_ENABLE;
+	__raw_writel(ch_cfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+}
+
+static void dma_clocks_up(void)
+{
+	/* Enable DMA clock if needed */
+	if (dma_ctrl.num_clks == 0)
+	{
+		clk_enable(dma_ctrl.clk);
+		__raw_writel(DMAC_CTRL_ENABLE, DMA_CONFIG(DMAIOBASE));
+	}
+
+	dma_ctrl.num_clks++;
+}
+
+static void dma_clocks_down(void)
+{
+	dma_ctrl.num_clks--;
+
+	/* Disable DMA clock if needed */
+	if (dma_ctrl.num_clks == 0)
+	{
+		__raw_writel(0, DMA_CONFIG(DMAIOBASE));
+		clk_disable(dma_ctrl.clk);
+	}
+}
+
+static int lpc32xx_ch_setup(struct dma_config *dmachcfg)
+{
+	u32 tmpctrl, tmpcfg, tmp;
+	int ch = dmachcfg->ch;
+
+	/* Channel control setup */
+	tmpctrl = 0;
+	switch (dmachcfg->src_size)
+	{
+		case 1:
+			tmpctrl |= DMAC_CHAN_SRC_WIDTH_8;
+			break;
+
+		case 2:
+			tmpctrl |= DMAC_CHAN_SRC_WIDTH_16;
+			break;
+
+		case 4:
+			tmpctrl |= DMAC_CHAN_SRC_WIDTH_32;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+	switch (dmachcfg->dst_size)
+	{
+		case 1:
+			tmpctrl |= DMAC_CHAN_DEST_WIDTH_8;
+			break;
+
+		case 2:
+			tmpctrl |= DMAC_CHAN_DEST_WIDTH_16;
+			break;
+
+		case 4:
+			tmpctrl |= DMAC_CHAN_DEST_WIDTH_32;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+	if (dmachcfg->src_inc != 0)
+	{
+		tmpctrl |= DMAC_CHAN_SRC_AUTOINC;
+	}
+	if (dmachcfg->dst_inc != 0)
+	{
+		tmpctrl |= DMAC_CHAN_DEST_AUTOINC;
+	}
+	if (dmachcfg->src_ahb1 != 0)
+	{
+		tmpctrl |= DMAC_CHAN_SRC_AHB1;
+	}
+	if (dmachcfg->dst_ahb1 != 0)
+	{
+		tmpctrl |= DMAC_CHAN_DEST_AHB1;
+	}
+	if (dmachcfg->tc_inten != 0)
+	{
+		tmpctrl |= DMAC_CHAN_INT_TC_EN;
+	}
+	tmpctrl |= dmachcfg->src_bsize | dmachcfg->dst_bsize;
+	dma_ctrl.dma_channels[ch].control = tmpctrl;
+
+	/* Channel config setup */
+	tmpcfg = dmachcfg->src_prph | dmachcfg->dst_prph |
+		dmachcfg->flowctrl;
+	dma_ctrl.dma_channels[ch].config = tmpcfg;
+
+	dma_ctrl.dma_channels[ch].config_int_mask = 0;
+	if (dmachcfg->err_inten != 0)
+	{
+		dma_ctrl.dma_channels[ch].config_int_mask |=
+			DMAC_CHAN_IE;
+	}
+	if (dmachcfg->tc_inten != 0)
+	{
+		dma_ctrl.dma_channels[ch].config_int_mask |=
+			DMAC_CHAN_ITC;
+	}
+
+	tmp = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	tmp &= ~DMAC_CHAN_ENABLE;
+	__raw_writel(tmp, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	/* Clear interrupts for channel */
+	__raw_writel((1 << ch), DMA_INT_TC_CLEAR(DMAIOBASE));
+	__raw_writel((1 << ch), DMA_INT_ERR_CLEAR(DMAIOBASE));
+
+	/* Write control and config words */
+	__raw_writel(tmpctrl, DMACH_CONTROL(DMAIOBASE, ch));
+	__raw_writel(tmpcfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	return 0;
+}
+
+int lpc32xx_dma_ch_enable(int ch)
+{
+	if (!VALID_CHANNEL(ch) || !dma_ctrl.dma_channels[ch].name)
+		return -EINVAL;
+
+	__dma_regs_lock();
+	__dma_enable(ch);
+	__dma_regs_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_enable);
+
+int lpc32xx_dma_ch_disable(int ch)
+{
+	if (!VALID_CHANNEL(ch) || !dma_ctrl.dma_channels[ch].name)
+		return -EINVAL;
+
+	__dma_regs_lock();
+	__dma_disable(ch);
+	__dma_regs_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_disable);
+
+int lpc32xx_dma_ch_get(struct dma_config *dmachcfg, char *name,
+		void *irq_handler, void *data) {
+	int ret;
+
+	if (!VALID_CHANNEL(dmachcfg->ch))
+		return -EINVAL;
+
+	/* If the channel is already enabled, return */
+	if (dma_ctrl.dma_channels[dmachcfg->ch].name != NULL)
+		return -ENODEV;
+
+	/* Save channel data */
+	dma_ctrl.dma_channels[dmachcfg->ch].dmacfg = dmachcfg;
+	dma_ctrl.dma_channels[dmachcfg->ch].name = name;
+	dma_ctrl.dma_channels[dmachcfg->ch].irq_handler = irq_handler;
+	dma_ctrl.dma_channels[dmachcfg->ch].data = data;
+
+	/* Setup channel */
+	__dma_regs_lock();
+	dma_clocks_up();
+	ret = lpc32xx_ch_setup(dmachcfg);
+	__dma_regs_unlock();
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_get);
+
+int lpc32xx_dma_ch_put(int ch)
+{
+	u32 tmp;
+
+	if (!VALID_CHANNEL(ch))
+		return -EINVAL;
+
+	/* If the channel is already disabled, return */
+	if (dma_ctrl.dma_channels[ch].name == NULL)
+		return -EINVAL;
+
+	tmp = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	tmp &= ~DMAC_CHAN_ENABLE;
+	__raw_writel(tmp, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	__dma_regs_lock();
+	lpc32xx_dma_ch_disable(ch);
+	dma_clocks_down();
+	__dma_regs_unlock();
+
+	dma_ctrl.dma_channels[ch].name = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_put);
+
+int lpc32xx_dma_ch_pause_unpause(int ch, int pause) {
+	u32 tmp;
+
+	if (!VALID_CHANNEL(ch))
+		return -EINVAL;
+
+	/* If the channel is already disabled, return */
+	if (dma_ctrl.dma_channels[ch].name == NULL)
+		return -EINVAL;
+
+	tmp = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	if (pause) {
+		tmp |= DMAC_CHAN_HALT;
+	}
+	else {
+		tmp &= ~DMAC_CHAN_HALT;
+	}
+	__raw_writel(tmp, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_pause_unpause);
+
+int lpc32xx_dma_start_pflow_xfer(int ch,
+				void *src,
+				void *dst,
+				int enable)
+{
+	u32 tmp;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL))
+		return -EINVAL;
+
+	/* When starting a DMA transfer where the peripheral is the flow
+	   controller, DMA must be previously disabled */
+	tmp = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	if (tmp & DMAC_CHAN_ENABLE)
+		return -EBUSY;
+
+	__dma_regs_lock();
+	__raw_writel((u32) src, DMACH_SRC_ADDR(DMAIOBASE, ch));
+	__raw_writel((u32) dst, DMACH_DEST_ADDR(DMAIOBASE, ch));
+	__raw_writel(0, DMACH_LLI(DMAIOBASE, ch));
+	__raw_writel(dma_ctrl.dma_channels[ch].control, DMACH_CONTROL(DMAIOBASE, ch));
+
+	tmp = dma_ctrl.dma_channels[ch].config |
+		dma_ctrl.dma_channels[ch].config_int_mask;
+	if (enable != 0)
+		tmp |= DMAC_CHAN_ENABLE;
+	__raw_writel(tmp, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	__dma_regs_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_start_pflow_xfer);
+
+int lpc32xx_dma_is_active(int ch)
+{
+	int active = 0;
+
+	if ((VALID_CHANNEL(ch)) && (dma_ctrl.dma_channels[ch].name != NULL)) {
+		if (__raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch)) &
+			DMAC_CHAN_ENABLE)
+			active = 1;
+	}
+
+	return active;
+
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_is_active);
+
+extern u32 lpc32xx_dma_llist_v_to_p(int ch,
+				    u32 vlist) {
+	u32 pptr;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	pptr = vlist - dma_ctrl.dma_channels[ch].list_vstart;
+	pptr += dma_ctrl.dma_channels[ch].list_pstart;
+
+	return pptr;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_llist_v_to_p);
+
+u32 lpc32xx_dma_llist_p_to_v(int ch,
+			     u32 plist) {
+	u32 vptr;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	vptr = plist - dma_ctrl.dma_channels[ch].list_pstart;
+	vptr += dma_ctrl.dma_channels[ch].list_vstart;
+
+	return vptr;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_llist_p_to_v);
+
+u32 lpc32xx_dma_alloc_llist(int ch,
+			     int entries) {
+	int i;
+	dma_addr_t dma_handle;
+	struct dma_list_ctrl *pdmalist, *pdmalistst;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL))
+		return 0;
+
+	/*
+	 * Limit number of list entries, but add 1 extra entry as a spot holder
+	 * for the end of the list
+	 */
+	if (entries < 2) {
+		entries = 2;
+	}
+	if (entries > 64) {
+		entries = 64;
+	}
+	entries++;
+
+	/* Save list information */
+	dma_ctrl.dma_channels[ch].list_entries = entries;
+	dma_ctrl.dma_channels[ch].list_size = (entries * sizeof(struct dma_list_ctrl));
+	dma_ctrl.dma_channels[ch].list_vstart = (u32) dma_alloc_coherent(NULL,
+		dma_ctrl.dma_channels[ch].list_size, &dma_handle, GFP_KERNEL);
+	if (dma_ctrl.dma_channels[ch].list_vstart == 0) {
+		/* No allocated DMA space */
+		return 0;
+	}
+	dma_ctrl.dma_channels[ch].list_pstart = (u32) dma_handle;
+
+	/* Setup list tail and head pointers */
+	pdmalist = pdmalistst = (struct dma_list_ctrl *) dma_ctrl.dma_channels[ch].list_vstart;
+	for (i = 0; i < entries; i++) {
+		pdmalistst->next_list_addr = pdmalistst + 1;
+		pdmalistst->prev_list_addr = pdmalistst - 1;
+		pdmalistst->next_list_phy = lpc32xx_dma_llist_v_to_p(ch, (u32) pdmalistst->next_list_addr);
+		pdmalistst->prev_list_phy = lpc32xx_dma_llist_v_to_p(ch, (u32) pdmalistst->prev_list_addr);
+		pdmalistst++;
+	}
+	pdmalist[entries - 1].next_list_addr = pdmalist;
+	pdmalist[entries - 1].next_list_phy = lpc32xx_dma_llist_v_to_p(ch,
+		(u32) pdmalist[entries - 1].next_list_addr);
+	pdmalist->prev_list_addr = &pdmalist[entries - 1];
+	pdmalist->prev_list_phy = lpc32xx_dma_llist_v_to_p(ch, (u32) pdmalist->prev_list_addr);
+
+	/* Save current free descriptors and current head/tail */
+	dma_ctrl.dma_channels[ch].free_entries = entries - 1;
+	dma_ctrl.dma_channels[ch].list_head = pdmalist;
+	dma_ctrl.dma_channels[ch].list_tail = pdmalist;
+	dma_ctrl.dma_channels[ch].list_curr = pdmalist;
+
+	return dma_ctrl.dma_channels[ch].list_vstart;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_alloc_llist);
+
+void lpc32xx_dma_dealloc_llist(int ch) {
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return;
+
+	dma_free_coherent(NULL, dma_ctrl.dma_channels[ch].list_size,
+		(void *) dma_ctrl.dma_channels[ch].list_vstart,
+		(dma_addr_t) dma_ctrl.dma_channels[ch].list_pstart);
+	dma_ctrl.dma_channels[ch].list_head = 0;
+	dma_ctrl.dma_channels[ch].list_tail = 0;
+	dma_ctrl.dma_channels[ch].list_entries = 0;
+	dma_ctrl.dma_channels[ch].free_entries = 0;
+	dma_ctrl.dma_channels[ch].list_vstart = 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_dealloc_llist);
+
+extern u32 lpc32xx_dma_get_llist_head(int ch) {
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	/* Return the current list pointer (virtual) for the
+	   DMA channel */
+	return lpc32xx_dma_llist_p_to_v(ch,
+		__raw_readl(DMACH_LLI(DMAIOBASE, ch)));
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_get_llist_head);
+
+extern void lpc32xx_dma_flush_llist(int ch) {
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return;
+
+	/* Disable channel and clear LLI */
+	__dma_regs_lock();
+	__dma_disable(ch);
+	__raw_writel(0, DMACH_LLI(DMAIOBASE, ch));
+	__dma_regs_unlock();
+
+	dma_ctrl.dma_channels[ch].list_head = (struct dma_list_ctrl *)
+		dma_ctrl.dma_channels[ch].list_vstart;
+	dma_ctrl.dma_channels[ch].list_tail = (struct dma_list_ctrl *)
+		dma_ctrl.dma_channels[ch].list_vstart;
+	dma_ctrl.dma_channels[ch].list_curr = (struct dma_list_ctrl *)
+		dma_ctrl.dma_channels[ch].list_vstart;
+	dma_ctrl.dma_channels[ch].free_entries =
+		dma_ctrl.dma_channels[ch].list_entries - 1;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_flush_llist);
+
+u32 lpc32xx_dma_queue_llist_entry(int ch,
+				  void *src,
+				  void *dst,
+				  int size) {
+	struct dma_list_ctrl *plhead;
+	u32 ctrl, cfg;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	/* Exit if all the buffers are used */
+	if (dma_ctrl.dma_channels[ch].free_entries == 0) {
+		return 0;
+	}
+
+	/* Next available DMA link descriptor */
+	plhead = dma_ctrl.dma_channels[ch].list_head;
+
+	/* Adjust size to number of transfers (vs bytes) */
+	size = size / dma_ctrl.dma_channels[ch].dmacfg->dst_size;
+
+	/* Setup control and config words */
+	ctrl = dma_ctrl.dma_channels[ch].control | size;
+	cfg = dma_ctrl.dma_channels[ch].config | DMAC_CHAN_ENABLE |
+		dma_ctrl.dma_channels[ch].config_int_mask;
+
+	/* Populate DMA linked data structure */
+	plhead->dmall.src = (u32) src;
+	plhead->dmall.dest = (u32) dst;
+	plhead->dmall.next_lli = 0;
+	plhead->dmall.ctrl = ctrl;
+
+	__dma_regs_lock();
+
+	/* Append this link to the end of the previous link */
+	plhead->prev_list_addr->dmall.next_lli = lpc32xx_dma_llist_v_to_p(ch, (u32) plhead);
+
+	/* Decrement available buffers */
+	dma_ctrl.dma_channels[ch].free_entries--;
+
+	/* If the DMA channel is idle, then the buffer needs to be placed directly into
+	   the DMA registers */
+	if ((__raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch)) & DMAC_CHAN_ENABLE) == 0) {
+		/* DMA is disabled, so move the current buffer into the
+		   channel registers and start transfer */
+		__raw_writel((u32) src, DMACH_SRC_ADDR(DMAIOBASE, ch));
+		__raw_writel((u32) dst, DMACH_DEST_ADDR(DMAIOBASE, ch));
+		__raw_writel(0, DMACH_LLI(DMAIOBASE, ch));
+		__raw_writel(ctrl, DMACH_CONTROL(DMAIOBASE, ch));
+		__raw_writel(cfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+	}
+	else if (__raw_readl(DMACH_LLI(DMAIOBASE, ch)) == 0) {
+		/* Update current entry to next entry */
+		__raw_writel(dma_ctrl.dma_channels[ch].list_tail->next_list_phy,
+			DMACH_LLI(DMAIOBASE, ch));
+
+		/*
+		 * If the channel was stopped before the next entry made it into the
+		 * hardware descriptor, the next entry didn't make it there fast enough,
+		 * so load the new descriptor here.
+		 */
+		if ((__raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch)) & DMAC_CHAN_ENABLE) == 0) {
+			__raw_writel((u32) src, DMACH_SRC_ADDR(DMAIOBASE, ch));
+			__raw_writel((u32) dst, DMACH_DEST_ADDR(DMAIOBASE, ch));
+			__raw_writel(0, DMACH_LLI(DMAIOBASE, ch));
+			__raw_writel(ctrl, DMACH_CONTROL(DMAIOBASE, ch));
+			__raw_writel(cfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+		}
+	}
+
+	/* Process next link on next call */
+	dma_ctrl.dma_channels[ch].list_head = plhead->next_list_addr;
+
+	__dma_regs_unlock();
+
+	return (u32) plhead;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_queue_llist_entry);
+
+extern u32 lpc32xx_get_free_llist_entry(int ch) {
+	struct dma_list_ctrl *pltail;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	/* Exit if no entries to free */
+	if (dma_ctrl.dma_channels[ch].free_entries ==
+		dma_ctrl.dma_channels[ch].list_entries) {
+		return 0;
+	}
+
+	/* Get tail pointer */
+	pltail = dma_ctrl.dma_channels[ch].list_tail;
+
+	/* Next tail */
+	dma_ctrl.dma_channels[ch].list_tail = pltail->next_list_addr;
+
+	/* Increment available buffers */
+	dma_ctrl.dma_channels[ch].free_entries++;
+
+	return (u32) pltail;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_get_free_llist_entry);
+
+int lpc32xx_dma_start_xfer(int ch, u32 config)
+{
+	struct dma_list_ctrl *plhead;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return -1;
+
+	plhead = dma_ctrl.dma_channels[ch].list_head;
+	__dma_regs_lock();
+	__raw_writel(plhead->dmall.src, DMACH_SRC_ADDR(DMAIOBASE, ch));
+	__raw_writel(plhead->dmall.dest, DMACH_DEST_ADDR(DMAIOBASE, ch));
+	__raw_writel(plhead->dmall.next_lli, DMACH_LLI(DMAIOBASE, ch));
+	__raw_writel(plhead->dmall.ctrl, DMACH_CONTROL(DMAIOBASE, ch));
+	__raw_writel(config, DMACH_CONFIG_CH(DMAIOBASE, ch));
+	__dma_regs_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_start_xfer);
+
+u32 lpc32xx_dma_queue_llist(int ch, void *src, void *dst,
+				  int size, u32 ctrl)
+{
+	struct dma_list_ctrl *plhead;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	/* Exit if all the buffers are used */
+	if (dma_ctrl.dma_channels[ch].free_entries == 0) {
+		return 0;
+	}
+
+	/* Next available DMA link descriptor */
+	plhead = dma_ctrl.dma_channels[ch].list_curr;
+
+	/* Populate DMA linked data structure */
+	plhead->dmall.src = (u32) src;
+	plhead->dmall.dest = (u32) dst;
+	plhead->dmall.next_lli = 0;
+	plhead->dmall.ctrl = ctrl;
+
+	/* Append this link to the end of the previous link */
+	plhead->prev_list_addr->dmall.next_lli = lpc32xx_dma_llist_v_to_p(ch, (u32) plhead);
+
+	/* Decrement available buffers */
+	dma_ctrl.dma_channels[ch].free_entries--;
+
+	/* Process next link on next call */
+	dma_ctrl.dma_channels[ch].list_curr = plhead->next_list_addr;
+
+	return (u32) plhead;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_queue_llist);
+
+extern void lpc32xx_dma_force_burst(int ch, int src)
+{
+	__raw_writel(1 << src, DMA_SW_BURST_REQ(DMAIOBASE));
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_force_burst);
+
+static irqreturn_t dma_irq_handler(int irq, void *dev_id)
+{
+	int i;
+	unsigned long dint = __raw_readl(DMA_INT_STAT(DMAIOBASE));
+	unsigned long tcint = __raw_readl(DMA_INT_TC_STAT(DMAIOBASE));
+	unsigned long eint = __raw_readl(DMA_INT_ERR_STAT(DMAIOBASE));
+	unsigned long i_bit;
+
+	for (i = MAX_DMA_CHANNELS - 1; i >= 0; i--) {
+		i_bit = 1 << i;
+		if (dint & i_bit) {
+			struct dma_channel *channel = &dma_ctrl.dma_channels[i];
+
+			if (channel->name && channel->irq_handler) {
+				int cause = 0;
+
+				if (eint & i_bit) {
+					__raw_writel(i_bit, DMA_INT_ERR_CLEAR(DMAIOBASE));
+					cause |= DMA_ERR_INT;
+				}
+				if (tcint & i_bit) {
+					__raw_writel(i_bit, DMA_INT_TC_CLEAR(DMAIOBASE));
+					cause |= DMA_TC_INT;
+				}
+
+				channel->irq_handler(i, cause, channel->data);
+			} else {
+				/*
+				 * IRQ for an unregistered DMA channel
+				 */
+				__raw_writel(i_bit, DMA_INT_ERR_CLEAR(DMAIOBASE));
+				__raw_writel(i_bit, DMA_INT_TC_CLEAR(DMAIOBASE));
+				printk(KERN_WARNING
+				       "spurious IRQ for DMA channel %d\n", i);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init lpc32xx_dma_init(void)
+{
+	int ret;
+
+	ret = request_irq(IRQ_LPC32XX_DMA, dma_irq_handler, 0, "DMA", NULL);
+	if (ret) {
+		printk(KERN_CRIT "Wow!  Can't register IRQ for DMA\n");
+		goto out;
+	}
+
+	/* Get DMA clock */
+	dma_ctrl.clk = clk_get(NULL, "clk_dmac");
+	if (IS_ERR(dma_ctrl.clk)) {
+		ret = -ENODEV;
+		goto errout;
+	}
+	clk_enable(dma_ctrl.clk);
+
+	/* Clear DMA controller */
+	__raw_writel(1, DMA_CONFIG(DMAIOBASE));
+	__raw_writel(0xFF, DMA_INT_TC_CLEAR(DMAIOBASE));
+	__raw_writel(0xFF, DMA_INT_ERR_CLEAR(DMAIOBASE));
+
+	/* Clock is only enabled when needed to save power */
+	clk_disable(dma_ctrl.clk);
+
+	return 0;
+
+errout:
+	free_irq(IRQ_LPC32XX_DMA, NULL);
+
+out:
+	return ret;
+}
+arch_initcall(lpc32xx_dma_init);
diff --git a/arch/arm/mach-lpc32xx/ea3250.c b/arch/arm/mach-lpc32xx/ea3250.c
new file mode 100644
index 0000000..f12297f
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/ea3250.c
@@ -0,0 +1,1019 @@
+/*
+ * arch/arm/mach-lpc32xx/ea3250.c
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <linux/leds.h>
+#include <linux/leds-pca9532.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/amba/pl022.h>
+#include <linux/amba/mmci.h>
+#include <mtd/mtd-abi.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <mach/board.h>
+#include "common.h"
+
+#include <linux/spi/ads7846.h>
+
+#define I2C_PCA9532_ADDR 0x60
+#define I2C_24LC256_ADDR 0x50
+
+/*
+ * Mapped GPIOLIB GPIOs
+ */
+#define	LED_GPIO	LPC32XX_GPIO(LPC32XX_GPIO_P2_GRP, 1)
+#define	SPI0_CS_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 11)
+#define	ADS_TS_GPIO	LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 0)
+#define	NAND_WP_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 19)
+#define	LCD_CS_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 4)
+#define	LCD_RS_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 5)
+#define	BKL_POW_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 14)
+#define	SSEL0_GPIO5	LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
+#define	MMC_POWER_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 1)
+
+/*
+ * LCD controller functions
+ */
+#define SET_RS		(gpio_set_value(LCD_RS_GPIO, 1))
+#define RESET_RS	(gpio_set_value(LCD_RS_GPIO, 0))
+#define PANEL_SIZE	(3 * SZ_64K)
+
+/* SPI LCDC device structure */
+struct spi_device *ea3250_spi_lcd_dev = NULL;
+
+/*
+ * Tick LED
+ */
+static struct gpio_led phy_leds[] = {
+	{
+		.name			= "led0",
+		.gpio			= LED_GPIO,
+		.active_low		= 1,
+		.default_trigger	= "heartbeat",
+	},
+};
+
+static struct gpio_led_platform_data led_data = {
+	.leds = phy_leds,
+	.num_leds = ARRAY_SIZE(phy_leds),
+};
+
+static struct platform_device lpc32xx_gpio_led_device = {
+	.name			= "leds-gpio",
+	.id			= -1,
+	.dev.platform_data	= &led_data,
+};
+
+static struct pca9532_platform_data ea3250_leds = {
+	.leds = {
+	{ 	.type = PCA9532_TYPE_NONE }, /* Key 1 */
+	{ 	.type = PCA9532_TYPE_NONE }, /* Key 2 */
+	{ 	.type = PCA9532_TYPE_NONE }, /* Key 3 */
+	{ 	.type = PCA9532_TYPE_NONE }, /* Key 4 */
+	{ 	.type = PCA9532_TYPE_NONE }, /* MMC CD */
+	{ 	.type = PCA9532_TYPE_NONE }, /* MMC WP */
+	{ 	.type = PCA9532_TYPE_NONE }, /* not used */
+	{ 	.type = PCA9532_TYPE_NONE }, /* not used */
+	{	.name = "eabb:red:led1",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led2",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led3",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led4",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led5",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led6",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led7",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led8",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	}, },
+	.psc = { 0, 0 },
+	.pwm = { 0, 0 },
+};
+
+/*
+ * AMBA SSP (SPI)
+ */
+static struct pl022_ssp_controller lpc32xx_ssp0_data = {
+	.bus_id			= 0,
+	.num_chipselect		= 2,
+	.enable_dma		= 0,
+};
+
+static struct amba_device lpc32xx_ssp0_device = {
+	.dev	= {
+		.coherent_dma_mask	= ~0,
+		.init_name		= "dev:ssp0",
+		.platform_data		= &lpc32xx_ssp0_data,
+	},
+	.res				= {
+		.start			= LPC32XX_SSP0_BASE,
+		.end			= (LPC32XX_SSP0_BASE + SZ_4K - 1),
+		.flags			= IORESOURCE_MEM,
+	},
+	.dma_mask			= ~0,
+	.irq				= {IRQ_LPC32XX_SSP0, NO_IRQ},
+};
+
+/*
+ * Touchscreen device
+ */
+/* Touch screen chip select function */
+static void ea3250_spi_cs_set(u32 control)
+{
+	gpio_set_value(SPI0_CS_GPIO, (int) control);
+}
+
+/* Touch screen SPI parameters */
+static struct pl022_config_chip spi0_chip_info = {
+	.com_mode		= INTERRUPT_TRANSFER,
+	.iface			= SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy		= SSP_MASTER,
+	.slave_tx_disable	= 0,
+	.rx_lev_trig		= SSP_RX_4_OR_MORE_ELEM,
+	.tx_lev_trig		= SSP_TX_4_OR_MORE_EMPTY_LOC,
+	.ctrl_len		= SSP_BITS_8,
+	.wait_state		= SSP_MWIRE_WAIT_ZERO,
+	.duplex			= SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control		= ea3250_spi_cs_set,
+};
+
+/* Touch screen interrupt status function */
+static int ea3250_ads7846_pendown_state(void)
+{
+	u32 tmp = gpio_get_value(ADS_TS_GPIO);
+	return (tmp == 0);
+}
+
+/* Touch screen platform data */
+static struct ads7846_platform_data ea_ads7846_platform_data __initdata = {
+	.model      = 7846,
+	.debounce_max	= 10,
+	.debounce_tol	= 3,
+	.pressure_max	= 1024,
+	.get_pendown_state = ea3250_ads7846_pendown_state,
+	.wakeup = true,
+};
+
+/*
+ * SPI based LCDC data
+ */
+/* LCDC chip select function */
+static void ea3250_spi_lcdc_cs_set(u32 control)
+{
+	gpio_set_value(LCD_CS_GPIO, (int) control);
+}
+
+/* LCDC SPI parameters */
+static struct pl022_config_chip spi0_chip_info1 = {
+	.com_mode		= INTERRUPT_TRANSFER,
+	.iface			= SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy		= SSP_MASTER,
+	.slave_tx_disable	= 0,
+	.rx_lev_trig		= SSP_RX_4_OR_MORE_ELEM,
+	.tx_lev_trig		= SSP_TX_4_OR_MORE_EMPTY_LOC,
+	.ctrl_len		= SSP_BITS_8,
+	.wait_state		= SSP_MWIRE_WAIT_ZERO,
+	.duplex			= SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control		= ea3250_spi_lcdc_cs_set,
+};
+
+/* SPI devices registration */
+static int __init ea3250_spi_devices_register(void)
+{
+#if defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_SPI_SPIDEV_MODULE)
+	static struct spi_board_info info[] = {
+		{
+			.modalias = "spidev",
+			.max_speed_hz = 2500000,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &spi0_chip_info,
+		},
+	};
+#else
+	struct spi_board_info info[] = {
+		{
+			.modalias      = "ads7846",
+			.max_speed_hz  = 2500000,
+			.chip_select   = 0,
+			.irq           = IRQ_LPC32XX_GPIO_00,
+			.platform_data = &ea_ads7846_platform_data,
+			.controller_data = &spi0_chip_info,
+		},
+		{
+			.modalias      = "ea3250_lcdc",
+			.max_speed_hz  = 10000000,
+			.chip_select   = 1,
+			.controller_data = &spi0_chip_info1,
+		},
+	};
+#endif
+
+	/* Configure ADS TS INT GPIO pin as input */
+	if (gpio_request(ADS_TS_GPIO, "ADS7846 TS INT"))
+		return -EIO;
+	if(gpio_direction_input(ADS_TS_GPIO))
+		return -EIO;
+
+	/* Configure LCDC CS GPIO pin */
+	if (gpio_request(LCD_CS_GPIO, "LCDC CS"))
+		return -EIO;
+	if(gpio_direction_output(LCD_CS_GPIO, 1))
+		return -EIO;
+
+	return spi_register_board_info(info, ARRAY_SIZE(info));
+}
+arch_initcall(ea3250_spi_devices_register);
+
+#if defined (CONFIG_FB_ARMCLCD)
+/*
+ * LCDC AMBA Driver Board Functions
+ */
+#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
+/*
+ * Support for Embedded Artists 3.2 inch QVGA LCD panel
+ */
+static struct clcd_panel conn_lcd_panel = {
+	.mode = {
+		.name = "QVGA portrait",
+		.refresh = 60,
+		.xres = 240,
+		.yres = 320,
+		.pixclock = 121654,
+		.left_margin = 28,
+		.right_margin = 10,
+		.upper_margin = 2,
+		.lower_margin = 2,
+		.hsync_len = 3,
+		.vsync_len = 2,
+		.sync = 0,
+		.vmode = FB_VMODE_NONINTERLACED,
+	},
+	.width = -1,
+	.height = -1,
+	.tim2 = (TIM2_IVS | TIM2_IHS),
+	.cntl = (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
+			CNTL_LCDBPP16_565),
+	.bpp = 16,
+};
+
+#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
+/*
+ * Support for Embedded Artists 2.8 inch QVGA OLED panel
+*/
+static struct clcd_panel conn_lcd_panel = {
+	.mode = {
+		.name = "QVGA portrait",
+		.refresh = 60,
+		.xres = 240,
+		.yres = 320,
+		.pixclock = 176366,
+		.left_margin = 33,
+		.right_margin = 26,
+		.upper_margin = 3,
+		.lower_margin = 8,
+		.hsync_len = 32,
+		.vsync_len = 4,
+		.sync = 0,
+		.vmode = FB_VMODE_NONINTERLACED,
+	},
+	.width = -1,
+	.height = -1,
+	.tim2 = (TIM2_IVS | TIM2_IHS),
+	.cntl = (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
+			CNTL_LCDBPP16_565),
+	.bpp = 16,
+};
+#endif
+
+static int lpc32xx_clcd_setup(struct clcd_fb *fb)
+{
+	dma_addr_t dma;
+
+	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev,
+			PANEL_SIZE, &dma, GFP_KERNEL);
+	if (!fb->fb.screen_base) {
+		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
+		return -ENOMEM;
+	}
+
+	fb->fb.fix.smem_start = dma;
+	fb->fb.fix.smem_len = PANEL_SIZE;
+	fb->panel = &conn_lcd_panel;
+
+	if (gpio_request(SSEL0_GPIO5, "Unused GPIO5 input"))
+		return -EIO;
+	if(gpio_direction_input(SSEL0_GPIO5))
+		return -EIO;
+
+	/* Configure LCDC RS GPIO pin */
+	if (gpio_request(LCD_RS_GPIO, "LCDC RS"))
+		return -EIO;
+
+	if(gpio_direction_output(LCD_RS_GPIO, 1))
+		return -EIO;
+
+	/* Configure LCDC Backlight GPIO pin */
+	if (gpio_request(BKL_POW_GPIO, "LCDC BKL"))
+		return -EIO;
+
+#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
+	if(gpio_direction_output(BKL_POW_GPIO, 0)) {
+#else
+	if(gpio_direction_output(BKL_POW_GPIO, 1)) {
+#endif
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int lpc32xx_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
+{
+	return dma_mmap_writecombine(&fb->dev->dev, vma,
+															fb->fb.screen_base,
+															fb->fb.fix.smem_start,
+															fb->fb.fix.smem_len);
+}
+
+static void lpc32xx_clcd_remove(struct clcd_fb *fb)
+{
+	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
+			fb->fb.screen_base, fb->fb.fix.smem_start);
+}
+
+static void spiSend(u8 *buf, size_t len)
+{
+	BUG_ON(ea3250_spi_lcd_dev == NULL);
+	spi_write(ea3250_spi_lcd_dev, buf, len);
+}
+
+#if defined (CONFIG_EA3250_QVGA_2_8_OLED)
+static void writeToDisp(u16 data)
+{
+	u8 buf[3];
+
+	/* Initiliase buffer */
+	buf[0] = 0x72;
+	buf[1] = data >> 8;
+	buf[2] = data & 0xff;
+	spiSend(buf, 3);
+}
+#endif
+
+static void writeToReg(u16 addr, u16 data)
+{
+	u8 buf[3];
+
+#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
+	RESET_RS;
+	buf[0] = 0x00;
+	buf[1] = addr & 0xff;
+	spiSend(buf, 2);
+
+	SET_RS;
+	buf[0] = data >> 8;
+	buf[1] = data & 0xff;
+	spiSend(buf, 2);
+
+	RESET_RS;
+	buf[0] = 0x00;
+	buf[1] = 0x22;
+	spiSend(buf, 2);
+#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
+	buf[0] = 0x70;
+	buf[1] = data >> 8;
+	buf[2] = data & 0xff;
+	spiSend(buf, 3);
+#endif
+
+}
+
+static void clcd_display_init(void)
+{
+	u32 tmp;
+
+	/* setup MUX register to use SSP0 */
+	__raw_writel(( _BIT(12) | _BIT(10) | _BIT(9) ), LPC32XX_GPIO_P_MUX_SET);
+	tmp = __raw_readl(LPC32XX_GPIO_P_MUX_SET);
+
+#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
+	writeToReg (0x00,0x0001);
+	mdelay(20);
+	writeToReg (0x03,0xA2A4);
+	writeToReg (0x0C,0x0004);
+	writeToReg (0x0D,0x0308);
+	writeToReg (0x0E,0x3000);
+	mdelay(50);
+	writeToReg (0x1E,0x00AF);
+	writeToReg (0x01,0x2B3F);
+	writeToReg (0x02,0x0600);
+	writeToReg (0x10,0x0000);
+	writeToReg (0x07,0x0233);
+	writeToReg (0x0B,0x0039);
+	writeToReg (0x0F,0x0000);
+	mdelay(50);
+
+	writeToReg (0x30,0x0707);
+	writeToReg (0x31,0x0204);
+	writeToReg (0x32,0x0204);
+	writeToReg (0x33,0x0502);
+	writeToReg (0x34,0x0507);
+	writeToReg (0x35,0x0204);
+	writeToReg (0x36,0x0204);
+	writeToReg (0x37,0x0502);
+	writeToReg (0x3A,0x0302);
+	writeToReg (0x3B,0x0302);
+
+	writeToReg (0x23,0x0000);
+	writeToReg (0x24,0x0000);
+
+	writeToReg (0x48,0x0000);
+	writeToReg (0x49,0x013F);
+	writeToReg (0x4A,0x0000);
+	writeToReg (0x4B,0x0000);
+
+	writeToReg (0x41,0x0000);
+	writeToReg (0x42,0x0000);
+
+	writeToReg (0x44,0xEF00);
+	writeToReg (0x45,0x0000);
+	writeToReg (0x46,0x013F);
+	mdelay(50);
+
+	writeToReg (0x44,0xEF00);
+	writeToReg (0x45,0x0000);
+	writeToReg (0x4E,0x0000);
+	writeToReg (0x4F,0x0000);
+	writeToReg (0x46,0x013F);
+
+#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
+	writeToReg(0,0x02);
+	writeToDisp(0x0192);
+
+	writeToReg(0,0x03);
+	writeToDisp(0x0130);
+
+	/* set standby off */
+	writeToReg(0,0x10);
+	writeToDisp(0x0000);
+
+	mdelay(100);
+
+	/* set display on */
+	writeToReg(0,0x05);
+	writeToDisp(0x0001);
+
+	/* enable image data transfer */
+	writeToReg(0,0x22);
+#endif
+}
+
+void clcd_disable(struct clcd_fb *fb)
+{
+	/* Disable the backlight */
+#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
+	gpio_set_value(BKL_POW_GPIO, 1);
+#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
+	gpio_set_value(BKL_POW_GPIO, 0);
+#endif
+}
+
+void clcd_enable(struct clcd_fb *fb)
+{
+	clcd_display_init();
+
+	/* Enable the backlight */
+#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
+	gpio_set_value(BKL_POW_GPIO, 0);
+#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
+	gpio_set_value(BKL_POW_GPIO, 1);
+#endif
+}
+
+struct clcd_board lpc32xx_clcd_data = {
+#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
+	.name = "Embedded Artists 3.2 inch LCD",
+#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
+	.name = "Embedded Artists 2.8 inch OLED",
+#else
+	.name = "Unknown Display",
+#endif
+	.check = clcdfb_check,
+	.decode = clcdfb_decode,
+	.disable = clcd_disable,
+	.enable = clcd_enable,
+	.setup = lpc32xx_clcd_setup,
+	.mmap = lpc32xx_clcd_mmap,
+	.remove = lpc32xx_clcd_remove,
+};
+
+struct amba_device lpc32xx_clcd_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.init_name = "dev:clcd",
+		.platform_data = &lpc32xx_clcd_data,
+	},
+	.res                            = {
+		.start = LPC32XX_LCD_BASE,
+		.end = (LPC32XX_LCD_BASE + SZ_4K - 1),
+		.flags = IORESOURCE_MEM,
+	},
+	.dma_mask = ~0,
+	.irq = {IRQ_LPC32XX_LCD, NO_IRQ},
+};
+#endif
+
+/*
+ * SPI LCDC Driver Probe function
+ */
+static int ea3250_spi_lcdc_probe(struct spi_device *spi)
+{
+	int err;
+
+	spi->mode = SPI_MODE_0;
+	ea3250_spi_lcd_dev = spi;
+
+	/* SPI settings */
+	err = spi_setup(spi);
+	if (err < 0) {
+		dev_err(&spi->dev, "Err in setting SPI \n");
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ *  * SPI LCDC Driver remove function
+ *   * */
+static int ea3250_spi_lcdc_remove(struct spi_device *spi)
+{
+	return 0;
+}
+
+static struct spi_driver ea3250_spi_lcdc_driver = {
+	.driver = {
+		.name   = "ea3250_lcdc",
+		.bus    = &spi_bus_type,
+		.owner  = THIS_MODULE,
+	},
+	.probe  = ea3250_spi_lcdc_probe,
+	.remove = __devexit_p(ea3250_spi_lcdc_remove),
+};
+
+void __init ea3250_spi_lcdc_drv_init(void)
+{
+	spi_register_driver(&ea3250_spi_lcdc_driver);
+}
+
+#if defined (CONFIG_MMC_ARMMMCI)
+
+/*
+ * Returns !0 when card is removed, 0 when present
+ */
+unsigned int mmc_card_detect(struct device *dev)
+{
+	/*
+	 * This function may be adapted to retrieve the actual 'card detect'
+	 * status over the I2C bus, from PCA9532 pin 8 (LED4). For now, simply
+	 * indicate that a card is always present.
+	*/
+	return 0;
+}
+
+/*
+ * Enable or disable SD slot power
+ */
+void mmc_power_enable(int enable)
+{
+	if (enable != 0) {
+		/* active low */
+		gpio_set_value(MMC_POWER_GPIO,0);
+	}
+	else {
+		gpio_set_value(MMC_POWER_GPIO,0);
+	}
+}
+
+/*
+ * Board specific MMC driver data
+ */
+struct mmci_platform_data lpc32xx_plat_data = {
+	.ocr_mask	= MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|MMC_VDD_33_34,
+	.vdd_handler	= NULL,
+	.capabilities	= MMC_CAP_4_BIT_DATA,
+
+	/*
+	 * Indicate no direct GPIO, so MMC driver will assume card is NOT
+	 * write-protected
+	 */
+	.gpio_wp        = -ENOSYS,
+
+	/*
+	 * Indicate no direct GPIO, so MMC driver will call 'status' callback
+	 * function
+	 */
+	.gpio_cd        = -ENOSYS,
+
+	/*
+	 * Callback function, used by MMC driver in case 'gpio_cd'
+	 * equals -ENOSYS
+	 */
+	//.status		= mmc_card_detect,
+};
+
+/*
+ * SD card controller resources
+ */
+struct amba_device lpc32xx_mmc_device = {
+	.dev				= {
+		.coherent_dma_mask	= ~0,
+		.init_name		= "dev:mmc0",
+		.platform_data		= &lpc32xx_plat_data,
+	},
+	.res				= {
+		.start			= LPC32XX_SD_BASE,
+		.end			= (LPC32XX_SD_BASE + SZ_4K - 1),
+		.flags			= IORESOURCE_MEM,
+	},
+	.dma_mask			= ~0,
+	.irq				= {IRQ_LPC32XX_SD0, IRQ_LPC32XX_SD1},
+};
+#endif
+
+/* AMBA based devices list */
+static struct amba_device *amba_devs[] __initdata = {
+	&lpc32xx_ssp0_device,
+#if defined (CONFIG_FB_ARMCLCD)
+	&lpc32xx_clcd_device,
+#endif
+#if defined (CONFIG_MMC_ARMMMCI)
+	&lpc32xx_mmc_device,
+#endif
+};
+
+/*
+ * Register AMBA BUS Devices.
+ * Call AMBA device restration after SPI driver probe(),
+ * as LCD controller uses SPI driver for initialization
+ */
+static int __init ea3250_amba_devices_register(void)
+{
+	u32 i = 0;
+
+	/* Add AMBA devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+
+	return 0;
+}
+device_initcall_sync(ea3250_amba_devices_register);
+
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+/*
+ *  * Board specific NAND setup data
+ *   */
+static int nandwp_enable(int enable)
+{
+	if (enable != 0)
+		gpio_set_value(NAND_WP_GPIO,0);
+	else
+		gpio_set_value(NAND_WP_GPIO,1);
+
+	return 1;
+}
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition ea3250_nand_partition[] = {
+	{
+		.name = "ea3250-boot",
+		.offset = 0,
+		.size = (BLK_SIZE * 4),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name = "ea3250-uboot",
+		.offset = MTDPART_OFS_APPEND,
+		.size = (BLK_SIZE * 6)
+	},
+	{
+		.name = "ea3250-kernel",
+		.offset = MTDPART_OFS_APPEND,
+		.size = (BLK_SIZE * 32)
+	},
+	{
+		.name = "ea3250-jffs2",
+		.offset = MTDPART_OFS_APPEND,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+static struct mtd_partition * ea3250_nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(ea3250_nand_partition);
+	return ea3250_nand_partition;
+}
+struct lpc32XX_nand_cfg lpc32xx_nandcfg =
+{
+	.wdr_clks = 14,
+	.wwidth = 260000000,
+	.whold = 104000000,
+	.wsetup = 200000000,
+	.rdr_clks = 14,
+	.rwidth = 34666666,
+	.rhold = 104000000,
+	.rsetup = 200000000,
+	.use_bbt = true,
+	.polled_completion = false,
+	.enable_write_prot = nandwp_enable,
+	.partition_info = ea3250_nand_partitions,
+};
+
+/*
+ *  * SLC NAND resources
+ *   */
+static struct resource slc_nand_resources[] = {
+	[0] = {
+		.start = LPC32XX_SLC_BASE,
+		.end = LPC32XX_SLC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_FLASH,
+		.end = IRQ_LPC32XX_FLASH,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_slc_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_slc_nand_device = {
+	.name = "lpc32xx-nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &lpc32xx_nandcfg,
+		.dma_mask = &lpc32xx_slc_dma_mask,
+		.coherent_dma_mask = ~0UL,
+	},
+	.num_resources = ARRAY_SIZE(slc_nand_resources),
+	.resource = slc_nand_resources,
+};
+#endif
+
+/*
+ * Network Support
+ */
+static struct lpc_net_cfg lpc32xx_netdata =
+{
+	.phy_irq        = -1,
+	.phy_mask       = 0xFFFFFFF0,
+};
+
+static struct resource net_resources[] = {
+	[0] = {
+		.start = LPC32XX_ETHERNET_BASE,
+		.end = LPC32XX_ETHERNET_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start = IRQ_LPC32XX_ETHERNET,
+		.end = IRQ_LPC32XX_ETHERNET,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_mac_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_net_device = {
+	.name = "lpc-net",
+	.id = 0,
+	.dev = {
+		.dma_mask = &lpc32xx_mac_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data = &lpc32xx_netdata,
+	},
+	.num_resources = ARRAY_SIZE(net_resources),
+	.resource = net_resources,
+};
+
+/*
+ * I2C devices support
+ */
+#if defined (CONFIG_LEDS_PCA9532) || defined (CONFIG_AT24)
+	static struct i2c_board_info __initdata ea3250_i2c_board_info [] = {
+#if defined (CONFIG_LEDS_PCA9532)
+		{
+			I2C_BOARD_INFO("pca9532", I2C_PCA9532_ADDR),
+			.platform_data = &ea3250_leds,
+		},
+#endif
+#if defined (CONFIG_AT24)
+		{
+			I2C_BOARD_INFO("24c256", I2C_24LC256_ADDR),
+		},
+#endif
+	};
+#endif
+
+static struct platform_device* ea3250_devs[] __initdata = {
+	&lpc32xx_i2c0_device,
+	&lpc32xx_i2c1_device,
+	&lpc32xx_i2c2_device,
+	&lpc32xx_watchdog_device,
+	&lpc32xx_gpio_led_device,
+	&lpc32xx_rtc_device,
+	&lpc32xx_net_device,
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+	&lpc32xx_slc_nand_device,
+#endif
+#if defined(CONFIG_USB_OHCI_HCD)
+	&lpc32xx_ohci_device,
+#endif
+#if defined(CONFIG_USB_GADGET_LPC32XX)
+	&lpc32xx_usbd_device,
+#endif
+	&lpc32xx_i2s_device,
+	&lpc32xx_asoc_plat_device,
+};
+
+extern void __init ea3250_spi_lcdc_drv_init(void);
+
+/*
+ * Board specific functions
+ */
+void __init ea3250_board_init(void)
+{
+	u32 tmp;
+
+	/* Intiliase GPIO */
+	lpc32xx_gpio_init();
+
+#if defined (CONFIG_MMC_ARMMMCI)
+	/* Enable SD slot power */
+	mmc_power_enable(1);
+#endif
+
+	/* Set SPI CS GPIO to output */
+	gpio_request(SPI0_CS_GPIO, "spi0 cs");
+	gpio_direction_output(SPI0_CS_GPIO, 1);
+
+	/* Setup network interface for RMII mode */
+	tmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);
+	tmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;
+	tmp |= LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MACCLK_CTRL);
+
+	/* Setup SLC NAND controller */
+	__raw_writel(LPC32XX_CLKPWR_NANDCLK_SEL_SLC,
+			LPC32XX_CLKPWR_NAND_CLK_CTRL);
+
+	/* Setup LCD muxing to RGB565 */
+	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL) &
+		~(LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_MSK |
+				LPC32XX_CLKPWR_LCDCTRL_PSCALE_MSK);
+	tmp |= LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT16;
+	__raw_writel(tmp, LPC32XX_CLKPWR_LCDCLK_CTRL);
+
+	/* Set up I2C pull levels */
+	tmp = __raw_readl(LPC32XX_CLKPWR_I2C_CLK_CTRL);
+	tmp |= LPC32XX_CLKPWR_I2CCLK_USBI2CHI_DRIVE |
+		LPC32XX_CLKPWR_I2CCLK_I2C2HI_DRIVE;
+	__raw_writel(tmp, LPC32XX_CLKPWR_I2C_CLK_CTRL);
+
+	/* Enable DMA for I2S1 channel */
+	tmp = __raw_readl(LPC32XX_CLKPWR_I2S_CLK_CTRL);
+	tmp = LPC32XX_CLKPWR_I2SCTRL_I2S1_USE_DMA;
+	__raw_writel(tmp, LPC32XX_CLKPWR_I2S_CLK_CTRL);
+
+	/* Initalise Serial device */
+	lpc32xx_serial_init();
+
+	/*
+	 * AMBA peripheral clocks need to be enabled prior to AMBA device
+	 * detection or a data fault will occur, so enable the clocks
+	 * here. However, we don't want to enable them if the peripheral
+	 * isn't included in the image
+	 */
+	/* Initialise SSP clock */
+	tmp = __raw_readl(LPC32XX_CLKPWR_SSP_CLK_CTRL);
+	__raw_writel((tmp | LPC32XX_CLKPWR_SSPCTRL_SSPCLK0_EN),
+			LPC32XX_CLKPWR_SSP_CLK_CTRL);
+
+	/* Initialise LCD clock */
+	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL);
+	__raw_writel((tmp | LPC32XX_CLKPWR_LCDCTRL_CLK_EN),
+			LPC32XX_CLKPWR_LCDCLK_CTRL);
+
+	/* Enable SD card clock so AMBA driver will work correctly. The
+	   AMBA driver needs the clock before the SD card controller
+	   driver initializes it. The clock will turn off once the driver
+	   has been initialized. */
+	tmp = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
+	tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_EN |
+		LPC32XX_CLKPWR_MSCARD_MSDIO_PU_EN;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
+
+	/* Disable UART5->USB transparent mode or USB won't work */
+	tmp = __raw_readl(LPC32XX_UARTCTL_CTRL);
+	tmp &= ~LPC32XX_UART_U5_ROUTE_TO_USB;
+	__raw_writel(tmp, LPC32XX_UARTCTL_CTRL);
+
+	/* Add platform devcies */
+	platform_add_devices(ea3250_devs, ARRAY_SIZE(ea3250_devs));
+
+	/* Register SPI driver */
+	ea3250_spi_lcdc_drv_init();
+
+	/* Test clock needed for UDA1380 initial init */
+	__raw_writel(LPC32XX_CLKPWR_TESTCLK2_SEL_MOSC |
+			LPC32XX_CLKPWR_TESTCLK_TESTCLK2_EN,
+			LPC32XX_CLKPWR_TEST_CLK_SEL);
+
+#if defined (CONFIG_LEDS_PCA9532) || defined (CONFIG_AT24)
+	i2c_register_board_info(0, ea3250_i2c_board_info,
+			ARRAY_SIZE(ea3250_i2c_board_info));
+#endif
+}
+
+static int __init lpc32xx_display_uid(void)
+{
+	u32 uid[4];
+
+	lpc32xx_get_uid(uid);
+
+	printk(KERN_INFO "LPC32XX unique ID: %08x%08x%08x%08x\n",
+			uid[3], uid[2], uid[1], uid[0]);
+
+	return 1;
+}
+arch_initcall(lpc32xx_display_uid);
+
+MACHINE_START (EA3250, "Embedded Artists LPC3250 OEM board with the LPC3250 Microcontroller")
+	/* Maintainer: Embedded Artists */
+	.boot_params	= 0x80000100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= ea3250_board_init,
+	MACHINE_END
+
+/* For backwards compatibility with older bootloaders only */
+MACHINE_START (LPC3XXX, "Embedded Artists LPC3250 OEM board with the LPC3250 Microcontroller")
+	/* Maintainer: Embedded Artists */
+	.boot_params	= 0x80000100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= ea3250_board_init,
+	MACHINE_END
+
diff --git a/arch/arm/mach-lpc32xx/fdi3250.c b/arch/arm/mach-lpc32xx/fdi3250.c
new file mode 100644
index 0000000..e0ae08d
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/fdi3250.c
@@ -0,0 +1,602 @@
+/*
+ * arch/arm/mach-lpc32xx/fdi3250.c
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/amba/pl022.h>
+#include <linux/amba/mmci.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <mach/board.h>
+#include "common.h"
+
+/*
+ * Mapped GPIOLIB GPIOs
+ */
+#define	LED_GPIO		LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 3)
+#define	SPI_CS_GPIO		LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
+#define	NAND_WP_GPIO		LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 19)
+
+/*
+ * Tick LED
+ */
+static struct gpio_led phy_leds[] = {
+	{
+		.name			= "led0",
+		.gpio			= LED_GPIO,
+		.active_low		= 1,
+		.default_trigger	= "heartbeat",
+	},
+};
+
+static struct gpio_led_platform_data led_data = {
+	.leds = phy_leds,
+	.num_leds = ARRAY_SIZE(phy_leds),
+};
+
+static struct platform_device lpc32xx_gpio_led_device = {
+	.name			= "leds-gpio",
+	.id			= -1,
+	.dev.platform_data	= &led_data,
+};
+
+/*
+ * AMBA SSP (SPI)
+ */
+static struct pl022_ssp_controller lpc32xx_ssp0_data = {
+	.bus_id			= 0,
+	.num_chipselect		= 2,
+	.enable_dma		= 0,
+};
+
+static struct amba_device lpc32xx_ssp0_device = {
+	.dev	= {
+		.coherent_dma_mask	= ~0,
+		.init_name		= "dev:ssp0",
+		.platform_data		= &lpc32xx_ssp0_data,
+	},
+	.res				= {
+		.start			= LPC32XX_SSP0_BASE,
+		.end			= (LPC32XX_SSP0_BASE + SZ_4K - 1),
+		.flags			= IORESOURCE_MEM,
+	},
+	.dma_mask			= ~0,
+	.irq				= {IRQ_LPC32XX_SSP0, NO_IRQ},
+};
+
+/* SPIDEV chip select function */
+static void fdi3250_spi_cs_set(u32 control)
+{
+	gpio_set_value(SPI_CS_GPIO, (int) control);
+}
+
+/* SPIDEV parameters */
+static struct pl022_config_chip spi0_chip_info = {
+	.com_mode		= INTERRUPT_TRANSFER,
+	.iface			= SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy		= SSP_MASTER,
+	.slave_tx_disable	= 0,
+	.rx_lev_trig		= SSP_RX_4_OR_MORE_ELEM,
+	.tx_lev_trig		= SSP_TX_4_OR_MORE_EMPTY_LOC,
+	.ctrl_len		= SSP_BITS_8,
+	.wait_state		= SSP_MWIRE_WAIT_ZERO,
+	.duplex			= SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control		= fdi3250_spi_cs_set,
+};
+
+/* SPI devices registration */
+static int __init fdi3250_spi_devices_register(void)
+{
+	static struct spi_board_info info[] = {
+		{
+			.modalias = "spidev",
+			.max_speed_hz = 2500000,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &spi0_chip_info,
+		},
+	};
+
+	return spi_register_board_info(info, ARRAY_SIZE(info));
+}
+arch_initcall(fdi3250_spi_devices_register);
+
+#if defined (CONFIG_FB_ARMCLCD)
+/*
+ * Board specific LCD setup and functions
+ */
+#if defined (CONFIG_SOM9DIMM3250_LCD_PANEL)
+/*
+ * Support for QVGA portrait panel
+ */
+#if defined (CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35)
+static struct clcd_panel conn_lcd_panel = {
+	.mode		= {
+		.name		= "QVGA portrait",
+		.refresh	= 30,
+		.xres		= 320,
+		.yres		= 240,
+		.pixclock	= 158730,
+		.left_margin	= 11,
+		.right_margin	= 3,
+		.upper_margin	= 7,
+		.lower_margin	= 7,
+		.hsync_len	= 69,
+		.vsync_len	= 45,
+		.sync		= FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	.width		= -1,
+	.height		= -1,
+	.tim2		= 0,
+	.cntl		= (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
+				CNTL_LCDBPP16_565),
+	.bpp		= 16,
+};
+#define PANEL_SIZE (3 * SZ_64K)
+#endif
+#if defined (CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35)
+static struct clcd_panel conn_lcd_panel = {
+	.mode		= {
+		.name		= "VGA portrait",
+		.refresh	= 30,
+		.xres		= 640,
+		.yres		= 480,
+		.pixclock	= 41666,
+		.left_margin	= 10,
+		.right_margin	= 120,
+		.upper_margin	= 7,
+		.lower_margin	= 35,
+		.hsync_len	= 30,
+		.vsync_len	= 3,
+		.sync		= FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	.width		= -1,
+	.height		= -1,
+	.tim2		= 0,
+	.cntl		= (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
+				CNTL_LCDBPP16_565),
+	.bpp		= 16,
+};
+#define PANEL_SIZE (10 * SZ_64K)
+#endif
+
+#endif // CONFIG_SOM9DIMM3250_LCD_PANEL
+
+#if defined (CONFIG_MMC_ARMMMCI)
+static u32 mmc_translate_vdd(struct device *dev, unsigned int vdd,
+		unsigned char mode)
+{
+	return 0;
+}
+
+unsigned int fdi_mmc_status_always_on(struct device *dev)
+{
+	return 0;
+}
+/*
+ * Board specific MMC driver data
+ */
+struct mmci_platform_data lpc32xx_plat_data = {
+	.ocr_mask       = MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|MMC_VDD_33_34,
+	.vdd_handler	= mmc_translate_vdd,
+	.capabilities   = MMC_CAP_4_BIT_DATA,
+	.gpio_wp        = ARCH_NR_GPIOS + 1,
+	.gpio_cd        = ARCH_NR_GPIOS + 1,
+	.status         = fdi_mmc_status_always_on,
+};
+
+/*
+ * SD card controller resources
+ */
+struct amba_device lpc32xx_mmc_device = {
+	.dev = {
+		.coherent_dma_mask      = ~0,
+		.init_name                 = "dev:mmc0",
+		.platform_data          = &lpc32xx_plat_data,
+	},
+	.res = {
+		.start                  = LPC32XX_SD_BASE,
+		.end                    = (LPC32XX_SD_BASE + SZ_4K - 1),
+		.flags                  = IORESOURCE_MEM,
+	},
+	.dma_mask                       = ~0,
+	.irq                            = {IRQ_LPC32XX_SD0, IRQ_LPC32XX_SD1},
+};
+#endif
+
+static int lpc32xx_clcd_setup(struct clcd_fb *fb)
+{
+	dma_addr_t dma;
+
+	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev,
+			PANEL_SIZE, &dma, GFP_KERNEL);
+	if (!fb->fb.screen_base) {
+		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
+		return -ENOMEM;
+	}
+
+	fb->fb.fix.smem_start = dma;
+	fb->fb.fix.smem_len = PANEL_SIZE;
+	fb->panel = &conn_lcd_panel;
+
+	return 0;
+}
+
+static int lpc32xx_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
+{
+	return dma_mmap_writecombine(&fb->dev->dev, vma,
+															fb->fb.screen_base,
+															fb->fb.fix.smem_start,
+															fb->fb.fix.smem_len);
+}
+
+static void lpc32xx_clcd_remove(struct clcd_fb *fb)
+{
+	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
+			fb->fb.screen_base, fb->fb.fix.smem_start);
+}
+
+void clcd_disable(struct clcd_fb *fb)
+{
+#if defined (CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35)
+	__raw_writel(0x40000000, io_p2v(LPC32XX_PWM1_BASE));
+#elif defined (CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35)
+	__raw_writel(0x00000000, io_p2v(LPC32XX_PWM1_BASE));
+#endif
+}
+
+void clcd_enable(struct clcd_fb *fb)
+{
+#if defined (CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35)
+	__raw_writel(0x00000000, io_p2v(LPC32XX_PWM1_BASE));
+#elif defined (CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35)
+	__raw_writel(0x40000000, io_p2v(LPC32XX_PWM1_BASE));
+#endif
+}
+
+struct clcd_board lpc32xx_clcd_data = {
+#if defined (CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35)
+	.name = "Toshiba 3.5 inch LCD",
+#elif defined (CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35)
+	.name = "Okaya 3.5 inch LCD",
+#else
+	.name = "Unknown Display",
+#endif
+	.check = clcdfb_check,
+	.decode = clcdfb_decode,
+	.disable = clcd_disable,
+	.enable = clcd_enable,
+	.setup = lpc32xx_clcd_setup,
+	.mmap = lpc32xx_clcd_mmap,
+	.remove = lpc32xx_clcd_remove,
+};
+
+struct amba_device lpc32xx_clcd_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.init_name = "dev:clcd",
+		.platform_data = &lpc32xx_clcd_data,
+	},
+	.res = {
+		.start = LPC32XX_LCD_BASE,
+		.end = (LPC32XX_LCD_BASE + SZ_4K - 1),
+		.flags = IORESOURCE_MEM,
+	},
+	.dma_mask = ~0,
+	.irq = {IRQ_LPC32XX_LCD, NO_IRQ},
+};
+#endif
+
+/* AMBA based devices list */
+static struct amba_device *amba_devs[] __initdata = {
+	&lpc32xx_ssp0_device,
+#if defined (CONFIG_FB_ARMCLCD)
+	&lpc32xx_clcd_device,
+#endif
+#if defined(CONFIG_MMC_ARMMMCI)
+	&lpc32xx_mmc_device,
+#endif
+};
+
+/*
+ * Register AMBA BUS Devices.
+ * Call AMBA device restration after SPI driver probe(),
+ * as LCD controller uses SPI driver for initialization
+ */
+static int __init fdi3250_amba_devices_register(void)
+{
+	u32 i = 0;
+
+	/* Add AMBA devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+
+	return 0;
+}
+device_initcall_sync(fdi3250_amba_devices_register);
+
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+/*
+ *  * Board specific NAND setup data
+ *   */
+static int nandwp_enable(int enable)
+{
+	if (enable != 0)
+		gpio_set_value(NAND_WP_GPIO,0);
+	else
+		gpio_set_value(NAND_WP_GPIO,1);
+
+	return 1;
+}
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition fdi3250_nand_partition[] = {
+	{
+		.name = "fdi3250-boot",
+		.offset = 0,
+		.size = (BLK_SIZE * 4)
+	},
+	{
+		.name = "fdi3250-uboot",
+		.offset = MTDPART_OFS_APPEND,
+		.size = (BLK_SIZE * 6)
+	},
+	{
+		.name = "fdi3250-kernel",
+		.offset = MTDPART_OFS_APPEND,
+		.size = (BLK_SIZE * 32)
+	},
+	{
+		.name = "fdi3250-jffs2",
+		.offset = MTDPART_OFS_APPEND,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+static struct mtd_partition * fdi3250_nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(fdi3250_nand_partition);
+	return fdi3250_nand_partition;
+}
+struct lpc32XX_nand_cfg lpc32xx_nandcfg = {
+	.wdr_clks = 14,
+	.wwidth = 260000000,
+	.whold = 104000000,
+	.wsetup = 200000000,
+	.rdr_clks = 14,
+	.rwidth = 34666666,
+	.rhold = 104000000,
+	.rsetup = 200000000,
+	.use_bbt = true,
+	.polled_completion = false,
+	.enable_write_prot = nandwp_enable,
+	.partition_info = fdi3250_nand_partitions,
+};
+
+/*
+ *  * SLC NAND resources
+ *   */
+static struct resource slc_nand_resources[] = {
+	[0] = {
+		.start = LPC32XX_SLC_BASE,
+		.end = LPC32XX_SLC_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_FLASH,
+		.end = IRQ_LPC32XX_FLASH,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_slc_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_slc_nand_device = {
+	.name = "lpc32xx-nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &lpc32xx_nandcfg,
+		.dma_mask = &lpc32xx_slc_dma_mask,
+		.coherent_dma_mask = ~0UL,
+	},
+	.num_resources = ARRAY_SIZE(slc_nand_resources),
+	.resource = slc_nand_resources,
+};
+#endif
+
+/*
+ * Network Support
+ */
+static struct lpc_net_cfg lpc32xx_netdata =
+{
+	.phy_irq = -1,
+	.phy_mask = 0xFFFFFFF0,
+};
+
+static struct resource net_resources[] = {
+	[0] = {
+		.start = LPC32XX_ETHERNET_BASE,
+		.end = LPC32XX_ETHERNET_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_ETHERNET,
+		.end = IRQ_LPC32XX_ETHERNET,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_mac_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_net_device = {
+	.name = "lpc-net",
+	.id = 0,
+	.dev = {
+		.dma_mask = &lpc32xx_mac_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data  = &lpc32xx_netdata,
+	},
+	.num_resources = ARRAY_SIZE(net_resources),
+	.resource = net_resources,
+};
+
+static struct platform_device* fdi3250_devs[] __initdata = {
+	&lpc32xx_i2c0_device,
+	&lpc32xx_i2c1_device,
+	&lpc32xx_i2c2_device,
+	&lpc32xx_watchdog_device,
+	&lpc32xx_gpio_led_device,
+	&lpc32xx_rtc_device,
+	&lpc32xx_tsc_device,
+	&lpc32xx_net_device,
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+	&lpc32xx_slc_nand_device,
+#endif
+#if defined(CONFIG_USB_OHCI_HCD)
+	&lpc32xx_ohci_device,
+#endif
+#if defined(CONFIG_USB_GADGET_LPC32XX)
+	&lpc32xx_usbd_device,
+#endif
+	&lpc32xx_i2s_device,
+	&lpc32xx_asoc_plat_device,
+};
+
+/*
+ * Board specific functions
+ */
+void __init fdi3250_board_init(void)
+{
+	u32 tmp;
+
+	/* Intiliase GPIO */
+	lpc32xx_gpio_init();
+
+	/* Set SPI CS GPIO to output */
+	gpio_request(SPI_CS_GPIO, "spi0 cs");
+	gpio_direction_output(SPI_CS_GPIO, 1);
+
+	gpio_request(NAND_WP_GPIO, "NAND WP GPIO");
+	gpio_direction_input(NAND_WP_GPIO);
+
+	/* Setup network interface for RMII mode */
+	tmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);
+	tmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;
+	tmp |= LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MACCLK_CTRL);
+
+	/* Setup SLC NAND controller */
+	__raw_writel(LPC32XX_CLKPWR_NANDCLK_SEL_SLC,
+			LPC32XX_CLKPWR_NAND_CLK_CTRL);
+
+	/* Setup LCD muxing to RGB565 */
+	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL) &
+		~(LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_MSK |
+				LPC32XX_CLKPWR_LCDCTRL_PSCALE_MSK);
+	tmp |= LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT16;
+	__raw_writel(tmp, LPC32XX_CLKPWR_LCDCLK_CTRL);
+
+	/* Set up I2C pull levels */
+	tmp = __raw_readl(LPC32XX_CLKPWR_I2C_CLK_CTRL);
+	tmp |= LPC32XX_CLKPWR_I2CCLK_USBI2CHI_DRIVE |
+		LPC32XX_CLKPWR_I2CCLK_I2C2HI_DRIVE;
+	__raw_writel(tmp, LPC32XX_CLKPWR_I2C_CLK_CTRL);
+
+	/* Initalise Serial device */
+	lpc32xx_serial_init();
+
+	/*
+	 * AMBA peripheral clocks need to be enabled prior to AMBA device
+	 * detection or a data fault will occur, so enable the clocks
+	 * here. However, we don't want to enable them if the peripheral
+	 * isn't included in the image
+	 */
+	/* Initialise SSP clock */
+	tmp = __raw_readl(LPC32XX_CLKPWR_SSP_CLK_CTRL);
+	__raw_writel((tmp | LPC32XX_CLKPWR_SSPCTRL_SSPCLK0_EN),
+			LPC32XX_CLKPWR_SSP_CLK_CTRL);
+
+	/* Initialise LCD clock */
+	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL);
+	__raw_writel((tmp | LPC32XX_CLKPWR_LCDCTRL_CLK_EN),
+			LPC32XX_CLKPWR_LCDCLK_CTRL);
+
+	/* Enable SD card clock so AMBA driver will work correctly. The
+	   AMBA driver needs the clock before the SD card controller
+	   driver initializes it. The clock will turn off once the driver
+	   has been initialized. */
+	tmp = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
+	tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_EN |
+		LPC32XX_CLKPWR_MSCARD_MSDIO_PU_EN;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
+
+	/* Disable UART5->USB transparent mode or USB won't work */
+	tmp = __raw_readl(LPC32XX_UARTCTL_CTRL);
+	tmp &= ~LPC32XX_UART_U5_ROUTE_TO_USB;
+	__raw_writel(tmp, LPC32XX_UARTCTL_CTRL);
+
+	/* Add platform devcies */
+	platform_add_devices(fdi3250_devs, ARRAY_SIZE(fdi3250_devs));
+}
+
+static int __init lpc32xx_display_uid(void)
+{
+	u32 uid[4];
+
+	lpc32xx_get_uid(uid);
+
+	printk(KERN_INFO "LPC32XX unique ID: %08x%08x%08x%08x\n",
+			uid[3], uid[2], uid[1], uid[0]);
+
+	return 1;
+}
+arch_initcall(lpc32xx_display_uid);
+
+MACHINE_START (FDI3250, "Future Designs board with the LPC3250 Microcontroller")
+	.boot_params	= 0x80000100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= fdi3250_board_init,
+	MACHINE_END
+
+/* For backwards compatibility with older bootloaders only */
+MACHINE_START (LPC3XXX, "Future Designs board with the LPC3250 Microcontroller")
+	.boot_params	= 0x80000100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= fdi3250_board_init,
+	MACHINE_END
+
diff --git a/arch/arm/mach-lpc32xx/gpiolib.c b/arch/arm/mach-lpc32xx/gpiolib.c
index 69061ea..04f1889 100644
--- a/arch/arm/mach-lpc32xx/gpiolib.c
+++ b/arch/arm/mach-lpc32xx/gpiolib.c
@@ -36,9 +36,6 @@
 #define LPC32XX_GPIO_P2_INP_STATE		_GPREG(0x01C)
 #define LPC32XX_GPIO_P2_OUTP_SET		_GPREG(0x020)
 #define LPC32XX_GPIO_P2_OUTP_CLR		_GPREG(0x024)
-#define LPC32XX_GPIO_P2_MUX_SET			_GPREG(0x028)
-#define LPC32XX_GPIO_P2_MUX_CLR			_GPREG(0x02C)
-#define LPC32XX_GPIO_P2_MUX_STATE		_GPREG(0x030)
 #define LPC32XX_GPIO_P0_INP_STATE		_GPREG(0x040)
 #define LPC32XX_GPIO_P0_OUTP_SET		_GPREG(0x044)
 #define LPC32XX_GPIO_P0_OUTP_CLR		_GPREG(0x048)
@@ -59,7 +56,7 @@
 #define GPO3_PIN_TO_BIT(x)			(1 << (x))
 #define GPIO012_PIN_IN_SEL(x, y)		(((x) >> (y)) & 1)
 #define GPIO3_PIN_IN_SHIFT(x)			((x) == 5 ? 24 : 10 + (x))
-#define GPIO3_PIN_IN_SEL(x, y)			((x) >> GPIO3_PIN_IN_SHIFT(y))
+#define GPIO3_PIN_IN_SEL(x, y)			(((x) >> GPIO3_PIN_IN_SHIFT(y)) & 1)
 #define GPIO3_PIN5_IN_SEL(x)			(((x) >> 24) & 1)
 #define GPI3_PIN_IN_SEL(x, y)			(((x) >> (y)) & 1)
 
@@ -74,12 +71,12 @@ struct gpio_regs {
 /*
  * GPIO names
  */
-static const char *gpio_p0_names[LPC32XX_GPIO_P0_MAX] = {
+static const char const *gpio_p0_names[LPC32XX_GPIO_P0_MAX] = {
 	"p0.0", "p0.1", "p0.2", "p0.3",
 	"p0.4", "p0.5", "p0.6", "p0.7"
 };
 
-static const char *gpio_p1_names[LPC32XX_GPIO_P1_MAX] = {
+static const char const *gpio_p1_names[LPC32XX_GPIO_P1_MAX] = {
 	"p1.0", "p1.1", "p1.2", "p1.3",
 	"p1.4", "p1.5", "p1.6", "p1.7",
 	"p1.8", "p1.9", "p1.10", "p1.11",
@@ -88,29 +85,30 @@ static const char *gpio_p1_names[LPC32XX_GPIO_P1_MAX] = {
 	"p1.20", "p1.21", "p1.22", "p1.23",
 };
 
-static const char *gpio_p2_names[LPC32XX_GPIO_P2_MAX] = {
+static const char const *gpio_p2_names[LPC32XX_GPIO_P2_MAX] = {
 	"p2.0", "p2.1", "p2.2", "p2.3",
 	"p2.4", "p2.5", "p2.6", "p2.7",
 	"p2.8", "p2.9", "p2.10", "p2.11",
 	"p2.12"
 };
 
-static const char *gpio_p3_names[LPC32XX_GPIO_P3_MAX] = {
-	"gpi000", "gpio01", "gpio02", "gpio03",
+static const char const *gpio_p3_names[LPC32XX_GPIO_P3_MAX] = {
+	"gpio00", "gpio01", "gpio02", "gpio03",
 	"gpio04", "gpio05"
 };
 
-static const char *gpi_p3_names[LPC32XX_GPI_P3_MAX] = {
+static const char const *gpi_p3_names[LPC32XX_GPI_P3_MAX] = {
 	"gpi00", "gpi01", "gpi02", "gpi03",
 	"gpi04", "gpi05", "gpi06", "gpi07",
 	"gpi08", "gpi09",  NULL,    NULL,
 	 NULL,    NULL,    NULL,   "gpi15",
 	"gpi16", "gpi17", "gpi18", "gpi19",
 	"gpi20", "gpi21", "gpi22", "gpi23",
-	"gpi24", "gpi25", "gpi26", "gpi27"
+	"gpi24", "gpi25", "gpi26", "gpi27",
+	"gpi28"
 };
 
-static const char *gpo_p3_names[LPC32XX_GPO_P3_MAX] = {
+static const char const *gpo_p3_names[LPC32XX_GPO_P3_MAX] = {
 	"gpo00", "gpo01", "gpo02", "gpo03",
 	"gpo04", "gpo05", "gpo06", "gpo07",
 	"gpo08", "gpo09", "gpo10", "gpo11",
diff --git a/arch/arm/mach-lpc32xx/include/mach/board.h b/arch/arm/mach-lpc32xx/include/mach/board.h
new file mode 100644
index 0000000..3049eaf
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/board.h
@@ -0,0 +1,86 @@
+/*
+ * arm/arch/mach-lpc32xx/include/mach/board.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+#include "platform.h"
+#include <linux/mtd/partitions.h>
+#include <linux/serial_core.h>
+
+/*
+ * NAND platform configuration structure
+*/
+typedef int (*en_wp)(int);
+struct lpc32XX_nand_cfg
+{
+        u32             wdr_clks;
+        u32             wwidth;
+        u32             whold;
+        u32             wsetup;
+        u32             rdr_clks;
+        u32             rwidth;
+        u32             rhold;
+        u32             rsetup;
+	bool		use_bbt;
+	bool		polled_completion;
+        en_wp           enable_write_prot;
+        struct mtd_partition* (*partition_info)(int, int*);
+};
+
+/*
+ * Key scanner platform configuration structure
+ */
+struct lpc32XX_kscan_cfg {
+	u32	matrix_sz;	/* Size of matrix in XxY, ie. 3 = 3x3 */
+	int	*keymap;	/* Pointer to key map for the scan matrix */
+	u32	deb_clks;	/* Debounce clocks (based on 32KHz clock) */
+	u32	scan_delay;	/* Scan delay (based on 32KHz clock) */
+};
+
+/*
+ * Network configuration structure
+ */
+struct lpc_net_cfg {
+	int	phy_irq;	/* PHY IRQ number, or -1 for polling */
+	u32	phy_mask;	/* PHY mask value */
+};
+
+/*
+ * USB device configuration structure
+ */
+typedef void (*usc_chg_event)(int);
+struct lpc32xx_usbd_cfg
+{
+        int     vbus_drv_pol;   /* 0=active low drive for VBUS via ISP1301 */
+        usc_chg_event conn_chgb; /* Connection change event callback (optional) */
+        usc_chg_event susp_chgb; /* Suspend/resume event callback (optional) */
+        usc_chg_event rmwk_chgb; /* Enable/disable remote wakeup */
+};
+
+/*
+ * High Speed UART configuration structure
+ */
+struct lpc32xx_hsuart_port {
+	struct uart_port port;
+	unsigned int fbit_sam;
+};
+
+#endif	/* __ASM_ARCH_BOARD_H */
+
diff --git a/arch/arm/mach-lpc32xx/include/mach/debug-macro.S b/arch/arm/mach-lpc32xx/include/mach/debug-macro.S
index 629e744..910ea7c 100644
--- a/arch/arm/mach-lpc32xx/include/mach/debug-macro.S
+++ b/arch/arm/mach-lpc32xx/include/mach/debug-macro.S
@@ -20,6 +20,33 @@
  * Debug output is hardcoded to standard UART 5
 */
 
+#if defined(CONFIG_SERIAL_HS_LPC32XX_CONSOLE)
+		.macro	addruart,rp, rv
+		ldreq	\rp, =0x40014000	@ physical
+		ldrne	\rv, =0xF4014000	@ virtual
+1003:
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #0]
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldr	\rd, [\rx, #0x0]
+		ldr	\rd, [\rx, #0x4]
+		cmp	\rd, #0
+		bne	1002b
+		.endm
+
+		.macro	waituart,rd,rx
+1001:		ldr	\rd, [\rx, #0x0]
+		ldr	\rd, [\rx, #0x4]
+		cmp	\rd, #0
+		bne	1001b
+		.endm
+
+#else
+
 	.macro	addruart, rp, rv
 	ldreq	\rp, =0x40090000
 	ldrne	\rv, =0xF4090000
@@ -27,3 +54,5 @@
 
 #define UART_SHIFT	2
 #include <asm/hardware/debug-8250.S>
+#endif
+
diff --git a/arch/arm/mach-lpc32xx/include/mach/dma.h b/arch/arm/mach-lpc32xx/include/mach/dma.h
new file mode 100644
index 0000000..2bdec9f
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/dma.h
@@ -0,0 +1,116 @@
+/*
+ * asm-arm/arch-lpc32xx/dma.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#include <mach/platform.h>
+
+#define MAX_DMA_CHANNELS 8
+
+#define DMA_CH_SDCARD_TX	0
+#define DMA_CH_SDCARD_RX	1
+#define DMA_CH_I2S_TX		2
+#define DMA_CH_I2S_RX		3
+#define DMA_CH_SLCNAND		4
+
+enum {
+	DMA_NO_INT = 0,
+	DMA_ERR_INT = 1,
+	DMA_TC_INT = 2,
+};
+
+/*
+ * DMA channel control structure
+ */
+struct dma_config {
+	int ch;		/* Channel # to use */
+	int tc_inten;	/* !0 = Enable TC interrupts for this channel */
+	int err_inten;	/* !0 = Enable error interrupts for this channel */
+	int src_size;	/* Source xfer size - must be 1, 2, or 4 */
+	int src_inc;	/* !0 = Enable source address increment */
+	int src_ahb1;	/* !0 = Use AHB1 for source transfer */
+	int src_bsize;	/* Source burst size (ie, DMAC_CHAN_SRC_BURST_xxx) */
+	u32 src_prph;	/* Source peripheral (ie, DMA_PERID_xxxx) */
+	int dst_size;	/* Destination xfer size - must be 1, 2, or 4 */
+	int dst_inc;	/* !0 = Enable destination address increment */
+	int dst_ahb1;	/* !0 = Use AHB1 for destination transfer */
+	int dst_bsize;	/* Destination burst size (ie, DMAC_CHAN_DEST_BURST_xxx) */
+	u32 dst_prph;	/* Destination peripheral (ie, DMA_PERID_xxxx) */
+	u32 flowctrl;	/* Flow control (ie, DMAC_CHAN_FLOW_xxxxxx) */
+};
+
+/*
+ * Channel enable and disable functions
+ */
+extern int lpc32xx_dma_ch_enable(int ch);
+extern int lpc32xx_dma_ch_disable(int ch);
+
+/*
+ * Channel allocation and deallocation functions
+ */
+extern int lpc32xx_dma_ch_get(struct dma_config *dmachcfg,
+				char *name,
+				void *irq_handler,
+				void *data);
+extern int lpc32xx_dma_ch_put(int ch);
+extern int lpc32xx_dma_ch_pause_unpause(int ch, int pause);
+
+/*
+ * Setup or start an unbound DMA transfer
+ */
+extern int lpc32xx_dma_start_pflow_xfer(int ch,
+					void *src,
+					void *dst,
+					int enable);
+
+/*
+ * DMA channel status
+ */
+extern int lpc32xx_dma_is_active(int ch);
+
+/*
+ * DMA linked list support
+ */
+extern u32 lpc32xx_dma_alloc_llist(int ch,
+				   int entries);
+extern void lpc32xx_dma_dealloc_llist(int ch);
+extern u32 lpc32xx_dma_llist_v_to_p(int ch,
+				    u32 vlist);
+extern u32 lpc32xx_dma_llist_p_to_v(int ch,
+				    u32 plist);
+extern u32 lpc32xx_dma_get_llist_head(int ch);
+extern void lpc32xx_dma_flush_llist(int ch);
+extern u32 lpc32xx_dma_queue_llist_entry(int ch,
+					 void *src,
+					 void *dst,
+					 int size);
+extern u32 lpc32xx_get_free_llist_entry(int ch);
+extern u32 lpc32xx_dma_queue_llist(int ch,
+				   void *src,
+				   void *dst,
+				   int size,
+				   u32 ctrl);
+extern int lpc32xx_dma_start_xfer(int chan, u32 config);
+extern void lpc32xx_dma_force_burst(int ch, int src);
+
+#endif /* _ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/dmac.h b/arch/arm/mach-lpc32xx/include/mach/dmac.h
new file mode 100644
index 0000000..e7d82a7
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/dmac.h
@@ -0,0 +1,285 @@
+/*
+ * asm-arm/arch-lpc32xx/dmac.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMAC_H
+#define __ASM_ARCH_DMAC_H
+
+/**********************************************************************
+* DMA register offsets
+**********************************************************************/
+
+/* DMA controller register structures */
+#define DMA_INT_STAT(x)			(x + 0x00)
+#define DMA_INT_TC_STAT(x)		(x + 0x04)
+#define DMA_INT_TC_CLEAR(x)		(x + 0x08)
+#define DMA_INT_ERR_STAT(x)		(x + 0x0C)
+#define DMA_INT_ERR_CLEAR(x)		(x + 0x10)
+#define DMA_RAW_TC_STAT(x)		(x + 0x14)
+#define DMA_RAW_ERR_STAT(x)		(x + 0x18)
+#define DMA_CH_ENABLE(x)		(x + 0x1C)
+#define DMA_SW_BURST_REQ(x)		(x + 0x20)
+#define DMA_SW_SINGLE_REQ(x)		(x + 0x24)
+#define DMA_SW_LAST_BURST_REQ(x)	(x + 0x28)
+#define DMA_SW_LAST_SINGLE_REQ(x)	(x + 0x2C)
+#define DMA_CONFIG(x)			(x + 0x30)
+#define DMA_SYNC(x)			(x + 0x34)
+
+/* DMA controller channel register structure */
+#define DMA_CH_OFFS(c)			((c * 0x20) + 0x100)
+#define DMACH_SRC_ADDR(x, c)		(x + DMA_CH_OFFS(c) + 0x00)
+#define DMACH_DEST_ADDR(x, c)		(x + DMA_CH_OFFS(c) + 0x04)
+#define DMACH_LLI(x, c)			(x + DMA_CH_OFFS(c) + 0x08)
+#define DMACH_CONTROL(x, c)		(x + DMA_CH_OFFS(c) + 0x0C)
+#define DMACH_CONFIG_CH(x, c)		(x + DMA_CH_OFFS(c) + 0x10)
+
+/* DMA linked list structure */
+#define DMA_LL_SRC(x)			(x + 0x0)
+#define DMA_LL_DEST(x)			(x + 0x4)
+#define DMA_LL_NEXT_LLI(x)		(x + 0x8)
+#define DMA_LL_NEXT_CTRL(x)		(x + 0xC)
+
+#define DMA_LL_SIZE 16
+
+/**********************************************************************
+* int_stat, int_tc_stat, int_tc_clear, int_err_stat, raw_tc_stat,
+* raw_err_stat, and chan_enable register definitions
+**********************************************************************/
+/* Macro for determining a bit position for a channel */
+#define DMAC_GET_CHAN_POS(chan)     (0x1 << ((chan) & 0x7))
+
+/**********************************************************************
+* sw_burst_req, sw_single_req, sw_last_burst_req, sw_last_single_req,
+* and sync register definitions
+**********************************************************************/
+/* Peripheral DMA bit position for I2S0 DMA0 */
+#define DMA_PER_I2S0_DMA0           _BIT(0)
+
+/* Peripheral DMA bit position for NAND FLASH (same as 12) */
+#define DMA_PER_NAND1               _BIT(1)
+
+/* Peripheral DMA bit position for I2S1 DMA0 */
+#define DMA_PER_I2S1_DMA0           _BIT(2)
+
+/* Peripheral DMA bit position for SPI2 (RX and TX) */
+#define DMA_PER_SPI2_TXRX           _BIT(3)
+
+/* Peripheral DMA bit position for SSP1 (RX) */
+#define DMA_PER_SSP1_RX             _BIT(3)
+
+/* Peripheral DMA bit position for SD card */
+#define DMA_PER_SDCARD              _BIT(4)
+
+/* Peripheral DMA bit position for HSUART1 TX */
+#define DMA_PER_HSUART1_TX          _BIT(5)
+
+/* Peripheral DMA bit position for HSUART1 RX */
+#define DMA_PER_HSUART1_RX          _BIT(6)
+
+/* Peripheral DMA bit position for HSUART2 TX */
+#define DMA_PER_HSUART2_TX          _BIT(7)
+
+/* Peripheral DMA bit position for HSUART2 RX */
+#define DMA_PER_HSUART2_RX          _BIT(8)
+
+/* Peripheral DMA bit position for HSUART7 TX */
+#define DMA_PER_HSUART7_TX          _BIT(9)
+
+/* Peripheral DMA bit position for HSUART7 RX */
+#define DMA_PER_HSUART7_RX          _BIT(10)
+
+/* Peripheral DMA bit position for I2S1 DMA1 */
+#define DMA_PER_I2S1_DMA1           _BIT(10)
+
+/* Peripheral DMA bit position for SPI1 (RX and TX) */
+#define DMA_PER_SPI1_TXRX           _BIT(11)
+
+/* Peripheral DMA bit position for SSP1 (TX) */
+#define DMA_PER_SSP1_TX             _BIT(11)
+
+/* Peripheral DMA bit position for NAND FLASH (same as 1) */
+#define DMA_PER_NAND2               _BIT(12)
+
+/* Peripheral DMA bit position for I2S0 DMA1 */
+#define DMA_PER_I2S0_DMA1           _BIT(13)
+
+/* Peripheral DMA bit position for SSP0 (RX) */
+#define DMA_PER_SSP0_RX             _BIT(14)
+
+/* Peripheral DMA bit position for SSP0 (TX) */
+#define DMA_PER_SSP0_TX             _BIT(15)
+
+/**********************************************************************
+* config register definitions
+**********************************************************************/
+/* Bit for enabling big endian mode on AHB 1 */
+#define DMAC_BIG_ENDIAN_AHB1        _BIT(2)
+
+/* Bit for enabling big endian mode on AHB 0 */
+#define DMAC_BIG_ENDIAN_AHB0        _BIT(1)
+
+/* Bit for enabling the DMA controller */
+#define DMAC_CTRL_ENABLE            _BIT(0)
+
+/**********************************************************************
+* lli register definitions
+**********************************************************************/
+/* Bit for selecting AHB0 (0) or AHB1 (1) */
+#define DMAC_CHAN_LLI_SEL_AHB1      _BIT(0)
+
+/**********************************************************************
+* control register definitions
+**********************************************************************/
+/* Bit for enabling a channel terminal count interrupt */
+#define DMAC_CHAN_INT_TC_EN         _BIT(31)
+
+/* Bit for indicating address is cacheable */
+#define DMAC_CHAN_PROT3             _BIT(30)
+
+/* Bit for indicating address is bufferable */
+#define DMAC_CHAN_PROT2             _BIT(29)
+
+/* Bit for indicating address is privelaged mode (1) or user
+   mode (0) */
+#define DMAC_CHAN_PROT1             _BIT(28)
+
+/* Bit for enabling automatic destination increment */
+#define DMAC_CHAN_DEST_AUTOINC      _BIT(27)
+
+/* Bit for enabling automatic source increment */
+#define DMAC_CHAN_SRC_AUTOINC       _BIT(26)
+
+/* Bit for using AHB1 master for destination transfer */
+#define DMAC_CHAN_DEST_AHB1         _BIT(25)
+
+/* Bit for using AHB1 master for source transfer */
+#define DMAC_CHAN_SRC_AHB1          _BIT(24)
+
+/* Destination data width selection defines */
+#define DMAC_CHAN_DEST_WIDTH_8      0x0
+#define DMAC_CHAN_DEST_WIDTH_16     _BIT(21)
+#define DMAC_CHAN_DEST_WIDTH_32     _BIT(22)
+
+/* Source data width selection defines */
+#define DMAC_CHAN_SRC_WIDTH_8       0x0
+#define DMAC_CHAN_SRC_WIDTH_16      _BIT(18)
+#define DMAC_CHAN_SRC_WIDTH_32      _BIT(19)
+
+/* Destination data burst size defines (in transfer width) */
+#define DMAC_CHAN_DEST_BURST_1      0
+#define DMAC_CHAN_DEST_BURST_4      _BIT(15)
+#define DMAC_CHAN_DEST_BURST_8      _BIT(16)
+#define DMAC_CHAN_DEST_BURST_16     (_BIT(16) | _BIT(15))
+#define DMAC_CHAN_DEST_BURST_32     _BIT(17)
+#define DMAC_CHAN_DEST_BURST_64     (_BIT(17) | _BIT(15))
+#define DMAC_CHAN_DEST_BURST_128    (_BIT(17) | _BIT(16))
+#define DMAC_CHAN_DEST_BURST_256    (_BIT(17) | _BIT(16) | _BIT(15))
+
+/* Macro for direct loading of destination burst size field */
+#define DMAC_CHAN_DEST_BURST_LOAD(n) (((n) & 0x7) << 15)
+
+/* Source data burst size defines (in transfer width) */
+#define DMAC_CHAN_SRC_BURST_1       0
+#define DMAC_CHAN_SRC_BURST_4       _BIT(12)
+#define DMAC_CHAN_SRC_BURST_8       _BIT(13)
+#define DMAC_CHAN_SRC_BURST_16      (_BIT(13) | _BIT(12))
+#define DMAC_CHAN_SRC_BURST_32      _BIT(14)
+#define DMAC_CHAN_SRC_BURST_64      (_BIT(14) | _BIT(12))
+#define DMAC_CHAN_SRC_BURST_128     (_BIT(14) | _BIT(13))
+#define DMAC_CHAN_SRC_BURST_256     (_BIT(14) | _BIT(13) | _BIT(12))
+
+/* Macro for direct loading of source burst size field */
+#define DMAC_CHAN_SRC_BURST_LOAD(n) (((n) & 0x7) << 12)
+
+/* Macro for loading transfer size */
+#define DMAC_CHAN_TRANSFER_SIZE(n)  ((n) & 0xFFF)
+
+/**********************************************************************
+* config_ch register definitions
+**********************************************************************/
+/* Bit for halting a DMA transfer */
+#define DMAC_CHAN_HALT              _BIT(18)
+
+/* Bit for checking active status of the DMA channel */
+#define DMAC_CHAN_ACTIVE            _BIT(17)
+
+/* Bit for enabling locked transfers */
+#define DMAC_CHAN_LOCK              _BIT(16)
+
+/* Terminal count interrupt mask bit */
+#define DMAC_CHAN_ITC               _BIT(15)
+
+/* Interrupt error mask bit */
+#define DMAC_CHAN_IE                _BIT(14)
+
+/* Defines for flow control with DMA as the controller */
+#define DMAC_CHAN_FLOW_D_M2M        (0x0 << 11)
+#define DMAC_CHAN_FLOW_D_M2P        (0x1 << 11)
+#define DMAC_CHAN_FLOW_D_P2M        (0x2 << 11)
+#define DMAC_CHAN_FLOW_D_SP2DP      (0x3 << 11)
+
+/* Defines for flow control with destination peripheral as the
+   controller */
+#define DMAC_CHAN_FLOW_DP_SP2DP     (0x4 << 11)
+
+/* Defines for flow control with peripheral as the controller */
+#define DMAC_CHAN_FLOW_P_M2P        (0x5 << 11)
+#define DMAC_CHAN_FLOW_P_P2M        (0x6 << 11)
+
+/* Defines for flow control with source peripheral as the
+   controller */
+#define DMAC_CHAN_FLOW_SP_SP2DP     (0x7 << 11)
+
+/* Macro for loading destination peripheral */
+#define DMAC_DEST_PERIP(n)          (((n) & 0x1F) << 6)
+
+/* Macro for loading source peripheral */
+#define DMAC_SRC_PERIP(n)           (((n) & 0x1F) << 1)
+
+/* Channel enable bit */
+#define DMAC_CHAN_ENABLE            _BIT(0)
+
+/**********************************************************************
+* config_ch register definitions (source and destination
+* peripheral ID numbers). These can be used with the DMAC_DEST_PERIP
+* and DMAC_SRC_PERIP macros.
+**********************************************************************/
+#define DMA_PERID_I2S0_DMA0         0
+#define DMA_PERID_NAND1             1
+#define DMA_PERID_I2S1_DMA0         2
+#define DMA_PERID_SPI2_TXRX         3
+#define DMA_PERID_SSP1_RX           3
+#define DMA_PERID_SDCARD            4
+#define DMA_PERID_HSUART1_TX        5
+#define DMA_PERID_HSUART1_RX        6
+#define DMA_PERID_HSUART2_TX        7
+#define DMA_PERID_HSUART2_RX        8
+#define DMA_PERID_HSUART7_TX        9
+#define DMA_PERID_HSUART7_RX        10
+#define DMA_PERID_I2S1_DMA1         10
+#define DMA_PERID_SPI1_TXRX         11
+#define DMA_PERID_SSP1_TX           11
+#define DMA_PERID_NAND2             12
+#define DMA_PERID_I2S0_DMA1         13
+#define DMA_PERID_SSP0_RX           14
+#define DMA_PERID_SSP0_TX           15
+
+#endif /* __ASM_ARCH_DMAC_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/gpio.h b/arch/arm/mach-lpc32xx/include/mach/gpio.h
index 67d03da..0c18c51 100644
--- a/arch/arm/mach-lpc32xx/include/mach/gpio.h
+++ b/arch/arm/mach-lpc32xx/include/mach/gpio.h
@@ -34,7 +34,7 @@
 #define LPC32XX_GPIO_P1_MAX 24
 #define LPC32XX_GPIO_P2_MAX 13
 #define LPC32XX_GPIO_P3_MAX 6
-#define LPC32XX_GPI_P3_MAX 28
+#define LPC32XX_GPI_P3_MAX 29
 #define LPC32XX_GPO_P3_MAX 24
 
 #define LPC32XX_GPIO_P0_GRP 0
diff --git a/arch/arm/mach-lpc32xx/include/mach/i2s.h b/arch/arm/mach-lpc32xx/include/mach/i2s.h
new file mode 100644
index 0000000..63ec790
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/i2s.h
@@ -0,0 +1,156 @@
+/*
+ * asm-arm/arch-lpc32xx/i2c.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef  __ASM_ARCH_I2S_H
+#define  __ASM_ARCH_I2S_H
+
+/**********************************************************************
+* I2S controller register offsets
+**********************************************************************/
+
+#define I2S_DAO(x)			(x + 0x00)
+#define I2S_DAI(x)			(x + 0x04)
+#define I2S_TX_FIFO(x)			(x + 0x08)
+#define I2S_RX_FIFO(x)			(x + 0x0C)
+#define I2S_STAT(x)			(x + 0x10)
+#define I2S_DMA0(x)			(x + 0x14)
+#define I2S_DMA1(x)			(x + 0x18)
+#define I2S_IRQ(x)			(x + 0x1C)
+#define I2S_TX_RATE(x)			(x + 0x20)
+#define I2S_RX_RATE(x)			(x + 0x24)
+
+/**********************************************************************
+* i2s_daO i2s_dai register definitions
+**********************************************************************/
+#define I2S_WW8      _SBF(0,0) /* Word width is 8bit*/
+#define I2S_WW16     _SBF(0,1) /* Word width is 16bit*/
+#define I2S_WW32     _SBF(0,3) /* Word width is 32bit*/
+#define I2S_MONO     _BIT(2)   /* Mono */
+#define I2S_STOP     _BIT(3)   /* Stop, diables the access to FIFO, 
+                                  mutes the channel */
+#define I2S_RESET    _BIT(4)   /* Reset the channel */
+#define I2S_WS_SEL   _BIT(5)   /* Channel Master(0) or slave(1) 
+                                  mode select*/
+#define I2S_WS_HP(s) _SBF(6,s) /* Word select half period - 1 */
+
+#define I2S_MUTE     _BIT(15)  /* Mute the channel, 
+                                  Transmit channel only */
+
+#define I2S_WW32_HP  0x1f /* Word select half period for 32bit 
+                             word width */
+#define I2S_WW16_HP  0x0f /* Word select half period for 16bit 
+                             word width */
+#define I2S_WW8_HP   0x7  /* Word select half period for 8bit
+                             word width */
+
+#define WSMASK_HP	  0X7FC /* Mask for WS half period bits */
+
+/**********************************************************************
+* i2s_tx_fifo register definitions
+**********************************************************************/
+#define I2S_FIFO_TX_WRITE(d)              (d)
+
+/**********************************************************************
+* i2s_rx_fifo register definitions
+**********************************************************************/
+#define I2S_FIFO_RX_WRITE(d)              (d)
+
+/**********************************************************************
+* i2s_stat register definitions
+**********************************************************************/
+#define I2S_IRQ_STAT     _BIT(0)
+#define I2S_DMA0_REQ     _BIT(1)
+#define I2S_DMA1_REQ     _BIT(2)
+
+#define I2S_RX_STATE_MASK	0x0000ff00
+#define I2S_TX_STATE_MASK	0x00ff0000
+
+/**********************************************************************
+* i2s_dma0 Configuration register definitions
+**********************************************************************/
+#define I2S_DMA0_RX_EN     _BIT(0)       /* Enable RX DMA1*/
+#define I2S_DMA0_TX_EN     _BIT(1)       /* Enable TX DMA1*/
+#define I2S_DMA0_RX_DEPTH(s)  _SBF(8,s)  /* Set the level for DMA1 
+                                            RX Request */
+#define I2S_DMA0_TX_DEPTH(s)  _SBF(16,s) /* Set the level for DMA1 
+                                            TX Request */
+
+/**********************************************************************
+* i2s_dma1 Configuration register definitions
+**********************************************************************/
+#define I2S_DMA1_RX_EN     _BIT(0)       /* Enable RX DMA1*/
+#define I2S_DMA1_TX_EN     _BIT(1)       /* Enable TX DMA1*/
+#define I2S_DMA1_RX_DEPTH(s)  _SBF(8,s)	 /* Set the level for DMA1 
+                                            RX Request */
+#define I2S_DMA1_TX_DEPTH(s)  _SBF(16,s) /* Set the level for DMA1 
+                                            TX Request */
+
+/**********************************************************************
+* i2s_irq register definitions
+**********************************************************************/
+#define I2S_RX_IRQ_EN     _BIT(0)       /* Enable RX IRQ*/
+#define I2S_TX_IRQ_EN     _BIT(1)       /* Enable TX IRQ*/
+#define I2S_IRQ_RX_DEPTH(s)  _SBF(8,s)  /* valid values ar 0 to 7 */
+#define I2S_IRQ_TX_DEPTH(s)  _SBF(16,s) /* valid values ar 0 to 7 */
+
+/**********************************************************************
+* define audio rates for i2s_tx_rate/i2s_rx_rate register definitions
+**********************************************************************/
+
+#define A96KHZ104MHZ8BIT 0x7ed  // 7, 237
+#define A48KHZ104MHZ8BIT 0x3cb  // 3, 203
+#define A44KHZ104MHZ8BIT 0x14a  // 1, 74
+#define A32KHZ104MHZ8BIT 0x5fe	// 5, 254
+#define A22KHZ104MHZ8BIT 0x194  // 1, 148
+#define A16KHZ104MHZ8BIT 0x1cb	// 1, 203
+
+#define A96KHZ104MHZ16BIT 0xeed	//  14, 237
+#define A48KHZ104MHZ16BIT 0x7ED //  7, 237
+#define A44KHZ104MHZ16BIT 0x6dd //  6, 221	
+#define A32KHZ104MHZ16BIT 0x5fe //  5, 254
+#define A22KHZ104MHZ16BIT 0x14a //  1, 74
+#define A16KHZ104MHZ16BIT 0x2cb //  2, 203
+
+#define A96KHZ104MHZ32BIT 0x1ced// 28, 237
+#define A48KHZ104MHZ32BIT 0xeed // 14, 237 
+#define A44KHZ104MHZ32BIT 0xdf0 // 13, 240 
+#define A32KHZ104MHZ32BIT 0x57f	// 5, 127
+#define A22KHZ104MHZ32BIT 0x125 // 1, 37 
+#define A16KHZ104MHZ32BIT 0x5fe // 5, 254 
+
+/**********************************************************************
+* i2s_tx_rate register definitions
+**********************************************************************/
+#define I2S_SET_TX_RATE(d)          (d)
+
+/**********************************************************************
+* i2s_rx_rate register definitions
+**********************************************************************/
+#define I2S_SET_RX_RATE(d)          (d)
+
+/**********************************************************************
+* i2s channel select
+**********************************************************************/
+#define I2S_CH0	0
+#define I2S_CH1	1
+
+#endif /*  __ASM_ARCH_I2S_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/irqs.h b/arch/arm/mach-lpc32xx/include/mach/irqs.h
index 2667f52..19fec8d 100644
--- a/arch/arm/mach-lpc32xx/include/mach/irqs.h
+++ b/arch/arm/mach-lpc32xx/include/mach/irqs.h
@@ -23,6 +23,22 @@
 #define LPC32XX_SIC2_IRQ(n)		(64 + (n))
 
 /*
+ * Default value representing the Activation polarity of all internal
+ * interrupt sources
+ */
+#define MIC_APR_DEFAULT		0x3FF0EFE0
+#define SIC1_APR_DEFAULT	0xFBD27186
+#define SIC2_APR_DEFAULT	0x801810C0
+
+/*
+ * Default value representing the Activation Type of all internal
+ * interrupt sources. All are level sensitive.
+ */
+#define MIC_ATR_DEFAULT		0x00000000
+#define SIC1_ATR_DEFAULT	0x00026000
+#define SIC2_ATR_DEFAULT	0x00000000
+
+/*
  * MIC interrupts
  */
 #define IRQ_LPC32XX_SUB1IRQ		0
@@ -61,7 +77,7 @@
  */
 #define IRQ_LPC32XX_JTAG_COMM_TX	LPC32XX_SIC1_IRQ(1)
 #define IRQ_LPC32XX_JTAG_COMM_RX	LPC32XX_SIC1_IRQ(2)
-#define IRQ_LPC32XX_GPI_11		LPC32XX_SIC1_IRQ(4)
+#define IRQ_LPC32XX_GPI_28		LPC32XX_SIC1_IRQ(4)
 #define IRQ_LPC32XX_TS_P		LPC32XX_SIC1_IRQ(6)
 #define IRQ_LPC32XX_TS_IRQ		LPC32XX_SIC1_IRQ(7)
 #define IRQ_LPC32XX_TS_AUX		LPC32XX_SIC1_IRQ(8)
@@ -113,5 +129,6 @@
 #define IRQ_LPC32XX_SYSCLK		LPC32XX_SIC2_IRQ(31)
 
 #define NR_IRQS				96
+#define NR_IRQ_CTRLS	3
 
 #endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/platform.h b/arch/arm/mach-lpc32xx/include/mach/platform.h
index 14ea8d1..a2bff7b 100644
--- a/arch/arm/mach-lpc32xx/include/mach/platform.h
+++ b/arch/arm/mach-lpc32xx/include/mach/platform.h
@@ -253,6 +253,8 @@
 #define LPC32XX_CLKPWR_INTSRC_GPIO_02_BIT	_BIT(2)
 #define LPC32XX_CLKPWR_INTSRC_GPIO_01_BIT	_BIT(1)
 #define LPC32XX_CLKPWR_INTSRC_GPIO_00_BIT	_BIT(0)
+/* Reserved bits */
+#define LPC32XX_CLKPWR_INTSRC_MASK		~(0x1806FF00)
 
 /*
  * clkpwr_start_pin, clkpwr_start_raw_sts_pin, clkpwr_start_sts_pin,
@@ -281,8 +283,11 @@
 #define LPC32XX_CLKPWR_EXTSRC_GPI_07_BIT	_BIT(7)
 #define LPC32XX_CLKPWR_EXTSRC_SPI2_DATIN_BIT	_BIT(6)
 #define LPC32XX_CLKPWR_EXTSRC_GPI_19_BIT	_BIT(5)
+#define LPC32XX_CLKPWR_EXTSRC_U4_RX_BIT		 _BIT(5)
 #define LPC32XX_CLKPWR_EXTSRC_GPI_09_BIT	_BIT(4)
 #define LPC32XX_CLKPWR_EXTSRC_GPI_08_BIT	_BIT(3)
+/* Reserved bits */
+#define LPC32XX_CLKPWR_EXTSRC_MASK		~(0x28180007)
 
 /*
  * clkpwr_hclk_div register definitions
@@ -591,42 +596,42 @@
 /*
  * Timer/counter register offsets
  */
-#define LCP32XX_TIMER_IR(x)			io_p2v((x) + 0x00)
-#define LCP32XX_TIMER_TCR(x)			io_p2v((x) + 0x04)
-#define LCP32XX_TIMER_TC(x)			io_p2v((x) + 0x08)
-#define LCP32XX_TIMER_PR(x)			io_p2v((x) + 0x0C)
-#define LCP32XX_TIMER_PC(x)			io_p2v((x) + 0x10)
-#define LCP32XX_TIMER_MCR(x)			io_p2v((x) + 0x14)
-#define LCP32XX_TIMER_MR0(x)			io_p2v((x) + 0x18)
-#define LCP32XX_TIMER_MR1(x)			io_p2v((x) + 0x1C)
-#define LCP32XX_TIMER_MR2(x)			io_p2v((x) + 0x20)
-#define LCP32XX_TIMER_MR3(x)			io_p2v((x) + 0x24)
-#define LCP32XX_TIMER_CCR(x)			io_p2v((x) + 0x28)
-#define LCP32XX_TIMER_CR0(x)			io_p2v((x) + 0x2C)
-#define LCP32XX_TIMER_CR1(x)			io_p2v((x) + 0x30)
-#define LCP32XX_TIMER_CR2(x)			io_p2v((x) + 0x34)
-#define LCP32XX_TIMER_CR3(x)			io_p2v((x) + 0x38)
-#define LCP32XX_TIMER_EMR(x)			io_p2v((x) + 0x3C)
-#define LCP32XX_TIMER_CTCR(x)			io_p2v((x) + 0x70)
+#define LPC32XX_TIMER_IR(x)			io_p2v((x) + 0x00)
+#define LPC32XX_TIMER_TCR(x)			io_p2v((x) + 0x04)
+#define LPC32XX_TIMER_TC(x)			io_p2v((x) + 0x08)
+#define LPC32XX_TIMER_PR(x)			io_p2v((x) + 0x0C)
+#define LPC32XX_TIMER_PC(x)			io_p2v((x) + 0x10)
+#define LPC32XX_TIMER_MCR(x)			io_p2v((x) + 0x14)
+#define LPC32XX_TIMER_MR0(x)			io_p2v((x) + 0x18)
+#define LPC32XX_TIMER_MR1(x)			io_p2v((x) + 0x1C)
+#define LPC32XX_TIMER_MR2(x)			io_p2v((x) + 0x20)
+#define LPC32XX_TIMER_MR3(x)			io_p2v((x) + 0x24)
+#define LPC32XX_TIMER_CCR(x)			io_p2v((x) + 0x28)
+#define LPC32XX_TIMER_CR0(x)			io_p2v((x) + 0x2C)
+#define LPC32XX_TIMER_CR1(x)			io_p2v((x) + 0x30)
+#define LPC32XX_TIMER_CR2(x)			io_p2v((x) + 0x34)
+#define LPC32XX_TIMER_CR3(x)			io_p2v((x) + 0x38)
+#define LPC32XX_TIMER_EMR(x)			io_p2v((x) + 0x3C)
+#define LPC32XX_TIMER_CTCR(x)			io_p2v((x) + 0x70)
 
 /*
  * ir register definitions
  */
-#define LCP32XX_TIMER_CNTR_MTCH_BIT(n)		(1 << ((n) & 0x3))
-#define LCP32XX_TIMER_CNTR_CAPT_BIT(n)		(1 << (4 + ((n) & 0x3)))
+#define LPC32XX_TIMER_CNTR_MTCH_BIT(n)		(1 << ((n) & 0x3))
+#define LPC32XX_TIMER_CNTR_CAPT_BIT(n)		(1 << (4 + ((n) & 0x3)))
 
 /*
  * tcr register definitions
  */
-#define LCP32XX_TIMER_CNTR_TCR_EN		0x1
-#define LCP32XX_TIMER_CNTR_TCR_RESET		0x2
+#define LPC32XX_TIMER_CNTR_TCR_EN		0x1
+#define LPC32XX_TIMER_CNTR_TCR_RESET		0x2
 
 /*
  * mcr register definitions
  */
-#define LCP32XX_TIMER_CNTR_MCR_MTCH(n)		(0x1 << ((n) * 3))
-#define LCP32XX_TIMER_CNTR_MCR_RESET(n)		(0x1 << (((n) * 3) + 1))
-#define LCP32XX_TIMER_CNTR_MCR_STOP(n)		(0x1 << (((n) * 3) + 2))
+#define LPC32XX_TIMER_CNTR_MCR_MTCH(n)		(0x1 << ((n) * 3))
+#define LPC32XX_TIMER_CNTR_MCR_RESET(n)		(0x1 << (((n) * 3) + 1))
+#define LPC32XX_TIMER_CNTR_MCR_STOP(n)		(0x1 << (((n) * 3) + 2))
 
 /*
  * Standard UART register offsets
@@ -690,5 +695,8 @@
 #define LPC32XX_GPIO_P1_MUX_SET			_GPREG(0x130)
 #define LPC32XX_GPIO_P1_MUX_CLR			_GPREG(0x134)
 #define LPC32XX_GPIO_P1_MUX_STATE		_GPREG(0x138)
+#define LPC32XX_GPIO_P2_MUX_SET			_GPREG(0x028)
+#define LPC32XX_GPIO_P2_MUX_CLR			_GPREG(0x02C)
+#define LPC32XX_GPIO_P2_MUX_STATE		_GPREG(0x030)
 
 #endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/sdcard.h b/arch/arm/mach-lpc32xx/include/mach/sdcard.h
new file mode 100644
index 0000000..cc4a6af
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/sdcard.h
@@ -0,0 +1,177 @@
+/*
+ * asm-arm/arch-lpc32xx/sdcard.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SDCARD_H
+#define __ASM_ARCH_SDCARD_H
+
+/**********************************************************************
+* SD Card controller register offsets
+**********************************************************************/
+
+#define SD_POWER(x)			(x + 0x00)
+#define SD_CLOCK(x)			(x + 0x04)
+#define SD_ARG(x)			(x + 0x08)
+#define SD_CMD(x)			(x + 0x10)
+#define SD_RESPCMD(x)			(x + 0x14)
+#define SD_RESP(x)			(x + 0x18)
+#define SD_DTIMER(x)			(x + 0x28)
+#define SD_DLEN(x)			(x + 0x2C)
+#define SD_DCTRL(x)			(x + 0x30)
+#define SD_DCNT(x)			(x + 0x34)
+#define SD_STATUS(x)			(x + 0x38)
+#define SD_CLEAR(x)			(x + 0x3C)
+#define SD_MASK0(x)			(x + 0x40)
+#define SD_MASK1(x)			(x + 0x44)
+#define SD_FIFOCNT(x)			(x + 0x4C)
+#define SD_FIFO(x)			(x + 0x80)
+
+/**********************************************************************
+* sd_power register definitions
+**********************************************************************/
+/* SD bit for enabling open drain mode (1) or pushpull mode (0) */
+#define SD_OPENDRAIN_EN            _BIT(6)
+/* SD power control mode: power off */
+#define SD_POWER_OFF_MODE          0x0
+/* SD power control mode: power up */
+#define SD_POWER_UP_MODE           0x2
+/* SD power control mode: power on */
+#define SD_POWER_ON_MODE           0x3
+/* SD power control mode mask */
+#define SD_POWER_MODE_MASK         0x3
+
+/**********************************************************************
+* sd_clock register definitions
+**********************************************************************/
+/* SD bit for enabling side bus mode */
+#define SD_WIDEBUSMODE_EN          _BIT(11)
+/* SD bit for enabling SDCLK clock bypass */
+#define SD_SDCLK_BYPASS            _BIT(10)
+/* SD bit for enabling clock throttling during idle states */
+#define SD_SDCLK_PWRSAVE           _BIT(9)
+/* SD bit for enabling the SD clock */
+#define SD_SDCLK_EN                _BIT(8)
+/* SD clock divider bit mask */
+#define SD_CLKDIV_MASK             0xFF
+
+/**********************************************************************
+* sd_cmd register definitions
+**********************************************************************/
+/* SD bit for enabling command path state machine */
+#define SD_CPST_EN                 _BIT(10)
+/* SD bit for wait for CMDPEND prior to sending command */
+#define SD_CMDPEND_WAIT            _BIT(9)
+/* SD bit for enabling card interrupt request (without timeout) */
+#define SD_INTERRUPT_EN            _BIT(8)
+/* SD bit for enabling 136-bit response support */
+#define SD_LONGRESP_EN             _BIT(7)
+/* SD bit for enabling response support */
+#define SD_RESPONSE                _BIT(6)
+/* SD command mask */
+#define SD_CMD_MASK                0x3F
+
+/**********************************************************************
+* sd_dctrl register definitions
+**********************************************************************/
+/* SD data transfer blocksize of 1 byte */
+#define SD_BLKSIZE_1BYTE           0x00
+/* SD data transfer blocksize of 2 bytes */
+#define SD_BLKSIZE_2BYTES          0x10
+/* SD data transfer blocksize of 4 bytes */
+#define SD_BLKSIZE_4BYTES          0x20
+/* SD data transfer blocksize of 8 bytes */
+#define SD_BLKSIZE_8BYTES          0x30
+/* SD data transfer blocksize of 16 bytes */
+#define SD_BLKSIZE_16BYTES         0x40
+/* SD data transfer blocksize of 32 bytes */
+#define SD_BLKSIZE_32BYTES         0x50
+/* SD data transfer blocksize of 64 bytes */
+#define SD_BLKSIZE_64BYTES         0x60
+/* SD data transfer blocksize of 128 bytes */
+#define SD_BLKSIZE_128BYTES        0x70
+/* SD data transfer blocksize of 256 bytes */
+#define SD_BLKSIZE_256BYTES        0x80
+/* SD data transfer blocksize of 512 bytes */
+#define SD_BLKSIZE_512BYTES        0x90
+/* SD data transfer blocksize of 1024 bytes */
+#define SD_BLKSIZE_1024BYTES       0xA0
+/* SD data transfer blocksize of 2048 bytes */
+#define SD_BLKSIZE_2048BYTES       0xB0
+/* SD bit for enabling DMA */
+#define SD_DMA_EN                  _BIT(3)
+/* SD bit for enabling a stream transfer */
+#define SD_STREAM_EN               _BIT(2)
+/* SD direction bit (1 = receive, 0 = transmit) */
+#define SD_DIR_FROMCARD            _BIT(1)
+/* SD data transfer enable bit */
+#define SD_DATATRANSFER_EN         _BIT(0)
+
+/**********************************************************************
+* sd_status register definitions
+* sd_clear register definitions (bits 0..10 only)
+* sd_mask0, sd_mask1 register definitions
+**********************************************************************/
+/* SD bit for data receive FIFO NOT empty status */
+#define SD_FIFO_RXDATA_AVAIL       _BIT(21)
+/* SD bit for data transmit FIFO NOT empty status */
+#define SD_FIFO_TXDATA_AVAIL       _BIT(20)
+/* SD bit for data receive FIFO empty status */
+#define SD_FIFO_RXDATA_EMPTY       _BIT(19)
+/* SD bit for data transmit FIFO empty status */
+#define SD_FIFO_TXDATA_EMPTY       _BIT(18)
+/* SD bit for data receive FIFO full status */
+#define SD_FIFO_RXDATA_FULL        _BIT(17)
+/* SD bit for data transmit FIFO full status */
+#define SD_FIFO_TXDATA_FULL        _BIT(16)
+/* SD bit for data receive FIFO half-full status */
+#define SD_FIFO_RXDATA_HFULL       _BIT(15)
+/* SD bit for data transmit FIFO half-empty status */
+#define SD_FIFO_TXDATA_HEMPTY      _BIT(14)
+/* SD bit for data receive in progress status */
+#define SD_RX_INPROGRESS           _BIT(13)
+/* SD bit for data transmit in progress status */
+#define SD_TX_INPROGRESS           _BIT(12)
+/* SD bit for command transfer in progress status */
+#define SD_CMD_INPROGRESS          _BIT(11)
+/* SD bit for data block send/received complete (CRC good) status */
+#define SD_DATABLK_END             _BIT(10)
+/* SD bit for start bit detection error status */
+#define SD_STARTBIT_ERR            _BIT(9)
+/* SD bit for data end (data counter is 0) status */
+#define SD_DATA_END                _BIT(8)
+/* SD bit for command sent status */
+#define SD_CMD_SENT                _BIT(7)
+/* SD bit for command response received (CRC good) status */
+#define SD_CMD_RESP_RECEIVED       _BIT(6)
+/* SD bit for data receive FIFO overflow status */
+#define SD_FIFO_RXDATA_OFLOW       _BIT(5)
+/* SD bit for data transmit FIFO underflow status */
+#define SD_FIFO_TXDATA_UFLOW       _BIT(4)
+/* SD bit for data timeout status */
+#define SD_DATA_TIMEOUT            _BIT(3)
+/* SD bit for command timeout status */
+#define SD_CMD_TIMEOUT             _BIT(2)
+/* SD bit for data CRC failure status */
+#define SD_DATA_CRC_FAIL           _BIT(1)
+/* SD bit for command CRC failure status */
+#define SD_CMD_CRC_FAIL            _BIT(0)
+
+#endif /* __ASM_ARCH_SDCARD_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/slcnand.h b/arch/arm/mach-lpc32xx/include/mach/slcnand.h
new file mode 100644
index 0000000..6d9c896
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/slcnand.h
@@ -0,0 +1,103 @@
+/*
+ * asm-arm/arch-lpc32xx/slcnand.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SLCNAND_H
+#define __ASM_ARCH_SLCNAND_H
+
+/**********************************************************************
+* SLC NAND controller register offsets
+**********************************************************************/
+
+#define SLC_DATA(x)			(x + 0x000)
+#define SLC_ADDR(x)			(x + 0x004)
+#define SLC_CMD(x)			(x + 0x008)
+#define SLC_STOP(x)			(x + 0x00C)
+#define SLC_CTRL(x)			(x + 0x010)
+#define SLC_CFG(x)			(x + 0x014)
+#define SLC_STAT(x)			(x + 0x018)
+#define SLC_INT_STAT(x)			(x + 0x01C)
+#define SLC_IEN(x)			(x + 0x020)
+#define SLC_ISR(x)			(x + 0x024)
+#define SLC_ICR(x)			(x + 0x028)
+#define SLC_TAC(x)			(x + 0x02C)
+#define SLC_TC(x)			(x + 0x030)
+#define SLC_ECC(x)			(x + 0x034)
+#define SLC_DMA_DATA(x)			(x + 0x038)
+
+/**********************************************************************
+* slc_ctrl register definitions
+**********************************************************************/
+#define SLCCTRL_SW_RESET    _BIT(2) /* Reset the NAND controller bit */
+#define SLCCTRL_ECC_CLEAR   _BIT(1) /* Reset ECC bit */
+#define SLCCTRL_DMA_START   _BIT(0) /* Start DMA channel bit */
+
+/**********************************************************************
+* slc_cfg register definitions
+**********************************************************************/
+#define SLCCFG_CE_LOW       _BIT(5) /* Force CE low bit */
+#define SLCCFG_DMA_ECC      _BIT(4) /* Enable DMA ECC bit */
+#define SLCCFG_ECC_EN       _BIT(3) /* ECC enable bit */
+#define SLCCFG_DMA_BURST    _BIT(2) /* DMA burst bit */
+#define SLCCFG_DMA_DIR      _BIT(1) /* DMA write(0)/read(1) bit */
+#define SLCCFG_WIDTH        _BIT(0) /* External device width, 0=8bit */
+
+/**********************************************************************
+* slc_stat register definitions
+**********************************************************************/
+#define SLCSTAT_DMA_FIFO    _BIT(2) /* DMA FIFO has data bit */
+#define SLCSTAT_SLC_FIFO    _BIT(1) /* SLC FIFO has data bit */
+#define SLCSTAT_NAND_READY  _BIT(0) /* NAND device is ready bit */
+
+/**********************************************************************
+* slc_int_stat, slc_ien, slc_isr, and slc_icr register definitions
+**********************************************************************/
+#define SLCSTAT_INT_TC      _BIT(1) /* Transfer count bit */
+#define SLCSTAT_INT_RDY_EN  _BIT(0) /* Ready interrupt bit */
+
+/**********************************************************************
+* slc_tac register definitions
+**********************************************************************/
+/* Clock setting for RDY write sample wait time in 2*n clocks */
+#define SLCTAC_WDR(n)       (((n) & 0xF) << 28)
+/* Write pulse width in clocks cycles, 1 to 16 clocks */
+#define SLCTAC_WWIDTH(n)    (((n) & 0xF) << 24)
+/* Write hold time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_WHOLD(n)     (((n) & 0xF) << 20)
+/* Write setup time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_WSETUP(n)    (((n) & 0xF) << 16)
+/* Clock setting for RDY read sample wait time in 2*n clocks */
+#define SLCTAC_RDR(n)       (((n) & 0xF) << 12)
+/* Read pulse width in clocks cycles, 1 to 16 clocks */
+#define SLCTAC_RWIDTH(n)    (((n) & 0xF) << 8)
+/* Read hold time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_RHOLD(n)     (((n) & 0xF) << 4)
+/* Read setup time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_RSETUP(n)    (((n) & 0xF) << 0)
+
+/**********************************************************************
+* slc_ecc register definitions
+**********************************************************************/
+/* ECC line party fetch macro */
+#define SLCECC_TO_LINEPAR(n) (((n) >> 6) & 0x7FFF)
+#define SLCECC_TO_COLPAR(n)  ((n) & 0x3F)
+
+#endif /* __ASM_ARCH_SLCNAND_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/uncompress.h b/arch/arm/mach-lpc32xx/include/mach/uncompress.h
index c142487..c4ffa37 100644
--- a/arch/arm/mach-lpc32xx/include/mach/uncompress.h
+++ b/arch/arm/mach-lpc32xx/include/mach/uncompress.h
@@ -24,6 +24,28 @@
 #include <mach/hardware.h>
 #include <mach/platform.h>
 
+#if defined(CONFIG_SERIAL_HS_LPC32XX_CONSOLE)
+
+#define HSUART_FIFO     (*(volatile unsigned char *)(LPC32XX_HS_UART1_BASE + 0x00))
+#define HSUART_LEVEL    (*(volatile unsigned short *)(LPC32XX_HS_UART1_BASE + 0x04))
+
+static inline void putc(int ch)
+{
+    /* Wait for transmit FIFO to empty */
+    while ((HSUART_LEVEL & 0xFF00) != 0);
+    HSUART_FIFO = ch;
+}
+
+static inline void flush(void)
+{
+
+    /* Don't see a reset? */
+
+    /* Then just wait for transmition to complete */
+    while ((HSUART_LEVEL & 0xFF00) != 0);
+}
+
+#else
 /*
  * Uncompress output is hardcoded to standard UART 5
  */
@@ -52,6 +74,7 @@ static inline void flush(void)
 	__raw_writel(__raw_readl(_UARTREG(LPC32XX_UART_IIRFCR_O)) |
 		UART_FIFO_CTL_TX_RESET, _UARTREG(LPC32XX_UART_IIRFCR_O));
 }
+#endif
 
 /* NULL functions; we don't presently need them */
 #define arch_decomp_setup()
diff --git a/arch/arm/mach-lpc32xx/include/mach/usbd.h b/arch/arm/mach-lpc32xx/include/mach/usbd.h
new file mode 100644
index 0000000..f10efae
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/usbd.h
@@ -0,0 +1,291 @@
+/*
+ * asm-arm/arch-lpc32xx/usbd.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_USBD_H
+#define __ASM_ARCH_USBD_H
+
+/**********************************************************************
+* USE device controller register offsets
+**********************************************************************/
+
+#define USBD_DEVINTST(x)	(x + 0x200)
+#define USBD_DEVINTEN(x)	(x + 0x204)
+#define USBD_DEVINTCLR(x)	(x + 0x208)
+#define USBD_DEVINTSET(x)	(x + 0x20C)
+#define USBD_CMDCODE(x)		(x + 0x210)
+#define USBD_CMDDATA(x)		(x + 0x214)
+#define USBD_RXDATA(x)		(x + 0x218)
+#define USBD_TXDATA(x)		(x + 0x21C)
+#define USBD_RXPLEN(x)		(x + 0x220)
+#define USBD_TXPLEN(x)		(x + 0x224)
+#define USBD_CTRL(x)		(x + 0x228)
+#define USBD_DEVINTPRI(x)	(x + 0x22C)
+#define USBD_EPINTST(x)		(x + 0x230)
+#define USBD_EPINTEN(x)		(x + 0x234)
+#define USBD_EPINTCLR(x)	(x + 0x238)
+#define USBD_EPINTSET(x)	(x + 0x23C)
+#define USBD_EPINTPRI(x)	(x + 0x240)
+#define USBD_REEP(x)		(x + 0x244)
+#define USBD_EPIND(x)		(x + 0x248)
+#define USBD_EPMAXPSIZE(x)	(x + 0x24C)
+/* DMA support registers only below */
+/* Set, clear, or get enabled state of the DMA request status. If
+   enabled, an IN or OUT token will start a DMA transfer for the EP */
+#define USBD_DMARST(x)		(x + 0x250)
+#define USBD_DMARCLR(x)		(x + 0x254)
+#define USBD_DMARSET(x)		(x + 0x258)
+/* DMA UDCA head pointer */
+#define USBD_UDCAH(x)		(x + 0x280)
+/* EP DMA status, enable, and disable. This is used to specifically
+   enabled or disable DMA for a specific EP */
+#define USBD_EPDMAST(x)		(x + 0x284)
+#define USBD_EPDMAEN(x)		(x + 0x288)
+#define USBD_EPDMADIS(x)	(x + 0x28C)
+/* DMA master interrupts enable and pending interrupts */
+#define USBD_DMAINTST(x)	(x + 0x290)
+#define USBD_DMAINTEN(x)	(x + 0x294)
+/* DMA end of transfer interrupt enable, disable, status */
+#define USBD_EOTINTST(x)	(x + 0x2A0)
+#define USBD_EOTINTCLR(x)	(x + 0x2A4)
+#define USBD_EOTINTSET(x)	(x + 0x2A8)
+/* New DD request interrupt enable, disable, status */
+#define USBD_NDDRTINTST(x)	(x + 0x2AC)
+#define USBD_NDDRTINTCLR(x)	(x + 0x2B0)
+#define USBD_NDDRTINTSET(x)	(x + 0x2B4)
+/* DMA error interrupt enable, disable, status */
+#define USBD_SYSERRTINTST(x)	(x + 0x2B8)
+#define USBD_SYSERRTINTCLR(x)	(x + 0x2BC)
+#define USBD_SYSERRTINTSET(x)	(x + 0x2C0)
+
+/**********************************************************************
+* USBD_DEVINTST/USBD_DEVINTEN/USBD_DEVINTCLR/USBD_DEVINTSET/
+* USBD_DEVINTPRI register definitions
+**********************************************************************/
+#define USBD_ERR_INT               (1 << 9)
+#define USBD_EP_RLZED              (1 << 8)
+#define USBD_TXENDPKT              (1 << 7)
+#define USBD_RXENDPKT              (1 << 6)
+#define USBD_CDFULL                (1 << 5)
+#define USBD_CCEMPTY               (1 << 4)
+#define USBD_DEV_STAT              (1 << 3)
+#define USBD_EP_SLOW               (1 << 2)
+#define USBD_EP_FAST               (1 << 1)
+#define USBD_FRAME                 (1 << 0)
+
+/**********************************************************************
+* USBD_EPINTST/USBD_EPINTEN/USBD_EPINTCLR/USBD_EPINTSET/
+* USBD_EPINTPRI register definitions
+**********************************************************************/
+/* End point selection macro (RX) */
+#define USBD_RX_EP_SEL(e)          (1 << ((e) << 1))
+
+/* End point selection macro (TX) */
+#define USBD_TX_EP_SEL(e)          (1 << (((e) << 1) + 1))
+
+/**********************************************************************
+* USBD_REEP/USBD_DMARST/USBD_DMARCLR/USBD_DMARSET/USBD_EPDMAST/
+* USBD_EPDMAEN/USBD_EPDMADIS/
+* USBD_NDDRTINTST/USBD_NDDRTINTCLR/USBD_NDDRTINTSET/
+* USBD_EOTINTST/USBD_EOTINTCLR/USBD_EOTINTSET/
+* USBD_SYSERRTINTST/USBD_SYSERRTINTCLR/USBD_SYSERRTINTSET
+* register definitions
+**********************************************************************/
+/* Endpoint selection macro */
+#define USBD_EP_SEL(e)              (1 << (e))
+
+/**********************************************************************
+SBD_DMAINTST/USBD_DMAINTEN
+**********************************************************************/
+#define USBD_SYS_ERR_INT            (1 << 2)
+#define USBD_NEW_DD_INT             (1 << 1)
+#define USBD_EOT_INT                (1 << 0)
+
+/**********************************************************************
+* USBD_RXPLEN register definitions
+**********************************************************************/
+#define USBD_PKT_RDY               (1 << 11)
+#define USBD_DV                    (1 << 10)
+#define USBD_PK_LEN_MASK           0x3FF
+
+/**********************************************************************
+* USBD_CTRL register definitions
+**********************************************************************/
+#define USBD_LOG_ENDPOINT(e)      ((e) << 2)
+#define USBD_WR_EN                (1 << 1)
+#define USBD_RD_EN                (1 << 0)
+
+/**********************************************************************
+* USBD_CMDCODE register definitions
+**********************************************************************/
+#define USBD_CMD_CODE(c)          ((c) << 16)
+#define USBD_CMD_PHASE(p)         ((p) << 8)
+
+/**********************************************************************
+* USBD_DMARST/USBD_DMARCLR/USBD_DMARSET register definitions
+**********************************************************************/
+#define USBD_DMAEP(e)             (1 << (e))
+
+/* DD (DMA Descriptor) structure, requires word alignment */
+struct lpc32xx_usbd_dd
+{
+	u32 *dd_next;
+	u32 dd_setup;
+	u32 dd_buffer_addr;
+	u32 dd_status;
+	u32 dd_iso_ps_mem_addr;
+};
+
+/* dd_setup bit defines */
+#define DD_SETUP_ATLE_DMA_MODE 0x01
+#define DD_SETUP_NEXT_DD_VALID 0x04
+#define DD_SETUP_ISO_EP        0x10
+#define DD_SETUP_PACKETLEN(n)  (((n) & 0x7FF) << 5)
+#define DD_SETUP_DMALENBYTES(n)(((n) & 0xFFFF) << 16)
+
+/* dd_status bit defines */
+#define DD_STATUS_DD_RETIRED   0x01
+#define DD_STATUS_STS_MASK     0x1E
+#define DD_STATUS_STS_NS       0x00 /* Not serviced */
+#define DD_STATUS_STS_BS       0x02 /* Being serviced */
+#define DD_STATUS_STS_NC       0x04 /* Normal completion */
+#define DD_STATUS_STS_DUR      0x06 /* Data underrun (short packet) */
+#define DD_STATUS_STS_DOR      0x08 /* Data overrun */
+#define DD_STATUS_STS_SE       0x12 /* System error */
+#define DD_STATUS_PKT_VAL      0x20 /* Packet valid */
+#define DD_STATUS_LSB_EX       0x40 /* LS byte extracted (ATLE) */
+#define DD_STATUS_MSB_EX       0x80 /* MS byte extracted (ATLE) */
+#define DD_STATUS_MLEN(n)      (((n) >> 8) & 0x3F)
+#define DD_STATUS_CURDMACNT(n) (((n) >> 16) & 0xFFFF)
+
+/*
+ *
+ * Protocol engine bits below
+ *
+ */
+/* Device Interrupt Bit Definitions */
+#define FRAME_INT           0x00000001
+#define EP_FAST_INT         0x00000002
+#define EP_SLOW_INT         0x00000004
+#define DEV_STAT_INT        0x00000008
+#define CCEMTY_INT          0x00000010
+#define CDFULL_INT          0x00000020
+#define RxENDPKT_INT        0x00000040
+#define TxENDPKT_INT        0x00000080
+#define EP_RLZED_INT        0x00000100
+#define ERR_INT             0x00000200
+
+/* Rx & Tx Packet Length Definitions */
+#define PKT_LNGTH_MASK      0x000003FF
+#define PKT_DV              0x00000400
+#define PKT_RDY             0x00000800
+
+/* USB Control Definitions */
+#define CTRL_RD_EN          0x00000001
+#define CTRL_WR_EN          0x00000002
+
+/* Command Codes */
+#define CMD_SET_ADDR        0x00D00500
+#define CMD_CFG_DEV         0x00D80500
+#define CMD_SET_MODE        0x00F30500
+#define CMD_RD_FRAME        0x00F50500
+#define DAT_RD_FRAME        0x00F50200
+#define CMD_RD_TEST         0x00FD0500
+#define DAT_RD_TEST         0x00FD0200
+#define CMD_SET_DEV_STAT    0x00FE0500
+#define CMD_GET_DEV_STAT    0x00FE0500
+#define DAT_GET_DEV_STAT    0x00FE0200
+#define CMD_GET_ERR_CODE    0x00FF0500
+#define DAT_GET_ERR_CODE    0x00FF0200
+#define CMD_RD_ERR_STAT     0x00FB0500
+#define DAT_RD_ERR_STAT     0x00FB0200
+#define DAT_WR_BYTE(x)     (0x00000100 | ((x) << 16))
+#define CMD_SEL_EP(x)      (0x00000500 | ((x) << 16))
+#define DAT_SEL_EP(x)      (0x00000200 | ((x) << 16))
+#define CMD_SEL_EP_CLRI(x) (0x00400500 | ((x) << 16))
+#define DAT_SEL_EP_CLRI(x) (0x00400200 | ((x) << 16))
+#define CMD_SET_EP_STAT(x) (0x00400500 | ((x) << 16))
+#define CMD_CLR_BUF         0x00F20500
+#define DAT_CLR_BUF         0x00F20200
+#define CMD_VALID_BUF       0x00FA0500
+
+/* Device Address Register Definitions */
+#define DEV_ADDR_MASK       0x7F
+#define DEV_EN              0x80
+
+/* Device Configure Register Definitions */
+#define CONF_DVICE          0x01
+
+/* Device Mode Register Definitions */
+#define AP_CLK              0x01
+#define INAK_CI             0x02
+#define INAK_CO             0x04
+#define INAK_II             0x08
+#define INAK_IO             0x10
+#define INAK_BI             0x20
+#define INAK_BO             0x40
+
+/* Device Status Register Definitions */
+#define DEV_CON             0x01
+#define DEV_CON_CH          0x02
+#define DEV_SUS             0x04
+#define DEV_SUS_CH          0x08
+#define DEV_RST             0x10
+
+/* Error Code Register Definitions */
+#define ERR_EC_MASK         0x0F
+#define ERR_EA              0x10
+
+/* Error Status Register Definitions */
+#define ERR_PID             0x01
+#define ERR_UEPKT           0x02
+#define ERR_DCRC            0x04
+#define ERR_TIMOUT          0x08
+#define ERR_EOP             0x10
+#define ERR_B_OVRN          0x20
+#define ERR_BTSTF           0x40
+#define ERR_TGL             0x80
+
+/* Endpoint Select Register Definitions */
+#define EP_SEL_F            0x01
+#define EP_SEL_ST           0x02
+#define EP_SEL_STP          0x04
+#define EP_SEL_PO           0x08
+#define EP_SEL_EPN          0x10
+#define EP_SEL_B_1_FULL     0x20
+#define EP_SEL_B_2_FULL     0x40
+
+/* Endpoint Status Register Definitions */
+#define EP_STAT_ST          0x01
+#define EP_STAT_DA          0x20
+#define EP_STAT_RF_MO       0x40
+#define EP_STAT_CND_ST      0x80
+
+/* Clear Buffer Register Definitions */
+#define CLR_BUF_PO          0x01
+
+/* DMA Interrupt Bit Definitions */
+#define EOT_INT             0x01
+#define NDD_REQ_INT         0x02
+#define SYS_ERR_INT         0x04
+
+
+#endif /* __ASM_ARCH_USBD_H */
diff --git a/arch/arm/mach-lpc32xx/irq.c b/arch/arm/mach-lpc32xx/irq.c
index 4eae566..2a6652b 100644
--- a/arch/arm/mach-lpc32xx/irq.c
+++ b/arch/arm/mach-lpc32xx/irq.c
@@ -16,33 +16,26 @@
  * GNU General Public License for more details.
  */
 
+#ifdef CONFIG_PM_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/pm.h>
+#include <linux/suspend.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/err.h>
 #include <linux/io.h>
+#include <linux/kobject.h>
 
 #include <mach/irqs.h>
 #include <mach/hardware.h>
 #include <mach/platform.h>
 #include "common.h"
 
-/*
- * Default value representing the Activation polarity of all internal
- * interrupt sources
- */
-#define MIC_APR_DEFAULT		0x3FF0EFE0
-#define SIC1_APR_DEFAULT	0xFBD27186
-#define SIC2_APR_DEFAULT	0x801810C0
-
-/*
- * Default value representing the Activation Type of all internal
- * interrupt sources. All are level sensitive.
- */
-#define MIC_ATR_DEFAULT		0x00000000
-#define SIC1_ATR_DEFAULT	0x00026000
-#define SIC2_ATR_DEFAULT	0x00000000
+unsigned int wakeupirq = -1;
 
 struct lpc32xx_event_group_regs {
 	void __iomem *enab_reg;
@@ -70,8 +63,47 @@ struct lpc32xx_event_info {
 	u32 mask;
 };
 
+static const char *lpc32xx_irqname[NR_IRQS] = {
+	[IRQ_LPC32XX_GPI_08] = "GPI_08",
+	[IRQ_LPC32XX_GPI_09] = "GPI_09",
+	[IRQ_LPC32XX_GPI_19] = "GPI_19",
+	[IRQ_LPC32XX_GPI_07] = "GPI_07",
+	[IRQ_LPC32XX_GPI_00] = "GPI_00",
+	[IRQ_LPC32XX_GPI_01] = "GPI_01",
+	[IRQ_LPC32XX_GPI_02] = "GPI_02",
+	[IRQ_LPC32XX_GPI_03] = "GPI_03",
+	[IRQ_LPC32XX_GPI_04] = "GPI_04",
+	[IRQ_LPC32XX_GPI_05] = "GPI_05",
+	[IRQ_LPC32XX_GPI_06] = "GPI_06",
+	[IRQ_LPC32XX_GPI_28] = "GPI_28",
+	[IRQ_LPC32XX_UART_IIR1] = "Uart_1",
+	[IRQ_LPC32XX_UART_IIR2] = "Uart_2",
+	[IRQ_LPC32XX_UART_IIR3] = "Uart_3",
+	[IRQ_LPC32XX_UART_IIR4] = "Uart_4",
+	[IRQ_LPC32XX_UART_IIR5] = "Uart_5",
+	[IRQ_LPC32XX_UART_IIR6] = "Uart_6",
+	[IRQ_LPC32XX_UART_IIR7] = "Uart_7",
+	[IRQ_LPC32XX_GPIO_00] = "GPIO_00",
+	[IRQ_LPC32XX_GPIO_01] = "GPIO_01",
+	[IRQ_LPC32XX_GPIO_02] = "GPIO_02",
+	[IRQ_LPC32XX_GPIO_03] = "GPIO_03",
+	[IRQ_LPC32XX_GPIO_04] = "GPIO_04",
+	[IRQ_LPC32XX_GPIO_05] = "GPIO_05",
+	[IRQ_LPC32XX_ETHERNET]    = "Ethernet",
+	[IRQ_LPC32XX_KEY]         = "Keyboard",
+	[IRQ_LPC32XX_USB_OTG_ATX] = "USB_OTG",
+	[IRQ_LPC32XX_USB_HOST]    = "USB_Host",
+	[IRQ_LPC32XX_RTC]     = "RTC",
+	[IRQ_LPC32XX_MSTIMER] = "MS_Timer",
+	[IRQ_LPC32XX_TS_AUX]  = "TS_AUX",
+	[IRQ_LPC32XX_TS_P]    = "TS_P",
+	[IRQ_LPC32XX_TS_IRQ]  = "TS_IRQ",
+};
+
 /*
  * Maps an IRQ number to and event mask and register
+ * All IRQs are event based wakeup IRQs except the UARTs. The UART RX
+ * wakeup is based on the pin state, not the UART IRQ state.
  */
 static const struct lpc32xx_event_info lpc32xx_events[NR_IRQS] = {
 	[IRQ_LPC32XX_GPI_08] = {
@@ -118,6 +150,39 @@ static const struct lpc32xx_event_info lpc32xx_events[NR_IRQS] = {
 		.event_group = &lpc32xx_event_pin_regs,
 		.mask = LPC32XX_CLKPWR_EXTSRC_GPI_06_BIT,
 	},
+	[IRQ_LPC32XX_GPI_28] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_GPI_28_BIT,
+	},
+  /* UART */
+	[IRQ_LPC32XX_UART_IIR1] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U1_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR2] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U2_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR3] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U3_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR4] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U4_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR5] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U5_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR6] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U6_IRRX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR7] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U7_RX_BIT,
+	},
 	[IRQ_LPC32XX_GPIO_00] = {
 		.event_group = &lpc32xx_event_int_regs,
 		.mask = LPC32XX_CLKPWR_INTSRC_GPIO_00_BIT,
@@ -146,6 +211,10 @@ static const struct lpc32xx_event_info lpc32xx_events[NR_IRQS] = {
 		.event_group = &lpc32xx_event_int_regs,
 		.mask = LPC32XX_CLKPWR_INTSRC_KEY_BIT,
 	},
+	[IRQ_LPC32XX_ETHERNET] = {
+		.event_group = &lpc32xx_event_int_regs,
+		.mask = LPC32XX_CLKPWR_INTSRC_MAC_BIT,
+	},
 	[IRQ_LPC32XX_USB_OTG_ATX] = {
 		.event_group = &lpc32xx_event_int_regs,
 		.mask = LPC32XX_CLKPWR_INTSRC_USBATXINT_BIT,
@@ -289,15 +358,171 @@ static int lpc32xx_set_irq_type(struct irq_data *d, unsigned int type)
 		return -EINVAL;
 	}
 
-	/* Ok to use the level handler for all types */
-	irq_set_handler(d->irq, handle_level_irq);
-
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static u32 backup_irqs[NR_IRQ_CTRLS];
+static u32 wakeup_irqs[NR_IRQ_CTRLS];
+
+static ssize_t wakeup_event_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	if(wakeupirq < 0) {
+		return 0;
+	}
+
+	return sprintf(buf, "%s\n", lpc32xx_irqname[wakeupirq]);
+}
+static struct kobj_attribute wakeup_event_attr =
+			__ATTR(wakeup_event, 0644, wakeup_event_show, NULL);
+#endif
+
+void lpc32xx_irq_suspend(suspend_state_t state)
+{
+#ifdef CONFIG_PM
+	unsigned int i, ctrl, mask;
+
+	for( i=0; i < NR_IRQ_CTRLS; i++) {
+		get_controller((i*32), &ctrl, &mask);
+
+		/* Backup programmed IRQs */
+		backup_irqs[i] = __raw_readl(LPC32XX_INTC_MASK(ctrl));
+
+		/* Disable all interrupts */
+		__raw_writel(0, LPC32XX_INTC_MASK(ctrl));
+
+		if(state == PM_SUSPEND_STANDBY) {
+			pr_debug("Wakeup_irq[%d] = 0x%08X\n", i, wakeup_irqs[i] );
+
+			/* Program interrupts only in standby because of DDR wakeup issues*/
+			__raw_writel( wakeup_irqs[i], LPC32XX_INTC_RAW_STAT(ctrl));
+			__raw_writel( wakeup_irqs[i], LPC32XX_INTC_MASK(ctrl));
+		}
+	}
+
+	if(state == PM_SUSPEND_MEM)	{
+		pr_debug("Start_enable_pin = 0x%X\n",
+				__raw_readl(lpc32xx_event_pin_regs.enab_reg));
+		pr_debug("Start_enable_internal = 0x%X\n",
+				__raw_readl(lpc32xx_event_int_regs.enab_reg));
+	}
+
+	/* Clear Raw Status registers */
+	__raw_writel(LPC32XX_CLKPWR_EXTSRC_MASK,
+			lpc32xx_event_pin_regs.rawstat_reg);
+	__raw_writel(LPC32XX_CLKPWR_INTSRC_MASK,
+			lpc32xx_event_int_regs.rawstat_reg);
+
+	sysfs_remove_file(power_kobj, &wakeup_event_attr.attr);
+#endif
+}
+
+void lpc32xx_irq_resume(suspend_state_t state)
+{
+#ifdef CONFIG_PM
+	unsigned int i, ctrl, mask;
+	unsigned int pinRegMask, intRegMask;
+	unsigned int statusReg = 0;
+
+	pinRegMask = __raw_readl(lpc32xx_event_pin_regs.maskstat_reg);
+	intRegMask = __raw_readl(lpc32xx_event_int_regs.maskstat_reg);
+	pr_debug("Pin Register wakeup mask = 0x%X\n", pinRegMask);
+	pr_debug("Int Register wakeup mask = 0x%X\n", intRegMask);
+
+	/* Scan all lpc32xx_events to find who woke up */
+	for(i=0; i< NR_IRQS; i++) {
+		/* Check IRQ can be defined as wakeup IRQ */
+		if (lpc32xx_events[i].mask != 0) {
+			pr_debug("Scan IRQ %d\n",i);
+			if((lpc32xx_events[i].event_group->enab_reg == lpc32xx_event_pin_regs.enab_reg)
+					&& pinRegMask) {
+				pr_debug("Test mask 0x%X\n",lpc32xx_events[i].mask);
+				if(lpc32xx_events[i].mask == pinRegMask) {
+					wakeupirq = i;
+					break;
+				}
+			}
+
+			if((lpc32xx_events[i].event_group->enab_reg == lpc32xx_event_int_regs.enab_reg)
+					&& intRegMask) {
+				pr_debug("Test mask 0x%X\n",lpc32xx_events[i].mask);
+				if(lpc32xx_events[i].mask == intRegMask) {
+					wakeupirq = i;
+					break;
+				}
+			}
+		}
+	}
+
+	/* Clear Raw Status registers */
+	__raw_writel(LPC32XX_CLKPWR_EXTSRC_MASK,
+			lpc32xx_event_pin_regs.rawstat_reg);
+	__raw_writel(LPC32XX_CLKPWR_INTSRC_MASK,
+			lpc32xx_event_int_regs.rawstat_reg);
+
+	for( i=0; i < NR_IRQ_CTRLS; i++) {
+		get_controller( (i*32), &ctrl, &mask);
+
+		statusReg = __raw_readl(LPC32XX_INTC_STAT(ctrl));
+
+		pr_debug("statusReg %d = 0x%08X\n",i,statusReg);
+
+		/* Disable all interrupts */
+		__raw_writel( 0, LPC32XX_INTC_MASK(ctrl));
+
+		/* Clear Wakeup pending interrupts */
+		__raw_writel(wakeup_irqs[i], LPC32XX_INTC_RAW_STAT(ctrl));
+
+		/* Restore old controller config */
+		__raw_writel(backup_irqs[i], LPC32XX_INTC_MASK(ctrl));
+	}
+
+	if(wakeupirq > 0) {
+		pr_debug("Wakeup source: %s\n", lpc32xx_irqname[wakeupirq]);
+		sysfs_create_file(power_kobj, &wakeup_event_attr.attr);
+	}
+#endif
+}
+
 static int lpc32xx_irq_wake(struct irq_data *d, unsigned int state)
 {
 	unsigned long eventreg;
+	unsigned int ctrl_nr, ctrl, mask;
+
+	if (unlikely(d->irq >= (32 * NR_IRQ_CTRLS))) {
+		return -EINVAL;
+	}
+
+	get_controller(d->irq, &ctrl, &mask);
+	ctrl_nr = d->irq / 32;
+
+#ifdef CONFIG_PM
+	if (state) {
+		pr_debug("Set irq %d as wakeup IRQ\n", d->irq);
+		wakeup_irqs[ctrl_nr] |= mask;
+		if( ctrl_nr == 1 ) {
+			wakeup_irqs[0] |= ( 1<<IRQ_LPC32XX_SUB1IRQ );
+		}
+		if( ctrl_nr == 2 ) {
+			wakeup_irqs[0] |= ( 1<<IRQ_LPC32XX_SUB2IRQ );
+		}
+	}
+	else
+	{
+		pr_debug("Disable wakeup from irq %d \n", d->irq);
+		wakeup_irqs[ctrl_nr] &= ~mask;
+		if( (ctrl_nr == 1) && (wakeup_irqs[1] == 0) )
+			wakeup_irqs[0] &= ~( 1<<IRQ_LPC32XX_SUB1IRQ );
+		if( (ctrl_nr == 2) && (wakeup_irqs[2] == 0) )
+				wakeup_irqs[0] &= ~( 1<<IRQ_LPC32XX_SUB2IRQ );
+	}
+#endif
+
+	if ( lpc32xx_events[d->irq].mask == 0 ) {
+		pr_warning("Can't configure irq %d as wakeup source\n",d->irq);
+		return 0;
+	}
 
 	if (lpc32xx_events[d->irq].mask != 0) {
 		eventreg = __raw_readl(lpc32xx_events[d->irq].
@@ -305,16 +530,24 @@ static int lpc32xx_irq_wake(struct irq_data *d, unsigned int state)
 
 		if (state)
 			eventreg |= lpc32xx_events[d->irq].mask;
-		else
+		else {
 			eventreg &= ~lpc32xx_events[d->irq].mask;
 
+			/*
+			 * When disabling the wakeup, clear the latched
+			 * event
+			 */
+			__raw_writel(lpc32xx_events[d->irq].mask,
+				lpc32xx_events[d->irq].
+				event_group->rawstat_reg);
+		}
+
 		__raw_writel(eventreg,
 			lpc32xx_events[d->irq].event_group->enab_reg);
 
 		return 0;
 	}
 
-	/* Clear event */
 	__raw_writel(lpc32xx_events[d->irq].mask,
 		lpc32xx_events[d->irq].event_group->rawstat_reg);
 
@@ -380,13 +613,13 @@ void __init lpc32xx_init_irq(void)
 
 	/* Setup SIC1 */
 	__raw_writel(0, LPC32XX_INTC_MASK(LPC32XX_SIC1_BASE));
-	__raw_writel(MIC_APR_DEFAULT, LPC32XX_INTC_POLAR(LPC32XX_SIC1_BASE));
-	__raw_writel(MIC_ATR_DEFAULT, LPC32XX_INTC_ACT_TYPE(LPC32XX_SIC1_BASE));
+	__raw_writel(SIC1_APR_DEFAULT, LPC32XX_INTC_POLAR(LPC32XX_SIC1_BASE));
+	__raw_writel(SIC1_ATR_DEFAULT, LPC32XX_INTC_ACT_TYPE(LPC32XX_SIC1_BASE));
 
 	/* Setup SIC2 */
 	__raw_writel(0, LPC32XX_INTC_MASK(LPC32XX_SIC2_BASE));
-	__raw_writel(MIC_APR_DEFAULT, LPC32XX_INTC_POLAR(LPC32XX_SIC2_BASE));
-	__raw_writel(MIC_ATR_DEFAULT, LPC32XX_INTC_ACT_TYPE(LPC32XX_SIC2_BASE));
+	__raw_writel(SIC2_APR_DEFAULT, LPC32XX_INTC_POLAR(LPC32XX_SIC2_BASE));
+	__raw_writel(SIC2_ATR_DEFAULT, LPC32XX_INTC_ACT_TYPE(LPC32XX_SIC2_BASE));
 
 	/* Configure supported IRQ's */
 	for (i = 0; i < NR_IRQS; i++) {
@@ -401,7 +634,9 @@ void __init lpc32xx_init_irq(void)
 	lpc32xx_set_default_mappings(SIC2_APR_DEFAULT, SIC2_ATR_DEFAULT, 64);
 
 	/* mask all interrupts except SUBIRQ */
-	__raw_writel(0, LPC32XX_INTC_MASK(LPC32XX_MIC_BASE));
+	__raw_writel((1 << IRQ_LPC32XX_SUB1IRQ) | (1 << IRQ_LPC32XX_SUB2IRQ) |
+			(1 << IRQ_LPC32XX_SUB1FIQ) | (1 << IRQ_LPC32XX_SUB2FIQ),
+			LPC32XX_INTC_MASK(LPC32XX_MIC_BASE));
 	__raw_writel(0, LPC32XX_INTC_MASK(LPC32XX_SIC1_BASE));
 	__raw_writel(0, LPC32XX_INTC_MASK(LPC32XX_SIC2_BASE));
 
@@ -414,16 +649,6 @@ void __init lpc32xx_init_irq(void)
 	__raw_writel(0, LPC32XX_CLKPWR_INT_ER);
 	__raw_writel(0, LPC32XX_CLKPWR_PIN_ER);
 
-	/*
-	 * Default wake activation polarities, all pin sources are low edge
-	 * triggered
-	 */
-	__raw_writel(LPC32XX_CLKPWR_INTSRC_TS_P_BIT |
-		LPC32XX_CLKPWR_INTSRC_MSTIMER_BIT |
-		LPC32XX_CLKPWR_INTSRC_RTC_BIT,
-		LPC32XX_CLKPWR_INT_AP);
-	__raw_writel(0, LPC32XX_CLKPWR_PIN_AP);
-
 	/* Clear latched wake event states */
 	__raw_writel(__raw_readl(LPC32XX_CLKPWR_PIN_RS),
 		LPC32XX_CLKPWR_PIN_RS);
diff --git a/arch/arm/mach-lpc32xx/phy3250.c b/arch/arm/mach-lpc32xx/phy3250.c
index 7993b09..f7404a0 100644
--- a/arch/arm/mach-lpc32xx/phy3250.c
+++ b/arch/arm/mach-lpc32xx/phy3250.c
@@ -27,9 +27,12 @@
 #include <linux/spi/eeprom.h>
 #include <linux/leds.h>
 #include <linux/gpio.h>
+#include <linux/input.h>
 #include <linux/amba/bus.h>
 #include <linux/amba/clcd.h>
 #include <linux/amba/pl022.h>
+#include <linux/amba/mmci.h>
+#include <sound/uda1380.h>
 
 #include <asm/setup.h>
 #include <asm/mach-types.h>
@@ -37,15 +40,20 @@
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
+#include <mach/board.h>
 #include "common.h"
 
 /*
  * Mapped GPIOLIB GPIOs
  */
-#define SPI0_CS_GPIO	LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
+#define SPI0_CS_GPIO		LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
 #define LCD_POWER_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 0)
 #define BKL_POWER_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 4)
-#define LED_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 1)
+#define LED_GPIO				LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 1)
+#define NAND_WP_GPIO		LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 19)
+#define	MMC_PWR_ENABLE_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 5)
+#define	MMC_CD_GPIO		LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 1)
+#define	MMC_WP_GPIO		LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 0)
 
 /*
  * AMBA LCD controller
@@ -233,7 +241,6 @@ static int __init phy3250_spi_board_register(void)
 			.max_speed_hz = 5000000,
 			.bus_num = 0,
 			.chip_select = 0,
-			.mode = SPI_MODE_0,
 			.platform_data = &eeprom,
 			.controller_data = &spi0_chip_info,
 		},
@@ -243,10 +250,25 @@ static int __init phy3250_spi_board_register(void)
 }
 arch_initcall(phy3250_spi_board_register);
 
+/*
+ * Platform Data for UDA1380 Audiocodec.
+ * As there are no GPIOs for codec power & reset pins,
+ * dummy GPIO numbers are used.
+ */
+static struct uda1380_platform_data uda1380_info = {
+	.gpio_power = LPC32XX_GPIO(LPC32XX_GPO_P3_GRP,10),
+	.gpio_reset = LPC32XX_GPIO(LPC32XX_GPO_P3_GRP,2),
+	.dac_clk    = UDA1380_DAC_CLK_WSPLL,
+};
+
 static struct i2c_board_info __initdata phy3250_i2c_board_info[] = {
 	{
 		I2C_BOARD_INFO("pcf8563", 0x51),
 	},
+	{
+		I2C_BOARD_INFO("uda1380", 0x18),
+		.platform_data = &uda1380_info,
+	},
 };
 
 static struct gpio_led phy_leds[] = {
@@ -269,17 +291,251 @@ static struct platform_device lpc32xx_gpio_led_device = {
 	.dev.platform_data	= &led_data,
 };
 
+/*
+ * Board specific key scanner driver data
+ */
+#define PHY3250_KMATRIX_SIZE 1
+static int lpc32xx_keymaps[] = {
+	KEY_1,  /* 1, 1 */
+};
+
+static struct lpc32XX_kscan_cfg lpc32xx_kscancfg = {
+	.matrix_sz      = PHY3250_KMATRIX_SIZE,
+	.keymap         = lpc32xx_keymaps,
+	/* About a 30Hz scan rate based on a 32KHz clock */
+	.deb_clks       = 3,
+	.scan_delay     = 34,
+};
+
+static struct resource kscan_resources[] = {
+	[0] = {
+		.start  = LPC32XX_KSCAN_BASE,
+		.end    = LPC32XX_KSCAN_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_LPC32XX_KEY,
+		.end    = IRQ_LPC32XX_KEY,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device lpc32xx_kscan_device = {
+	.name           = "lpc32xx_keys",
+	.id             = 0,
+	.dev            = {
+		.platform_data  = &lpc32xx_kscancfg,
+	},
+	.num_resources  = ARRAY_SIZE(kscan_resources),
+	.resource       = kscan_resources,
+};
+
+#if defined (CONFIG_MMC_ARMMMCI)
+static u32 mmc_translate_vdd(struct device *dev, unsigned int vdd,
+		unsigned char mode)
+{
+	/* Only on and off are supported */
+	if (vdd != 0)
+		gpio_set_value(MMC_PWR_ENABLE_GPIO,1);
+	else
+		gpio_set_value(MMC_PWR_ENABLE_GPIO,0);
+
+	return 0;
+}
+
+/*
+ * Board specific MMC driver data
+ */
+struct mmci_platform_data lpc32xx_plat_data = {
+	.ocr_mask       = MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|MMC_VDD_33_34,
+	.vdd_handler	= mmc_translate_vdd,
+	.capabilities   = MMC_CAP_4_BIT_DATA,
+	.gpio_wp        = MMC_WP_GPIO,
+	.gpio_cd        = MMC_CD_GPIO,
+	.cd_invert = true,
+};
+
+/*
+ * SD card controller resources
+ */
+struct amba_device lpc32xx_mmc_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.init_name = "dev:mmc0",
+		.platform_data = &lpc32xx_plat_data,
+	},
+	.res = {
+		.start = LPC32XX_SD_BASE,
+		.end = (LPC32XX_SD_BASE + SZ_4K - 1),
+		.flags = IORESOURCE_MEM,
+	},
+	.dma_mask = ~0,
+	.irq = {IRQ_LPC32XX_SD0, IRQ_LPC32XX_SD1},
+};
+#endif
+
+
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+/*
+ * Board specific NAND setup data
+ */
+static int nandwp_enable(int enable)
+{
+	if (enable != 0)
+		gpio_set_value(NAND_WP_GPIO,0);
+	else
+		gpio_set_value(NAND_WP_GPIO,1);
+
+	return 1;
+}
+
+#define BLK_SIZE (512 * 32)
+static struct mtd_partition phy3250_nand_partition[] = {
+	{
+		.name   = "phy3250-boot",
+		.offset = 0,
+		.size   = (BLK_SIZE * 25)
+	},
+	{
+		.name   = "phy3250-uboot",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = (BLK_SIZE * 100)
+	},
+	{
+		.name   = "phy3250-ubt-prms",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = (BLK_SIZE * 4)
+	},
+	{
+		.name   = "phy3250-kernel",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = (BLK_SIZE * 256)
+	},
+	{
+		.name   = "phy3250-rootfs",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mtd_partition * phy3250_nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(phy3250_nand_partition);
+	return phy3250_nand_partition;
+}
+
+static struct lpc32XX_nand_cfg lpc32xx_nandcfg =
+{
+	.wdr_clks = 14,
+	.wwidth = 40000000,
+	.whold = 100000000,
+	.wsetup = 100000000,
+	.rdr_clks = 14,
+	.rwidth = 40000000,
+	.rhold = 66666666,
+	.rsetup = 100000000,
+	.use_bbt = true,
+	.polled_completion = false,
+	.enable_write_prot = nandwp_enable,
+	.partition_info = phy3250_nand_partitions,
+};
+
+/*
+ * SLC NAND resources
+ */
+static struct resource slc_nand_resources[] = {
+	[0] = {
+		.start  = LPC32XX_SLC_BASE,
+		.end    = LPC32XX_SLC_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_LPC32XX_FLASH,
+		.end    = IRQ_LPC32XX_FLASH,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_slc_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_slc_nand_device = {
+	.name = "lpc32xx-nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &lpc32xx_nandcfg,
+		.dma_mask = &lpc32xx_slc_dma_mask,
+		.coherent_dma_mask = ~0UL,
+	},
+	.num_resources  = ARRAY_SIZE(slc_nand_resources),
+	.resource = slc_nand_resources,
+};
+#endif
+
+/*
+ * Network Support
+ */
+static struct lpc_net_cfg lpc32xx_netdata =
+{
+	.phy_irq        = -1,
+	.phy_mask       = 0xFFFFFFF0,
+};
+
+static struct resource net_resources[] = {
+	[0] = {
+		.start  = LPC32XX_ETHERNET_BASE,
+		.end    = LPC32XX_ETHERNET_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start  = IRQ_LPC32XX_ETHERNET,
+		.end    = IRQ_LPC32XX_ETHERNET,
+		.flags  = IORESOURCE_IRQ,
+	},
+
+};
+
+static u64 lpc32xx_mac_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_net_device = {
+	.name           = "lpc-net",
+	.id             = 0,
+	.dev            = {
+		.dma_mask = &lpc32xx_mac_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data  = &lpc32xx_netdata,
+	},
+	.num_resources  = ARRAY_SIZE(net_resources),
+	.resource       = net_resources,
+};
+
 static struct platform_device *phy3250_devs[] __initdata = {
 	&lpc32xx_i2c0_device,
 	&lpc32xx_i2c1_device,
 	&lpc32xx_i2c2_device,
 	&lpc32xx_watchdog_device,
 	&lpc32xx_gpio_led_device,
+	&lpc32xx_rtc_device,
+	&lpc32xx_tsc_device,
+	&lpc32xx_kscan_device,
+	&lpc32xx_net_device,
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+	&lpc32xx_slc_nand_device,
+#endif
+#if defined(CONFIG_USB_OHCI_HCD)
+	&lpc32xx_ohci_device,
+#endif
+#if defined(CONFIG_USB_GADGET_LPC32XX)
+	&lpc32xx_usbd_device,
+#endif
+	&lpc32xx_i2s_device,
+	&lpc32xx_asoc_plat_device,
 };
 
 static struct amba_device *amba_devs[] __initdata = {
 	&lpc32xx_clcd_device,
 	&lpc32xx_ssp0_device,
+#if defined(CONFIG_MMC_ARMMMCI)
+	&lpc32xx_mmc_device,
+#endif
 };
 
 /*
@@ -300,6 +556,13 @@ static void __init phy3250_board_init(void)
 		printk(KERN_ERR "Error setting gpio %u to output",
 			SPI0_CS_GPIO);
 
+	if (gpio_request(MMC_PWR_ENABLE_GPIO, "mmc_power_en"))
+		printk(KERN_ERR "Error requesting gpio %u",
+				MMC_PWR_ENABLE_GPIO);
+	else if (gpio_direction_output(MMC_PWR_ENABLE_GPIO, 1))
+		printk(KERN_ERR "Error setting gpio %u to output",
+				MMC_PWR_ENABLE_GPIO);
+
 	/* Setup network interface for RMII mode */
 	tmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);
 	tmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;
@@ -341,6 +604,12 @@ static void __init phy3250_board_init(void)
 	 * here. However, we don't want to enable them if the peripheral
 	 * isn't included in the image
 	 */
+#if defined(CONFIG_MMC_ARMMMCI)
+	tmp = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
+	tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_EN | LPC32XX_CLKPWR_MSCARD_MSDIO_PU_EN;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
+#endif
+
 #ifdef CONFIG_FB_ARMCLCD
 	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL);
 	__raw_writel((tmp | LPC32XX_CLKPWR_LCDCTRL_CLK_EN),
@@ -380,6 +649,51 @@ static int __init lpc32xx_display_uid(void)
 }
 arch_initcall(lpc32xx_display_uid);
 
+/*
+ * Example code for setting up the BTN1 button (on GPI3) for system
+ * wakeup and IRQ support. This will allow the GPI3 input to wake
+ * up the system on a low edge. Edge based interrupts won't be
+ * registered in the interrupt controller when the system is asleep,
+ * although they will be registered in the event manager. For this,
+ * reason, a level based interrupt state is recommended for GPIOs when
+ * using IRQ and wakeup from GPI edge state.
+ *
+ */
+#define BTN1_GPIO		LPC32XX_GPIO(LPC32XX_GPI_P3_GRP, 3)
+static irqreturn_t phy3250_btn1_irq(int irq, void *dev)
+{
+	printk(KERN_INFO "GPIO IRQ!\n");
+
+	return IRQ_HANDLED;
+}
+
+static int __init phy3250_button_setup(void)
+{
+	int ret;
+
+	if (gpio_request(BTN1_GPIO, "Button 1")) {
+		printk(KERN_ERR "Error requesting gpio %u", BTN1_GPIO);
+		return 0;
+	}
+
+	/*
+	 * Wakeup/irq on low edge - the wakeup state will use the same
+	 * state as the IRQ edge state.
+	 */
+	irq_set_irq_type(IRQ_LPC32XX_GPI_03, IRQ_TYPE_EDGE_FALLING);
+	ret = request_irq(IRQ_LPC32XX_GPI_03, phy3250_btn1_irq,
+		IRQF_DISABLED, "gpio_btn1_irq", NULL);
+	if (ret < 0) {
+		printk(KERN_ERR "Can't request interrupt\n");
+		return 0;
+	}
+
+	enable_irq_wake(IRQ_LPC32XX_GPI_03);
+
+	return 1;
+}
+device_initcall(phy3250_button_setup);
+
 MACHINE_START(PHY3250, "Phytec 3250 board with the LPC3250 Microcontroller")
 	/* Maintainer: Kevin Wells, NXP Semiconductors */
 	.boot_params	= 0x80000100,
@@ -388,3 +702,13 @@ MACHINE_START(PHY3250, "Phytec 3250 board with the LPC3250 Microcontroller")
 	.timer		= &lpc32xx_timer,
 	.init_machine	= phy3250_board_init,
 MACHINE_END
+
+/* For backwards compatibility with older bootloaders only */
+MACHINE_START(LPC3XXX, "Phytec 3250 board with the LPC3250 Microcontroller")
+	/* Maintainer: Kevin Wells, NXP Semiconductors */
+	.boot_params	= 0x80000100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= phy3250_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index b9c8059..98305d1 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -64,9 +64,11 @@
  *  Suspend mode is exited
  */
 
+#include <linux/pm.h>
 #include <linux/suspend.h>
 #include <linux/io.h>
 #include <linux/slab.h>
+#include <linux/delay.h>
 
 #include <asm/cacheflush.h>
 
@@ -76,25 +78,11 @@
 #include "clock.h"
 
 #define TEMP_IRAM_AREA  IO_ADDRESS(LPC32XX_IRAM_BASE)
+static void *iram_swap_area;
+static int (*lpc32xx_suspend_ptr) (void);
 
-/*
- * Both STANDBY and MEM suspend states are handled the same with no
- * loss of CPU or memory state
- */
-static int lpc32xx_pm_enter(suspend_state_t state)
+static inline int lpc32xx_suspend(void)
 {
-	int (*lpc32xx_suspend_ptr) (void);
-	void *iram_swap_area;
-
-	/* Allocate some space for temporary IRAM storage */
-	iram_swap_area = kmalloc(lpc32xx_sys_suspend_sz, GFP_KERNEL);
-	if (!iram_swap_area) {
-		printk(KERN_ERR
-		       "PM Suspend: cannot allocate memory to save portion "
-			"of SRAM\n");
-		return -ENOMEM;
-	}
-
 	/* Backup a small area of IRAM used for the suspend code */
 	memcpy(iram_swap_area, (void *) TEMP_IRAM_AREA,
 		lpc32xx_sys_suspend_sz);
@@ -106,25 +94,50 @@ static int lpc32xx_pm_enter(suspend_state_t state)
 	 */
 	memcpy((void *) TEMP_IRAM_AREA, &lpc32xx_sys_suspend,
 		lpc32xx_sys_suspend_sz);
+	flush_cache_all();
 	flush_icache_range((unsigned long)TEMP_IRAM_AREA,
 		(unsigned long)(TEMP_IRAM_AREA) + lpc32xx_sys_suspend_sz);
 
 	/* Transfer to suspend code in IRAM */
-	lpc32xx_suspend_ptr = (void *) TEMP_IRAM_AREA;
-	flush_cache_all();
 	(void) lpc32xx_suspend_ptr();
 
 	/* Restore original IRAM contents */
 	memcpy((void *) TEMP_IRAM_AREA, iram_swap_area,
 		lpc32xx_sys_suspend_sz);
 
-	kfree(iram_swap_area);
-
 	return 0;
 }
 
+static int lpc32xx_pm_enter(suspend_state_t state)
+{
+	int ret = 0;
+
+	lpc32xx_irq_suspend(state);
+
+	switch (state)
+	{
+		case PM_SUSPEND_STANDBY:
+			asm("mcr p15, 0, r0, c7, c0, 4");
+			break;
+		case PM_SUSPEND_MEM:
+			ret = lpc32xx_suspend();
+			break;
+	}
+
+	lpc32xx_irq_resume(state);
+
+	return ret;
+}
+
+static int lpc32xx_pm_valid(suspend_state_t state)
+{
+	return (state == PM_SUSPEND_STANDBY) ||
+	       (state == PM_SUSPEND_MEM);
+}
+
+
 static const struct platform_suspend_ops lpc32xx_pm_ops = {
-	.valid	= suspend_valid_only_mem,
+	.valid	= lpc32xx_pm_valid,
 	.enter	= lpc32xx_pm_enter,
 };
 
@@ -134,11 +147,21 @@ static const struct platform_suspend_ops lpc32xx_pm_ops = {
 static int __init lpc32xx_pm_init(void)
 {
 	/*
-	 * Setup SDRAM self-refresh clock to automatically disable o
+	 * Setup SDRAM self-refresh clock to automatically disable on
 	 * start of self-refresh. This only needs to be done once.
 	 */
 	__raw_writel(__raw_readl(EMC_CTRL_REG) | EMC_SRMMC, EMC_CTRL_REG);
 
+	/* Allocate some space for temporary IRAM storage */
+	iram_swap_area = kmalloc(lpc32xx_sys_suspend_sz, GFP_KERNEL);
+	if (!iram_swap_area) {
+		printk(KERN_ERR
+		       "PM Suspend: cannot allocate memory to save portion "
+			"of SRAM\n");
+		return -ENOMEM;
+	}
+
+	lpc32xx_suspend_ptr = (void *) TEMP_IRAM_AREA;
 	suspend_set_ops(&lpc32xx_pm_ops);
 
 	return 0;
diff --git a/arch/arm/mach-lpc32xx/serial.c b/arch/arm/mach-lpc32xx/serial.c
index 429cfdb..7b3fc03 100644
--- a/arch/arm/mach-lpc32xx/serial.c
+++ b/arch/arm/mach-lpc32xx/serial.c
@@ -27,6 +27,7 @@
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
+#include <mach/board.h>
 #include "common.h"
 
 #define LPC32XX_SUART_FIFO_SIZE	64
@@ -38,7 +39,6 @@ static struct plat_serial8250_port serial_std_platform_data[] = {
 		.membase        = io_p2v(LPC32XX_UART5_BASE),
 		.mapbase        = LPC32XX_UART5_BASE,
 		.irq		= IRQ_LPC32XX_UART_IIR5,
-		.uartclk	= LPC32XX_MAIN_OSC_FREQ,
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_BUGGY_UART |
@@ -50,7 +50,6 @@ static struct plat_serial8250_port serial_std_platform_data[] = {
 		.membase	= io_p2v(LPC32XX_UART3_BASE),
 		.mapbase        = LPC32XX_UART3_BASE,
 		.irq		= IRQ_LPC32XX_UART_IIR3,
-		.uartclk	= LPC32XX_MAIN_OSC_FREQ,
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_BUGGY_UART |
@@ -62,7 +61,6 @@ static struct plat_serial8250_port serial_std_platform_data[] = {
 		.membase	= io_p2v(LPC32XX_UART4_BASE),
 		.mapbase        = LPC32XX_UART4_BASE,
 		.irq		= IRQ_LPC32XX_UART_IIR4,
-		.uartclk	= LPC32XX_MAIN_OSC_FREQ,
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_BUGGY_UART |
@@ -74,7 +72,6 @@ static struct plat_serial8250_port serial_std_platform_data[] = {
 		.membase	= io_p2v(LPC32XX_UART6_BASE),
 		.mapbase        = LPC32XX_UART6_BASE,
 		.irq		= IRQ_LPC32XX_UART_IIR6,
-		.uartclk	= LPC32XX_MAIN_OSC_FREQ,
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_BUGGY_UART |
@@ -88,41 +85,51 @@ struct uartinit {
 	char *uart_ck_name;
 	u32 ck_mode_mask;
 	void __iomem *pdiv_clk_reg;
+	resource_size_t mapbase;
+	bool enabled;
 };
 
 static struct uartinit uartinit_data[] __initdata = {
-#ifdef CONFIG_ARCH_LPC32XX_UART5_SELECT
 	{
 		.uart_ck_name = "uart5_ck",
 		.ck_mode_mask =
 			LPC32XX_UART_CLKMODE_LOAD(LPC32XX_UART_CLKMODE_ON, 5),
 		.pdiv_clk_reg = LPC32XX_CLKPWR_UART5_CLK_CTRL,
-	},
+		.mapbase = LPC32XX_UART5_BASE,
+#ifdef CONFIG_ARCH_LPC32XX_UART5_SELECT
+		.enabled = true,
 #endif
-#ifdef CONFIG_ARCH_LPC32XX_UART3_SELECT
+	},
 	{
 		.uart_ck_name = "uart3_ck",
 		.ck_mode_mask =
 			LPC32XX_UART_CLKMODE_LOAD(LPC32XX_UART_CLKMODE_ON, 3),
 		.pdiv_clk_reg = LPC32XX_CLKPWR_UART3_CLK_CTRL,
-	},
+		.mapbase = LPC32XX_UART3_BASE,
+#ifdef CONFIG_ARCH_LPC32XX_UART3_SELECT
+		.enabled = true,
 #endif
-#ifdef CONFIG_ARCH_LPC32XX_UART4_SELECT
+	},
 	{
 		.uart_ck_name = "uart4_ck",
 		.ck_mode_mask =
 			LPC32XX_UART_CLKMODE_LOAD(LPC32XX_UART_CLKMODE_ON, 4),
 		.pdiv_clk_reg = LPC32XX_CLKPWR_UART4_CLK_CTRL,
-	},
+		.mapbase = LPC32XX_UART4_BASE,
+#ifdef CONFIG_ARCH_LPC32XX_UART4_SELECT
+		.enabled = true,
 #endif
-#ifdef CONFIG_ARCH_LPC32XX_UART6_SELECT
+	},
 	{
 		.uart_ck_name = "uart6_ck",
 		.ck_mode_mask =
 			LPC32XX_UART_CLKMODE_LOAD(LPC32XX_UART_CLKMODE_ON, 6),
 		.pdiv_clk_reg = LPC32XX_CLKPWR_UART6_CLK_CTRL,
-	},
+		.mapbase = LPC32XX_UART6_BASE,
+#ifdef CONFIG_ARCH_LPC32XX_UART6_SELECT
+		.enabled = true,
 #endif
+	},
 };
 
 static struct platform_device serial_std_platform_device = {
@@ -133,51 +140,147 @@ static struct platform_device serial_std_platform_device = {
 	},
 };
 
+/* High speed serial ports */
+static struct lpc32xx_hsuart_port serial_hspd_platform_data[] = {
+#ifdef CONFIG_ARCH_LPC32XX_HSUART1_SELECT
+	{
+		.port 					= {
+			.membase        = io_p2v(LPC32XX_HS_UART1_BASE),
+			.mapbase        = LPC32XX_HS_UART1_BASE,
+			.irq            = IRQ_LPC32XX_UART_IIR1,
+			.regshift       = 2,
+			.iotype         = UPIO_MEM32,
+			.flags          = UPF_BOOT_AUTOCONF,
+		},
+		.fbit_sam       = 20,
+	},
+#endif
+#ifdef CONFIG_ARCH_LPC32XX_HSUART2_SELECT
+	{
+		.port 					= {
+			.membase        = io_p2v(LPC32XX_HS_UART2_BASE),
+			.mapbase        = LPC32XX_HS_UART2_BASE,
+			.irq            = IRQ_LPC32XX_UART_IIR2,
+			.regshift       = 2,
+			.iotype         = UPIO_MEM32,
+			.flags          = UPF_BOOT_AUTOCONF,
+		},
+		.fbit_sam       = 20,
+	},
+#endif
+#ifdef CONFIG_ARCH_LPC32XX_HSUART7_SELECT
+	{
+		.port 					= {
+			.membase        = io_p2v(LPC32XX_HS_UART7_BASE),
+			.mapbase        = LPC32XX_HS_UART7_BASE,
+			.irq            = IRQ_LPC32XX_UART_IIR7,
+			.regshift       = 2,
+			.iotype         = UPIO_MEM32,
+			.flags          = UPF_BOOT_AUTOCONF,
+		},
+		.fbit_sam       = 20,
+	},
+#endif
+	{ },
+};
+
+static struct platform_device serial_hspd_platform_device = {
+	.name                   = "lpc32xx_hsuart",
+	.id                     = 0,
+	.dev                    = {
+		.platform_data  = serial_hspd_platform_data,
+	},
+};
+
 static struct platform_device *lpc32xx_serial_devs[] __initdata = {
 	&serial_std_platform_device,
+	&serial_hspd_platform_device,
 };
 
 void __init lpc32xx_serial_init(void)
 {
-	u32 tmp, clkmodes = 0;
+	u32 tmp, tmpclk, clkmodes = 0, clkmodesdone = 0;
 	struct clk *clk;
-	unsigned int puart;
-	int i, j;
-
-	/* UART clocks are off, let clock driver manage them */
-	__raw_writel(0, LPC32XX_CLKPWR_UART_CLK_CTRL);
+	resource_size_t puart;
+	int i, j, k = 0;
 
+	/*
+	 * For each standard UART, enable the UART clock, and force
+	 * FIFO flush. This works around a HW bug with the 8250 where
+	 * the FIFOs may not work correctly. This should be done even if
+	 * the standard UARTs are not used. The clocks will be disabled
+	 * when done.
+	 */
 	for (i = 0; i < ARRAY_SIZE(uartinit_data); i++) {
 		clk = clk_get(NULL, uartinit_data[i].uart_ck_name);
 		if (!IS_ERR(clk)) {
 			clk_enable(clk);
-			serial_std_platform_data[i].uartclk =
-				clk_get_rate(clk);
-		}
+			tmpclk = clk_get_rate(clk);
+
+			/*
+			 * Fall back on main osc rate if clock rate return
+			 * fails
+			 */
+			if (tmpclk == 0)
+				tmpclk = LPC32XX_MAIN_OSC_FREQ;
+
+			/* pre-UART clock divider set to 1 */
+			__raw_writel(0x0101, uartinit_data[i].pdiv_clk_reg);
 
-		/* Fall back on main osc rate if clock rate return fails */
-		if (serial_std_platform_data[i].uartclk == 0)
-			serial_std_platform_data[i].uartclk =
-				LPC32XX_MAIN_OSC_FREQ;
+			/* Setup UART clock modes for all UART to always on */
+			clkmodes = uartinit_data[i].ck_mode_mask;
+			__raw_writel(clkmodes, LPC32XX_UARTCTL_CLKMODE);
+
+			/*
+			 * Force a flush of the RX FIFOs to work around a
+			 * HW bug
+			 */
+			puart = uartinit_data[i].mapbase;
+			__raw_writel(0xC1, LPC32XX_UART_IIR_FCR(puart));
+			__raw_writel(0x00, LPC32XX_UART_DLL_FIFO(puart));
+			j = LPC32XX_SUART_FIFO_SIZE;
+			while (j--)
+				tmp = __raw_readl(
+					LPC32XX_UART_DLL_FIFO(puart));
+			__raw_writel(0, LPC32XX_UART_IIR_FCR(puart));
+
+			/*
+			 * The 8250 serial drivers do not use any type of
+			 * clock management, so the clocks need to be
+			 * pre-enabled here before the 8250 driver attempts
+			 * to access the peripherals. If a UART is enabled,
+			 * just leave the clock on.
+			 */
+			if (uartinit_data[i].enabled) {
+				clkmodesdone |= clkmodes;
+				serial_std_platform_data[k++].uartclk = tmpclk;
+			} else {
+				clk_disable(clk);
+				clk_put(clk);
+			}
+		}
+	}
 
-		/* Setup UART clock modes for all UARTs, disable autoclock */
-		clkmodes |= uartinit_data[i].ck_mode_mask;
+	/* Enable clocks only for enabled UARTs */
+	__raw_writel(clkmodesdone, LPC32XX_UARTCTL_CLKMODE);
 
-		/* pre-UART clock divider set to 1 */
-		__raw_writel(0x0101, uartinit_data[i].pdiv_clk_reg);
+	/*
+	 * Get current PCLK rate and use it for the base clock for all the
+	 * high speed UARTS
+	 */
+	tmpclk = 0;
+	clk = clk_get(NULL, "pclk_ck");
+	if (!IS_ERR(clk)) {
+		tmpclk = clk_get_rate(clk);
+		clk_put(clk);
 	}
+	if (!tmpclk)
+		tmpclk = LPC32XX_MAIN_OSC_FREQ;
 
-	/* This needs to be done after all UART clocks are setup */
-	__raw_writel(clkmodes, LPC32XX_UARTCTL_CLKMODE);
-	for (i = 0; i < ARRAY_SIZE(uartinit_data) - 1; i++) {
-		/* Force a flush of the RX FIFOs to work around a HW bug */
-		puart = serial_std_platform_data[i].mapbase;
-		__raw_writel(0xC1, LPC32XX_UART_IIR_FCR(puart));
-		__raw_writel(0x00, LPC32XX_UART_DLL_FIFO(puart));
-		j = LPC32XX_SUART_FIFO_SIZE;
-		while (j--)
-			tmp = __raw_readl(LPC32XX_UART_DLL_FIFO(puart));
-		__raw_writel(0, LPC32XX_UART_IIR_FCR(puart));
+        /* Setup of HSUART devices */
+        for (i = 0; i < ARRAY_SIZE(serial_hspd_platform_data) - 1; i++) {
+                serial_hspd_platform_data[i].port.line = i;
+                serial_hspd_platform_data[i].port.uartclk = tmpclk;
 	}
 
 	/* Disable UART5->USB transparent mode or USB won't work */
diff --git a/arch/arm/mach-lpc32xx/suspend.S b/arch/arm/mach-lpc32xx/suspend.S
index 374f9f0..757fd00 100644
--- a/arch/arm/mach-lpc32xx/suspend.S
+++ b/arch/arm/mach-lpc32xx/suspend.S
@@ -32,7 +32,8 @@
 #define LPC32XX_CLKPWR_HCLK_DIV_OFFS	0x40
 #define LPC32XX_CLKPWR_HCLKPLL_CTRL_OFFS 0x58
 
-#define CLKPWR_PCLK_DIV_MASK		0xFFFFFE7F
+#define CLKPWR_PCLK_DIV_MASK1		0xFFFFFF83
+#define CLKPWR_PCLK_DIV_MASK2		0xFFFFFE03
 
 	.text
 
@@ -78,15 +79,19 @@ ENTRY(lpc32xx_sys_suspend)
 	cmp	WORK2_REG, #LPC32XX_EMC_STATUS_SELF_RFSH
 	bne	3b @ Branch until self-refresh mode starts
 
+	@ Set PCLK divider to 1 prior to direct-run mode entry
+	ldr	SAVED_HCLK_DIV_REG, [CLKPWRBASE_REG,\
+		#LPC32XX_CLKPWR_HCLK_DIV_OFFS]
+	and	WORK2_REG, SAVED_HCLK_DIV_REG, #CLKPWR_PCLK_DIV_MASK1
+	str	WORK2_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_HCLK_DIV_OFFS]
+
 	@ Enter direct-run mode from run mode
 	bic	WORK1_REG, WORK1_REG, #LPC32XX_CLKPWR_SELECT_RUN_MODE
 	str	WORK1_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_PWR_CTRL_OFFS]
 
 	@ Safe disable of DRAM clock in EMC block, prevents DDR sync
 	@ issues on restart
-	ldr	SAVED_HCLK_DIV_REG, [CLKPWRBASE_REG,\
-		#LPC32XX_CLKPWR_HCLK_DIV_OFFS]
-	and	WORK2_REG, SAVED_HCLK_DIV_REG, #CLKPWR_PCLK_DIV_MASK
+	and	WORK2_REG, SAVED_HCLK_DIV_REG, #CLKPWR_PCLK_DIV_MASK2
 	str	WORK2_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_HCLK_DIV_OFFS]
 
 	@ Save HCLK PLL state and disable HCLK PLL
@@ -98,20 +103,22 @@ ENTRY(lpc32xx_sys_suspend)
 	@ Enter stop mode until an enabled event occurs
 	orr	WORK1_REG, WORK1_REG, #LPC32XX_CLKPWR_STOP_MODE_CTRL
 	str	WORK1_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_PWR_CTRL_OFFS]
+
 	.rept 9
 	nop
 	.endr
 
-	@ Clear stop status
+	@ Clear stop status now
 	bic	WORK1_REG, WORK1_REG, #LPC32XX_CLKPWR_STOP_MODE_CTRL
+	str	WORK1_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_PWR_CTRL_OFFS]
 
 	@ Restore original HCLK PLL value and wait for PLL lock
 	str	SAVED_HCLK_PLL_REG, [CLKPWRBASE_REG,\
 		#LPC32XX_CLKPWR_HCLKPLL_CTRL_OFFS]
 4:
 	ldr	WORK2_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_HCLKPLL_CTRL_OFFS]
-	and	WORK2_REG, WORK2_REG, #LPC32XX_CLKPWR_HCLKPLL_PLL_STS
-	bne	4b
+	ands WORK2_REG, WORK2_REG, #LPC32XX_CLKPWR_HCLKPLL_PLL_STS
+	beq 4b
 
 	@ Re-enter run mode with self-refresh flag cleared, but no DRAM
 	@ update yet. DRAM is still in self-refresh
@@ -132,8 +139,8 @@ ENTRY(lpc32xx_sys_suspend)
 	@ Wait for EMC to clear self-refresh mode
 5:
 	ldr	WORK2_REG, [EMCBASE_REG, #LPC32XX_EMC_STATUS_OFFS]
-	and	WORK2_REG, WORK2_REG, #LPC32XX_EMC_STATUS_SELF_RFSH
-	bne	5b @ Branch until self-refresh has exited
+	ands WORK2_REG, WORK2_REG, #LPC32XX_EMC_STATUS_SELF_RFSH
+	bne 5b @ Branch until self-refresh has exited
 
 	@ restore regs and return
 	adr	r0, tmp_stack
diff --git a/arch/arm/mach-lpc32xx/timer.c b/arch/arm/mach-lpc32xx/timer.c
index 6162ac3..88f24a2 100644
--- a/arch/arm/mach-lpc32xx/timer.c
+++ b/arch/arm/mach-lpc32xx/timer.c
@@ -33,7 +33,7 @@
 
 static cycle_t lpc32xx_clksrc_read(struct clocksource *cs)
 {
-	return (cycle_t)__raw_readl(LCP32XX_TIMER_TC(LPC32XX_TIMER1_BASE));
+	return (cycle_t)__raw_readl(LPC32XX_TIMER_TC(LPC32XX_TIMER1_BASE));
 }
 
 static struct clocksource lpc32xx_clksrc = {
@@ -47,11 +47,11 @@ static struct clocksource lpc32xx_clksrc = {
 static int lpc32xx_clkevt_next_event(unsigned long delta,
     struct clock_event_device *dev)
 {
-	__raw_writel(LCP32XX_TIMER_CNTR_TCR_RESET,
-		LCP32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
-	__raw_writel(delta, LCP32XX_TIMER_PR(LPC32XX_TIMER0_BASE));
-	__raw_writel(LCP32XX_TIMER_CNTR_TCR_EN,
-		LCP32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_TCR_RESET,
+		LPC32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
+	__raw_writel(delta, LPC32XX_TIMER_PR(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_TCR_EN,
+		LPC32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
 
 	return 0;
 }
@@ -71,7 +71,7 @@ static void lpc32xx_clkevt_mode(enum clock_event_mode mode,
 		 * disable the timer to wait for the first call to
 		 * set_next_event().
 		 */
-		__raw_writel(0, LCP32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
+		__raw_writel(0, LPC32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
 		break;
 
 	case CLOCK_EVT_MODE_UNUSED:
@@ -94,8 +94,8 @@ static irqreturn_t lpc32xx_timer_interrupt(int irq, void *dev_id)
 	struct clock_event_device *evt = &lpc32xx_clkevt;
 
 	/* Clear match */
-	__raw_writel(LCP32XX_TIMER_CNTR_MTCH_BIT(0),
-		LCP32XX_TIMER_IR(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_MTCH_BIT(0),
+		LPC32XX_TIMER_IR(LPC32XX_TIMER0_BASE));
 
 	evt->event_handler(evt);
 
@@ -141,14 +141,14 @@ static void __init lpc32xx_timer_init(void)
 	clkrate = clkrate / clk_get_pclk_div();
 
 	/* Initial timer setup */
-	__raw_writel(0, LCP32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
-	__raw_writel(LCP32XX_TIMER_CNTR_MTCH_BIT(0),
-		LCP32XX_TIMER_IR(LPC32XX_TIMER0_BASE));
-	__raw_writel(1, LCP32XX_TIMER_MR0(LPC32XX_TIMER0_BASE));
-	__raw_writel(LCP32XX_TIMER_CNTR_MCR_MTCH(0) |
-		LCP32XX_TIMER_CNTR_MCR_STOP(0) |
-		LCP32XX_TIMER_CNTR_MCR_RESET(0),
-		LCP32XX_TIMER_MCR(LPC32XX_TIMER0_BASE));
+	__raw_writel(0, LPC32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_MTCH_BIT(0),
+		LPC32XX_TIMER_IR(LPC32XX_TIMER0_BASE));
+	__raw_writel(1, LPC32XX_TIMER_MR0(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_MCR_MTCH(0) |
+		LPC32XX_TIMER_CNTR_MCR_STOP(0) |
+		LPC32XX_TIMER_CNTR_MCR_RESET(0),
+		LPC32XX_TIMER_MCR(LPC32XX_TIMER0_BASE));
 
 	/* Setup tick interrupt */
 	setup_irq(IRQ_LPC32XX_TIMER0, &lpc32xx_timer_irq);
@@ -164,12 +164,12 @@ static void __init lpc32xx_timer_init(void)
 	clockevents_register_device(&lpc32xx_clkevt);
 
 	/* Use timer1 as clock source. */
-	__raw_writel(LCP32XX_TIMER_CNTR_TCR_RESET,
-		LCP32XX_TIMER_TCR(LPC32XX_TIMER1_BASE));
-	__raw_writel(0, LCP32XX_TIMER_PR(LPC32XX_TIMER1_BASE));
-	__raw_writel(0, LCP32XX_TIMER_MCR(LPC32XX_TIMER1_BASE));
-	__raw_writel(LCP32XX_TIMER_CNTR_TCR_EN,
-		LCP32XX_TIMER_TCR(LPC32XX_TIMER1_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_TCR_RESET,
+		LPC32XX_TIMER_TCR(LPC32XX_TIMER1_BASE));
+	__raw_writel(0, LPC32XX_TIMER_PR(LPC32XX_TIMER1_BASE));
+	__raw_writel(0, LPC32XX_TIMER_MCR(LPC32XX_TIMER1_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_TCR_EN,
+		LPC32XX_TIMER_TCR(LPC32XX_TIMER1_BASE));
 	clocksource_register_hz(&lpc32xx_clksrc, clkrate);
 }
 
diff --git a/arch/arm/tools/mach-types b/arch/arm/tools/mach-types
index 7ca41f0..f7d9c9e 100644
--- a/arch/arm/tools/mach-types
+++ b/arch/arm/tools/mach-types
@@ -150,6 +150,7 @@ colibri			MACH_COLIBRI		COLIBRI			729
 gateway7001		MACH_GATEWAY7001	GATEWAY7001		731
 pcm027			MACH_PCM027		PCM027			732
 anubis			MACH_ANUBIS		ANUBIS			734
+lpc3xxx			MACH_LPC3XXX		LPC3XXX			736
 akita			MACH_AKITA		AKITA			744
 e330			MACH_E330		E330			753
 nokia770		MACH_NOKIA770		NOKIA770		755
@@ -428,6 +429,8 @@ g4evm			MACH_G4EVM		G4EVM			2493
 omapl138_hawkboard	MACH_OMAPL138_HAWKBOARD	OMAPL138_HAWKBOARD	2495
 ts41x			MACH_TS41X		TS41X			2502
 phy3250			MACH_PHY3250		PHY3250			2511
+ea3250			MACH_EA3250		EA3250			2512
+fdi3250			MACH_FDI3250		FDI3250			2513
 mini6410		MACH_MINI6410		MINI6410		2520
 mx28evk			MACH_MX28EVK		MX28EVK			2531
 smartq5			MACH_SMARTQ5		SMARTQ5			2534
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index f746950..f2dbc62 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -422,8 +422,12 @@ static int vfp_pm_suspend(struct sys_device *dev, pm_message_t state)
 
 static int vfp_pm_resume(struct sys_device *dev)
 {
+	unsigned int cpu_arch = cpu_architecture();
+
 	/* ensure we have access to the vfp */
-	vfp_enable(NULL);
+	if (cpu_arch >= CPU_ARCH_ARMv6) {
+		vfp_enable(NULL);
+	}
 
 	/* and disable it to ensure the next usage restores the state */
 	fmxr(FPEXC, fmrx(FPEXC) & ~FPEXC_EN);
diff --git a/drivers/i2c/busses/i2c-pnx.c b/drivers/i2c/busses/i2c-pnx.c
index 04be9f8..e534c8d 100644
--- a/drivers/i2c/busses/i2c-pnx.c
+++ b/drivers/i2c/busses/i2c-pnx.c
@@ -27,7 +27,7 @@
 #include <mach/hardware.h>
 #include <mach/i2c.h>
 
-#define I2C_PNX_TIMEOUT		10 /* msec */
+#define I2C_PNX_TIMEOUT		100 /* msec */
 #define I2C_PNX_SPEED_KHZ	100
 #define I2C_PNX_REGION_SIZE	0x100
 
@@ -305,11 +305,152 @@ static int i2c_pnx_master_rcv(struct i2c_pnx_algo_data *alg_data)
 	return 0;
 }
 
+/* SMBus receive handler, called from ISR */
+static int i2c_pnx_smbus_rx(struct i2c_pnx_algo_data *smbus)
+{
+	struct i2c_pnx_smbus *smb = &smbus->smb;
+	while (!(ioread32(I2C_REG_STS(smbus)) & mstatus_rfe)) {
+		smb->rx_buf[smb->rx_cnt++] =
+			(u8) ioread32(I2C_REG_RX(smbus));
+		dev_dbg(&smbus->adapter.dev, "Rx Char: %02x\n",
+				smb->rx_buf[smb->rx_cnt - 1]);
+
+		/* If Rx char is not length then continue receiving */
+		if ((smb->rx_cnt != 1) ||
+			!(smb->flags & I2C_PNX_SMBUS_BLOCK_RX))
+			continue;
+
+		/* If Received char is length, check for validity */
+		if (unlikely(smb->rx_buf[0] <= 0 &&
+			smb->rx_buf[0] > smb->max_rx_len)) {
+			dev_dbg(&smbus->adapter.dev, "ERR: SMBus received "
+					"invalid transfer length %d from slave"
+					" %#02x during a block transfer.\n",
+					smb->rx_buf[0],
+					smb->slave_addr);
+			smb->ret = -EIO;
+			complete(&smb->complete);
+			smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+			return 1;
+		}
+
+		/* There is a hardware BUG, that makes receiving
+		 * only length not possible, so we receive length
+		 * and a byte of data, if that is the only byte to
+		 * be received the the transfer must stop right away
+		 **/
+		if (smb->rx_buf[0] == 1) {
+			/* Stop xfer right away */
+			iowrite32(stop_bit, I2C_REG_TX(smbus));
+			iowrite32(ioread32(I2C_REG_CTL(smbus)) &
+					~(mcntrl_drmie | mcntrl_tffie),
+					I2C_REG_CTL(smbus));
+			return 1;
+		}
+
+		dev_dbg(&smbus->adapter.dev, "Set Len:%d\n",
+				smb->rx_buf[0]);
+		smb->len += smb->rx_buf[0] - 1;
+		smb->tx_buf[smb->len - 1] |= stop_bit;
+		iowrite32(ioread32(I2C_REG_CTL(smbus)) |
+				  mcntrl_tffie, I2C_REG_CTL(smbus));
+	}
+	return 0;
+}
+
+/* SMBUs interrupt handler */
+static irqreturn_t i2c_pnx_smbus_isr(int irq, void *dev_id)
+{
+	struct i2c_pnx_algo_data *smbus = dev_id;
+	struct i2c_pnx_smbus *smb = &smbus->smb;
+	u32 stat, ctl;
+	stat = ioread32(I2C_REG_STS(smbus));
+	ctl = ioread32(I2C_REG_CTL(smbus));
+
+	dev_dbg(&smbus->adapter.dev, "ISR: stat = %#08x, "
+			"ctrl = %#08x\r\n", stat, ctl);
+
+	/* Handle Rx data */
+	if (((stat & mstatus_rff) && (ctl & mcntrl_rffie)) ||
+	    (!(stat & mstatus_rfe) && (ctl & mcntrl_daie))) {
+		if (i2c_pnx_smbus_rx(smbus))
+			return IRQ_HANDLED;
+		stat = ioread32(I2C_REG_STS(smbus));
+		ctl = ioread32(I2C_REG_CTL(smbus));
+	}
+
+	/* Handle Transmit */
+	if (((stat & mstatus_drmi) && (ctl & mcntrl_drmie)) ||
+	    (!(stat & mstatus_rff) && (ctl & mcntrl_tffie))) {
+
+		/* Push data into FIFO until we run out of data
+		 * or TX/RX fifo is full
+		 **/
+		for (; (smb->index < smb->len) &&
+		     !(ioread32(I2C_REG_STS(smbus)) &
+				 (mstatus_tff | mstatus_rff));
+		     smb->index++) {
+			iowrite32(smb->tx_buf[smb->index], I2C_REG_TX(smbus));
+			dev_dbg(&smbus->adapter.dev, "Tx Char: %03x\n",
+					smb->tx_buf[smb->index]);
+		}
+
+		/* Stop further transmit if we run out of data */
+		if (smb->index >= smb->len) {
+			iowrite32(ctl & ~(mcntrl_drmie | mcntrl_tffie),
+					I2C_REG_CTL(smbus));
+		}
+		return IRQ_HANDLED;
+	}
+
+	/* Handle Arbitration loss */
+	if (unlikely((stat & mstatus_afi) && (ctl & mcntrl_afie))) {
+		dev_dbg(&smbus->adapter.dev, "Aribitration lost during"
+				" transfer to/from slave addr %02x\r\n",
+				smb->slave_addr);
+		smb->ret = -EAGAIN;
+		complete(&smb->complete);
+		smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+		/* We are done! */
+		iowrite32(0, I2C_REG_CTL(smbus));
+		return IRQ_HANDLED;
+	}
+
+	/* Handle NACK reception */
+	if (unlikely((stat & mstatus_nai) && (ctl & mcntrl_naie))) {
+		dev_dbg(&smbus->adapter.dev, "Nack received!\n");
+		smb->ret = -EIO;
+		complete(&smb->complete);
+		smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+		/* We are done! */
+		iowrite32(0, I2C_REG_CTL(smbus));
+		return IRQ_HANDLED;
+	}
+
+	/* Handle Xfer Done */
+	if ((stat & mstatus_tdi) &&
+	    (mcntrl_tdie & ctl)) {
+		dev_dbg(&smbus->adapter.dev, "SMBus Xfer Done!\r\n");
+		/* Transmission is done */
+		smb->ret = 0;
+		complete(&smb->complete);
+		iowrite32(mstatus_tdi, I2C_REG_STS(smbus));
+		iowrite32(0, I2C_REG_CTL(smbus));
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_HANDLED;
+}
+
 static irqreturn_t i2c_pnx_interrupt(int irq, void *dev_id)
 {
 	struct i2c_pnx_algo_data *alg_data = dev_id;
 	u32 stat, ctl;
 
+	/* If it is an SMBUS xfer let another handler do the task */
+	if (alg_data->smb.flags & I2C_PNX_SMBUS_ACTIVE)
+		return i2c_pnx_smbus_isr(irq, dev_id);
+
 	dev_dbg(&alg_data->adapter.dev,
 		"%s(): mstat = %x mctrl = %x, mode = %d\n",
 		__func__,
@@ -430,7 +571,7 @@ static inline void bus_reset_if_active(struct i2c_pnx_algo_data *alg_data)
 }
 
 /**
- * i2c_pnx_xfer - generic transfer entry point
+ * i2c_pnx_xfer - I2C Protocol Transfer routine
  * @adap:		pointer to I2C adapter structure
  * @msgs:		array of messages
  * @num:		number of messages
@@ -443,11 +584,15 @@ i2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	struct i2c_msg *pmsg;
 	int rc = 0, completed = 0, i;
 	struct i2c_pnx_algo_data *alg_data = adap->algo_data;
-	u32 stat = ioread32(I2C_REG_STS(alg_data));
+	u32 stat;
+
+	clk_enable(alg_data->clk);
+
+	stat = ioread32(I2C_REG_STS(alg_data));
 
 	dev_dbg(&alg_data->adapter.dev,
 		"%s(): entering: %d messages, stat = %04x.\n",
-		__func__, num, ioread32(I2C_REG_STS(alg_data)));
+		__func__, num, stat);
 
 	bus_reset_if_active(alg_data);
 
@@ -463,6 +608,7 @@ i2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 				"%s: 10 bits addr not supported!\n",
 				alg_data->adapter.name);
 			rc = -EINVAL;
+			clk_disable(alg_data->clk);
 			break;
 		}
 
@@ -524,44 +670,276 @@ i2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	dev_dbg(&alg_data->adapter.dev, "%s(): exiting, stat = %x\n",
 		__func__, ioread32(I2C_REG_STS(alg_data)));
 
+	clk_disable(alg_data->clk);
+
 	if (completed != num)
 		return ((rc < 0) ? rc : -EREMOTEIO);
 
 	return num;
 }
 
-static u32 i2c_pnx_func(struct i2c_adapter *adapter)
+/* Checks for the state of I2C BUS */
+static int i2c_pnx_smbus_check(struct i2c_pnx_algo_data *smbus)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
-}
+	u32 stat;
+	int need_reset;
 
-static struct i2c_algorithm pnx_algorithm = {
-	.master_xfer = i2c_pnx_xfer,
-	.functionality = i2c_pnx_func,
-};
+	stat = ioread32(I2C_REG_STS(smbus));
 
-#ifdef CONFIG_PM
-static int i2c_pnx_controller_suspend(struct platform_device *pdev,
-				      pm_message_t state)
-{
-	struct i2c_pnx_algo_data *alg_data = platform_get_drvdata(pdev);
+	/* Reset if bus is still active or a NACK from prev xfer pending */
+	need_reset = stat & (mstatus_active | mstatus_nai);
 
-	/* FIXME: shouldn't this be clk_disable? */
-	clk_enable(alg_data->clk);
+	/* Reset if TXFIFO or RXFIFO is not empty */
+	need_reset |= ~stat & (mstatus_rfe | mstatus_tfe);
+
+	if (unlikely(need_reset)) {
+		dev_dbg(&smbus->adapter.dev, "SMBus is not in idle state"
+				" before transfer, resetting it...\r\n");
+		iowrite32(ioread32(I2C_REG_CTL(smbus)) | mcntrl_reset,
+			  I2C_REG_CTL(smbus));
+		wait_reset(I2C_PNX_TIMEOUT, smbus);
+	}
+
+	stat = ioread32(I2C_REG_STS(smbus));
+
+	/* if the bus is still busy ask i2c-core to retry after sometime */
+	if (stat & mstatus_active) {
+		dev_dbg(&smbus->adapter.dev, "SMBus is still active!\r\n");
+		return -EAGAIN;
+	}
 
 	return 0;
 }
 
-static int i2c_pnx_controller_resume(struct platform_device *pdev)
+/* Initialize SMBus structure */
+static void i2c_pnx_smbus_init(struct i2c_pnx_algo_data *smbus)
 {
-	struct i2c_pnx_algo_data *alg_data = platform_get_drvdata(pdev);
+	struct i2c_pnx_smbus *smb = &smbus->smb;
+	smb->index = 0;
+	smb->ret = 0;
+	smb->flags = I2C_PNX_SMBUS_ACTIVE;
+	smb->len = 0;
+	smb->rx_cnt = 0;
+	iowrite32(mstatus_tdi, I2C_REG_STS(smbus));
+	init_completion(&smb->complete);
+}
 
-	return clk_enable(alg_data->clk);
+static void i2c_pnx_fill_buffer(u16 *to, u8 *from, int cnt)
+{
+	int i;
+	for (i = 0; i < cnt; i++)
+		to[i] = from ? from[i] : 0;
 }
-#else
-#define i2c_pnx_controller_suspend	NULL
-#define i2c_pnx_controller_resume	NULL
-#endif
+
+/**
+ * i2c_pnx_smbus_xfer - SMBUS protocol transfer routine
+ * @adapter:	pointer to I2C adapter structure
+ * @msgs:		array of messages
+ * @num:		number of messages
+ *
+ * Initiates the transfer
+ */
+static int i2c_pnx_smbus_xfer(struct i2c_adapter *adapter,
+		u16 addr, unsigned short flags, char read_write, u8 command,
+		int size, union i2c_smbus_data *data)
+{
+	struct i2c_pnx_algo_data *smbus = adapter->algo_data;
+	struct i2c_pnx_smbus *smb = &smbus->smb;
+	u16 *tx_buf = smb->tx_buf;
+	int read_flag, err;
+	int len = 0, i = 0;
+
+	dev_dbg(&adapter->dev, "SMBus xfer request: Slave addr %#02x,"
+			"command=%d, operation=%d\r\n", addr, command, size);
+
+	smb->slave_addr = addr;
+	/* All our ops take 8-bit shifted addresses */
+	addr <<= 1;
+	read_flag = read_write == I2C_SMBUS_READ;
+
+	clk_enable(smbus->clk);
+
+	err = i2c_pnx_smbus_check(smbus);
+	if (unlikely(err)) {
+		clk_disable(smbus->clk);
+		return err;
+	}
+
+	i2c_pnx_smbus_init(smbus);
+
+	smb->rx_buf = data->block;
+	switch (size) {
+	case I2C_SMBUS_QUICK:
+		tx_buf[0] = addr | start_bit | stop_bit | read_flag;
+		read_flag = 0;
+		smb->len = 1;
+		break;
+
+	case I2C_SMBUS_BYTE:
+		tx_buf[0] = addr | start_bit | read_flag;
+		tx_buf[1] = command | stop_bit;
+		smb->len = 2;
+		break;
+
+	case I2C_SMBUS_BYTE_DATA:
+		i = 0;
+		tx_buf[i++] = addr | start_bit;
+		tx_buf[i++] = command;
+		if (read_flag)
+			tx_buf[i++] = addr | start_bit | 1;
+		tx_buf[i++] = data->byte | stop_bit;
+		smb->len = i;
+		break;
+
+	case I2C_SMBUS_WORD_DATA:
+		i = 0;
+		tx_buf[i++] = addr | start_bit;
+		tx_buf[i++] = command;
+		if (read_flag)
+			tx_buf[i++] = addr | start_bit | 1;
+		tx_buf[i++] = (data->word & 0xFF); /* Low Word */
+		tx_buf[i++] = ((data->word >> 8) & 0xFF) | stop_bit;
+		smb->len = i;
+		smb->flags |= I2C_PNX_SMBUS_WORD_RX;
+		break;
+
+	case I2C_SMBUS_BLOCK_DATA:
+		len = data->block[0];
+		tx_buf[i++] = addr | start_bit;
+		tx_buf[i++] = command;
+		if (read_flag) {
+			tx_buf[i++] = addr | start_bit | 1;
+			i2c_pnx_fill_buffer(&tx_buf[i],
+					(u8 *)NULL, I2C_SMBUS_BLOCK_MAX + 1);
+			tx_buf[I2C_SMBUS_BLOCK_MAX + i] |= stop_bit;
+			smb->rx_buf = data->block;
+			smb->flags |= I2C_PNX_SMBUS_BLOCK_RX;
+			smb->len = i + 2;
+			smb->max_rx_len = I2C_SMBUS_BLOCK_MAX;
+		} else {
+			if (!len) {
+				clk_disable(smbus->clk);
+				return -EIO;
+			}
+			i2c_pnx_fill_buffer(&tx_buf[i],
+			    data->block, len + 1);
+			tx_buf[len + i] |= stop_bit;
+			smb->len = len + i + 1;
+		}
+		break;
+
+	case I2C_SMBUS_PROC_CALL:
+		tx_buf[0] = addr | start_bit;
+		tx_buf[1] = command;
+		tx_buf[2] = data->word & 0xFF;
+		tx_buf[3] = (data->word >> 8) & 0xFF;
+		tx_buf[4] = addr | start_bit | 1;
+		tx_buf[5] = 0;
+		tx_buf[6] = 0 | stop_bit;
+		smb->len = 7;
+		smb->max_rx_len = 2;
+		smb->flags |= I2C_PNX_SMBUS_WORD_RX;
+		read_flag = 1;
+		break;
+
+	case I2C_SMBUS_BLOCK_PROC_CALL:
+		len = data->block[0];
+		if (!len) {
+			clk_disable(smbus->clk);
+			return -EINVAL;
+		}
+		tx_buf[0] = addr | start_bit;
+		tx_buf[1] = command;
+		i2c_pnx_fill_buffer(&tx_buf[2],
+			data->block, len + 1);
+		i = 3 + len;
+		tx_buf[i++] = addr | start_bit | 1;
+		len = I2C_SMBUS_BLOCK_MAX - len;
+		i2c_pnx_fill_buffer(&tx_buf[i],
+		    NULL, len + 1);
+		tx_buf[i+len] = stop_bit;
+		smb->flags |= I2C_PNX_SMBUS_BLOCK_RX;
+		smb->max_rx_len = len;
+		smb->len = 2 + i;
+		read_flag = 1;
+		break;
+
+	default:
+		dev_warn(&adapter->dev, "Unsupported transaction %d\n", size);
+		clk_disable(smbus->clk);
+		return -EINVAL;
+	}
+	/* Enable interrupts and wait for completion of xfer */
+	iowrite32(ioread32(I2C_REG_CTL(smbus)) | 0xEF, I2C_REG_CTL(smbus));
+
+	err = wait_for_completion_interruptible_timeout(&smb->complete, HZ);
+
+	/* Disable interrupts */
+	iowrite32(ioread32(I2C_REG_CTL(smbus)) & ~0xEF, I2C_REG_CTL(smbus));
+	smb->flags &= ~I2C_PNX_SMBUS_ACTIVE;
+
+	if (err == 0) { /* Xfer timedout */
+		dev_dbg(&adapter->dev, "SMBus Xfer timedout"
+				"[Slave Addr: %02x]\n", addr >> 1);
+		err = -ETIMEDOUT;
+		smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+	} else if (err > 0) { /* No error */
+		err = smb->ret;
+	} else { /* < 0 Possibly interrupted */
+		smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+	}
+
+	/* Handle post processing for a Rx xfer */
+	if (!err && read_flag) {
+		len = (smb->flags & I2C_PNX_SMBUS_BLOCK_RX) ?
+			data->block[0] + 1 : 1;
+
+		if (smb->flags & I2C_PNX_SMBUS_WORD_RX) {
+			len = 2;
+			/* Return endian independent data */
+			data->word = (data->block[0] & 0xFF) |
+				((data->block[1] & 0xFF) << 8);
+		}
+		if (unlikely(len > smb->rx_cnt)) {
+			dev_err(&adapter->dev, "SMBus: Rx count error "
+					"[Expected:%d, Got:%d] slave: %#02x\n",
+					len, smb->rx_cnt, addr >> 1);
+			err = -EIO;
+		}
+	}
+
+	if (unlikely(smb->flags & I2C_PNX_SMBUS_NEED_RESET)) {
+		iowrite32(ioread32(I2C_REG_CTL(smbus)) | mcntrl_reset,
+			  I2C_REG_CTL(smbus));
+	}
+
+	clk_disable(smbus->clk);
+
+	return err;
+}
+
+/**
+ * i2c_pnx_func - SMBUS protocol transfer routine
+ * @adapt:	pointer to I2C adapter structure
+ *
+ * Provides the list of functionality provided by pnx-i2c
+ *
+ * I2C_FUNC_10BIT_ADDR - is supported by hardware but
+ * this driver does not implement it!
+ */
+static u32 i2c_pnx_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
+	       I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
+	       I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_PROC_CALL |
+	       I2C_FUNC_SMBUS_BLOCK_PROC_CALL | I2C_FUNC_I2C;
+}
+
+static const struct i2c_algorithm pnx_algorithm = {
+	.master_xfer = i2c_pnx_xfer,
+	.smbus_xfer  = i2c_pnx_smbus_xfer,
+	.functionality = i2c_pnx_func,
+};
 
 static int __devinit i2c_pnx_probe(struct platform_device *pdev)
 {
@@ -666,6 +1044,9 @@ static int __devinit i2c_pnx_probe(struct platform_device *pdev)
 	dev_dbg(&pdev->dev, "%s: Master at %#8x, irq %d.\n",
 	       alg_data->adapter.name, i2c_pnx->base, i2c_pnx->irq);
 
+	/* Disable clock until needed */
+	clk_disable(alg_data->clk);
+
 	return 0;
 
 out_irq:
@@ -691,6 +1072,7 @@ static int __devexit i2c_pnx_remove(struct platform_device *pdev)
 	struct i2c_pnx_algo_data *alg_data = platform_get_drvdata(pdev);
 	struct i2c_pnx_data *i2c_pnx = alg_data->i2c_pnx;
 
+	clk_enable(alg_data->clk);
 	free_irq(i2c_pnx->irq, alg_data);
 	i2c_del_adapter(&alg_data->adapter);
 	clk_disable(alg_data->clk);
@@ -710,8 +1092,6 @@ static struct platform_driver i2c_pnx_driver = {
 	},
 	.probe = i2c_pnx_probe,
 	.remove = __devexit_p(i2c_pnx_remove),
-	.suspend = i2c_pnx_controller_suspend,
-	.resume = i2c_pnx_controller_resume,
 };
 
 static int __init i2c_adap_pnx_init(void)
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index b16bed0..5ece3ac 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -292,6 +292,15 @@ config KEYBOARD_LOCOMO
 	  To compile this driver as a module, choose M here: the
 	  module will be called locomokbd.
 
+config KEYBOARD_LPC32XX
+        tristate "LPC32XX matrix key scanner support"
+        depends on ARCH_LPC32XX
+        help
+          Say Y here if you want to use the LPC32XX keyscanner interface.
+
+          To compile this driver as a module, choose M here: the
+          module will be called lpc32xx_keys.
+
 config KEYBOARD_MAPLE
 	tristate "Maple bus keyboard"
 	depends on SH_DREAMCAST && MAPLE
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index 878e6c2..36e0d0d 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_KEYBOARD_HP7XX)		+= jornada720_kbd.o
 obj-$(CONFIG_KEYBOARD_LKKBD)		+= lkkbd.o
 obj-$(CONFIG_KEYBOARD_LM8323)		+= lm8323.o
 obj-$(CONFIG_KEYBOARD_LOCOMO)		+= locomokbd.o
+obj-$(CONFIG_KEYBOARD_LPC32XX)  += lpc32xx_keys.o
 obj-$(CONFIG_KEYBOARD_MAPLE)		+= maple_keyb.o
 obj-$(CONFIG_KEYBOARD_MATRIX)		+= matrix_keypad.o
 obj-$(CONFIG_KEYBOARD_MAX7359)		+= max7359_keypad.o
diff --git a/drivers/input/keyboard/lpc32xx_keys.c b/drivers/input/keyboard/lpc32xx_keys.c
new file mode 100644
index 0000000..3eb37ac
--- /dev/null
+++ b/drivers/input/keyboard/lpc32xx_keys.c
@@ -0,0 +1,293 @@
+/*
+ * linux/drivers/input/keyboard/lpc32xx-keys.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <mach/board.h>
+
+/*
+ * Key scanner register offsets
+ */
+#define LPC32XX_KS_DEB(x)			((x) + 0x00)
+#define LPC32XX_KS_STATE_COND(x)		((x) + 0x04)
+#define LPC32XX_KS_IRQ(x)			((x) + 0x08)
+#define LPC32XX_KS_SCAN_CTL(x)			((x) + 0x0C)
+#define LPC32XX_KS_FAST_TST(x)			((x) + 0x10)
+#define LPC32XX_KS_MATRIX_DIM(x)		((x) + 0x14)
+#define LPC32XX_KS_DATA(x, y)			((x) + 0x40 + (y  << 2))
+
+#define LPC32XX_KSCAN_DEB_NUM_DEB_PASS(n)	((n) & 0xFF)
+
+#define LPC32XX_KSCAN_SCOND_IN_IDLE		0x0
+#define LPC32XX_KSCAN_SCOND_IN_SCANONCE		0x1
+#define LPC32XX_KSCAN_SCOND_IN_IRQGEN		0x2
+#define LPC32XX_KSCAN_SCOND_IN_SCAN_MATRIX	0x3
+
+#define LPC32XX_KSCAN_IRQ_PENDING_CLR		0x1
+
+#define LPC32XX_KSCAN_SCTRL_SCAN_DELAY(n)	((n) & 0xFF)
+
+#define LPC32XX_KSCAN_FTST_FORCESCANONCE	0x1
+#define LPC32XX_KSCAN_FTST_USE32K_CLK		0x2
+
+#define LPC32XX_KSCAN_MSEL_SELECT(n)		((n) & 0xF)
+
+struct lpc32xx_kscan_drv {
+	struct input_dev *input;
+	struct lpc32XX_kscan_cfg *kscancfg;
+	struct clk *clk;
+	void __iomem *kscan_base;
+	int irq;
+	u8 lastkeystates[8];
+};
+
+static void lpc32xx_mod_states(struct lpc32xx_kscan_drv *kscandat, int off)
+{
+	u8 st, key;
+	int j, scancode, keycode;
+
+	key = (u8) __raw_readl(LPC32XX_KS_DATA(kscandat->kscan_base, off));
+	if (key != kscandat->lastkeystates[off]) {
+		for (j = 0; j < kscandat->kscancfg->matrix_sz; j++) {
+			st = key & (1 << j);
+			if (st != (kscandat->lastkeystates[off] & (1 << j))) {
+				/* Key state changed, signal an event */
+				scancode = (int) (j *
+					kscandat->kscancfg->matrix_sz) + off;
+				keycode =
+					kscandat->kscancfg->keymap[scancode];
+				input_report_key(kscandat->input, keycode,
+					(st != 0));
+			}
+		}
+
+		kscandat->lastkeystates[off] = key;
+	}
+}
+
+static irqreturn_t lpc32xx_kscan_irq(int irq, void *dev_id)
+{
+	int i;
+	struct lpc32xx_kscan_drv *kscandat =
+		(struct lpc32xx_kscan_drv *) dev_id;
+
+	for (i = 0; i < kscandat->kscancfg->matrix_sz; i++)
+		lpc32xx_mod_states(kscandat, i);
+
+	__raw_writel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));
+
+	input_sync(kscandat->input);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit lpc32xx_kscan_probe(struct platform_device *pdev)
+{
+	struct lpc32xx_kscan_drv *kscandat;
+	struct resource *res;
+	int retval, i;
+
+	kscandat = kzalloc(sizeof(struct lpc32xx_kscan_drv), GFP_KERNEL);
+	if (unlikely(!kscandat)) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get platform I/O memory\n");
+		retval = -EBUSY;
+		goto err_nores;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to request I/O memory\n");
+		retval = -EBUSY;
+		goto err_nores;
+	}
+
+	kscandat->kscan_base = ioremap(res->start, res->end - res->start + 1);
+	if (kscandat->kscan_base == NULL) {
+		dev_err(&pdev->dev, "failed to remap I/O memory\n");
+		retval = -EBUSY;
+		goto err_noremap;
+	}
+
+	/* Get the key scanner clock */
+	kscandat->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(kscandat->clk)) {
+		dev_err(&pdev->dev, "failed to get clock\n");
+		retval = -ENODEV;
+		goto err_noclk;
+	}
+	clk_enable(kscandat->clk);
+
+	kscandat->irq = platform_get_irq(pdev, 0);
+	if ((kscandat->irq < 0) || (kscandat->irq >= NR_IRQS)) {
+		dev_err(&pdev->dev, "failed to get platform irq\n");
+		retval = -EINVAL;
+		goto err_noirq;
+	}
+	retval = request_irq(kscandat->irq, lpc32xx_kscan_irq,
+		0, pdev->name, kscandat);
+	if (retval) {
+		dev_err(&pdev->dev, "failed to request irq\n");
+		goto err_noirq;
+	}
+
+	kscandat->input = input_allocate_device();
+	if (kscandat->input == NULL) {
+		dev_err(&pdev->dev, "failed to allocate device\n");
+		retval = -ENOMEM;
+		goto err_noalloc;
+	}
+
+	kscandat->kscancfg = (struct lpc32XX_kscan_cfg *)
+		pdev->dev.platform_data;
+	platform_set_drvdata(pdev, kscandat);
+
+	/* Setup key input */
+	kscandat->input->evbit[0]	= BIT_MASK(EV_KEY);
+	kscandat->input->name		= pdev->name;
+	kscandat->input->phys		= "matrix-keys/input0";
+	kscandat->input->dev.parent	=  &pdev->dev;
+	kscandat->input->id.vendor	= 0x0001;
+	kscandat->input->id.product	= 0x0001;
+	kscandat->input->id.version	= 0x0100;
+	for (i = 0; i < kscandat->kscancfg->matrix_sz; i++)
+		__set_bit(kscandat->kscancfg->keymap[i],
+			kscandat->input->keybit);
+
+	input_set_capability(kscandat->input, EV_MSC, MSC_SCAN);
+
+	retval = input_register_device(kscandat->input);
+	if (retval) {
+		dev_err(&pdev->dev, "failed to register input device\n");
+		goto err_notregistered;
+	}
+
+	/* Configure the key scanner */
+	__raw_writel(kscandat->kscancfg->deb_clks,
+		LPC32XX_KS_DEB(kscandat->kscan_base));
+	__raw_writel(kscandat->kscancfg->scan_delay,
+		LPC32XX_KS_SCAN_CTL(kscandat->kscan_base));
+	__raw_writel(LPC32XX_KSCAN_FTST_USE32K_CLK,
+		LPC32XX_KS_FAST_TST(kscandat->kscan_base));
+	__raw_writel(kscandat->kscancfg->matrix_sz,
+		LPC32XX_KS_MATRIX_DIM(kscandat->kscan_base));
+	__raw_writel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));
+
+	return 0;
+
+err_notregistered:
+	input_free_device(kscandat->input);
+err_noalloc:
+	free_irq(kscandat->irq, pdev);
+err_noirq:
+	clk_put(kscandat->clk);
+err_noclk:
+	iounmap(kscandat->kscan_base);
+err_noremap:
+	release_mem_region(res->start, resource_size(res));
+err_nores:
+	kfree(kscandat);
+
+	return retval;
+}
+
+static int __devexit lpc32xx_kscan_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);
+
+	free_irq(kscandat->irq, pdev);
+	input_unregister_device(kscandat->input);
+	clk_put(kscandat->clk);
+	iounmap(kscandat->kscan_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	kfree(kscandat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lpc32xx_kscan_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	struct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);
+
+	/* Clear IRQ and disable clock */
+	__raw_writel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));
+	clk_disable(kscandat->clk);
+
+	return 0;
+}
+
+static int lpc32xx_kscan_resume(struct platform_device *pdev)
+{
+	struct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);
+
+	/* Enable clock and clear IRQ */
+	clk_enable(kscandat->clk);
+	__raw_writel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));
+
+	return 0;
+}
+#else
+#define lpc32xx_kscan_suspend	NULL
+#define lpc32xx_kscan_resume	NULL
+#endif
+
+static struct platform_driver lpc32xx_kscan_driver = {
+	.probe		= lpc32xx_kscan_probe,
+	.remove		= __devexit_p(lpc32xx_kscan_remove),
+	.suspend	= lpc32xx_kscan_suspend,
+	.resume		= lpc32xx_kscan_resume,
+	.driver		= {
+		.name	= "lpc32xx_keys",
+	}
+};
+
+static int __init lpc32xx_kscan_init(void)
+{
+	return platform_driver_register(&lpc32xx_kscan_driver);
+}
+
+static void __exit lpc32xx_kscan_exit(void)
+{
+	platform_driver_unregister(&lpc32xx_kscan_driver);
+}
+
+module_init(lpc32xx_kscan_init);
+module_exit(lpc32xx_kscan_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("Key scanner driver for LPC32XX devices");
diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index dcf803f..73b9d8b 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -1,5 +1,7 @@
 /*
- * LPC32xx built-in touchscreen driver
+ * drivers/input/touchscreen/lpc32xx_tsc.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
  *
  * Copyright (C) 2010 NXP Semiconductors
  *
@@ -26,31 +28,29 @@
 /*
  * Touchscreen controller register offsets
  */
-#define LPC32XX_TSC_STAT			0x00
-#define LPC32XX_TSC_SEL				0x04
-#define LPC32XX_TSC_CON				0x08
-#define LPC32XX_TSC_FIFO			0x0C
-#define LPC32XX_TSC_DTR				0x10
-#define LPC32XX_TSC_RTR				0x14
-#define LPC32XX_TSC_UTR				0x18
-#define LPC32XX_TSC_TTR				0x1C
-#define LPC32XX_TSC_DXP				0x20
-#define LPC32XX_TSC_MIN_X			0x24
-#define LPC32XX_TSC_MAX_X			0x28
-#define LPC32XX_TSC_MIN_Y			0x2C
-#define LPC32XX_TSC_MAX_Y			0x30
-#define LPC32XX_TSC_AUX_UTR			0x34
-#define LPC32XX_TSC_AUX_MIN			0x38
-#define LPC32XX_TSC_AUX_MAX			0x3C
+#define LPC32XX_TSC_STAT(x)			((x) + 0x00)
+#define LPC32XX_TSC_SEL(x)			((x) + 0x04)
+#define LPC32XX_TSC_CON(x)			((x) + 0x08)
+#define LPC32XX_TSC_FIFO(x)			((x) + 0x0C)
+#define LPC32XX_TSC_DTR(x)			((x) + 0x10)
+#define LPC32XX_TSC_RTR(x)			((x) + 0x14)
+#define LPC32XX_TSC_UTR(x)			((x) + 0x18)
+#define LPC32XX_TSC_TTR(x)			((x) + 0x1C)
+#define LPC32XX_TSC_DXP(x)			((x) + 0x20)
+#define LPC32XX_TSC_MIN_X(x)			((x) + 0x24)
+#define LPC32XX_TSC_MAX_X(x)			((x) + 0x28)
+#define LPC32XX_TSC_MIN_Y(x)			((x) + 0x2C)
+#define LPC32XX_TSC_MAX_Y(x)			((x) + 0x30)
+#define LPC32XX_TSC_AUX_UTR(x)			((x) + 0x34)
+#define LPC32XX_TSC_AUX_MIN(x)			((x) + 0x38)
+#define LPC32XX_TSC_AUX_MAX(x)			((x) + 0x3C)
 
 #define LPC32XX_TSC_STAT_FIFO_OVRRN		(1 << 8)
 #define LPC32XX_TSC_STAT_FIFO_EMPTY		(1 << 7)
 
-#define LPC32XX_TSC_SEL_DEFVAL			0x0284
-
 #define LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4	(0x1 << 11)
-#define LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(s)	((10 - (s)) << 7)
-#define LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(s)	((10 - (s)) << 4)
+#define LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(s)	((10 - s) << 7)
+#define LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(s)	((10 - s) << 4)
 #define LPC32XX_TSC_ADCCON_POWER_UP		(1 << 2)
 #define LPC32XX_TSC_ADCCON_AUTO_EN		(1 << 0)
 
@@ -60,55 +60,44 @@
 
 #define LPC32XX_TSC_ADCDAT_VALUE_MASK		0x000003FF
 
-#define LPC32XX_TSC_MIN_XY_VAL			0x0
-#define LPC32XX_TSC_MAX_XY_VAL			0x3FF
-
-#define MOD_NAME "ts-lpc32xx"
-
-#define tsc_readl(dev, reg) \
-	__raw_readl((dev)->tsc_base + (reg))
-#define tsc_writel(dev, reg, val) \
-	__raw_writel((val), (dev)->tsc_base + (reg))
+#define MOD_NAME "lpc32xx-ts"
 
-struct lpc32xx_tsc {
+struct lpc32xx_tsc_t {
 	struct input_dev *dev;
 	void __iomem *tsc_base;
 	int irq;
 	struct clk *clk;
+	int suspended;
 };
 
-static void lpc32xx_fifo_clear(struct lpc32xx_tsc *tsc)
+static void lpc32xx_fifo_clear(struct lpc32xx_tsc_t *lpc32xx_tsc_dat)
 {
-	while (!(tsc_readl(tsc, LPC32XX_TSC_STAT) &
-			LPC32XX_TSC_STAT_FIFO_EMPTY))
-		tsc_readl(tsc, LPC32XX_TSC_FIFO);
+	while (!(__raw_readl(LPC32XX_TSC_STAT(lpc32xx_tsc_dat->tsc_base)) &
+		LPC32XX_TSC_STAT_FIFO_EMPTY))
+		__raw_readl(LPC32XX_TSC_FIFO(lpc32xx_tsc_dat->tsc_base));
 }
 
 static irqreturn_t lpc32xx_ts_interrupt(int irq, void *dev_id)
 {
 	u32 tmp, rv[4], xs[4], ys[4];
 	int idx;
-	struct lpc32xx_tsc *tsc = dev_id;
-	struct input_dev *input = tsc->dev;
+	struct lpc32xx_tsc_t *lpc32xx_tsc_dat =
+		(struct lpc32xx_tsc_t *) dev_id;
+	struct input_dev *input = lpc32xx_tsc_dat->dev;
 
-	tmp = tsc_readl(tsc, LPC32XX_TSC_STAT);
+	tmp = __raw_readl(LPC32XX_TSC_STAT(lpc32xx_tsc_dat->tsc_base));
 
 	if (tmp & LPC32XX_TSC_STAT_FIFO_OVRRN) {
 		/* FIFO overflow - throw away samples */
-		lpc32xx_fifo_clear(tsc);
+		lpc32xx_fifo_clear(lpc32xx_tsc_dat);
 		return IRQ_HANDLED;
 	}
 
-	/*
-	 * Gather and normalize 4 samples. Pen-up events may have less
-	 * than 4 samples, but its ok to pop 4 and let the last sample
-	 * pen status check drop the samples.
-	 */
 	idx = 0;
-	while (idx < 4 &&
-	       !(tsc_readl(tsc, LPC32XX_TSC_STAT) &
-			LPC32XX_TSC_STAT_FIFO_EMPTY)) {
-		tmp = tsc_readl(tsc, LPC32XX_TSC_FIFO);
+	while ((idx < 4) &&
+		(!(__raw_readl(LPC32XX_TSC_STAT(lpc32xx_tsc_dat->tsc_base)) &
+		LPC32XX_TSC_STAT_FIFO_EMPTY))) {
+		tmp = __raw_readl(LPC32XX_TSC_FIFO(lpc32xx_tsc_dat->tsc_base));
 		xs[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -
 			LPC32XX_TSC_FIFO_NORMALIZE_X_VAL(tmp);
 		ys[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -
@@ -117,13 +106,14 @@ static irqreturn_t lpc32xx_ts_interrupt(int irq, void *dev_id)
 		idx++;
 	}
 
-	/* Data is only valid if pen is still down in last sample */
-	if (!(rv[3] & LPC32XX_TSC_FIFO_TS_P_LEVEL) && idx == 4) {
-		/* Use average of 2nd and 3rd sample for position */
-		input_report_abs(input, ABS_X, (xs[1] + xs[2]) / 2);
-		input_report_abs(input, ABS_Y, (ys[1] + ys[2]) / 2);
+	/* Data is only valid if pen is still down */
+	if ((!(rv[3] & LPC32XX_TSC_FIFO_TS_P_LEVEL)) && (idx == 4)) {
+		input_report_abs(input, ABS_X, ((xs[1] + xs[2]) / 2));
+		input_report_abs(input, ABS_Y, ((ys[1] + ys[2]) / 2));
+		input_report_abs(input, ABS_PRESSURE, 1);
 		input_report_key(input, BTN_TOUCH, 1);
 	} else {
+		input_report_abs(input, ABS_PRESSURE, 0);
 		input_report_key(input, BTN_TOUCH, 0);
 	}
 
@@ -132,244 +122,214 @@ static irqreturn_t lpc32xx_ts_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void lpc32xx_stop_tsc(struct lpc32xx_tsc *tsc)
+static void stop_tsc(struct lpc32xx_tsc_t *lpc32xx_tsc_dat)
 {
-	/* Disable auto mode */
-	tsc_writel(tsc, LPC32XX_TSC_CON,
-		   tsc_readl(tsc, LPC32XX_TSC_CON) &
-			     ~LPC32XX_TSC_ADCCON_AUTO_EN);
+	u32 tmp;
 
-	clk_disable(tsc->clk);
+	/* Disable auto mode */
+	tmp = __raw_readl(LPC32XX_TSC_CON(lpc32xx_tsc_dat->tsc_base));
+	tmp &= ~LPC32XX_TSC_ADCCON_AUTO_EN;
+	__raw_writel(tmp, LPC32XX_TSC_CON(lpc32xx_tsc_dat->tsc_base));
 }
 
-static void lpc32xx_setup_tsc(struct lpc32xx_tsc *tsc)
+static void setup_tsc(struct lpc32xx_tsc_t *lpc32xx_tsc_dat)
 {
 	u32 tmp;
 
-	clk_enable(tsc->clk);
-
-	tmp = tsc_readl(tsc, LPC32XX_TSC_CON) & ~LPC32XX_TSC_ADCCON_POWER_UP;
-
-	/* Set the TSC FIFO depth to 4 samples @ 10-bits per sample (max) */
-	tmp = LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4 |
-	      LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(10) |
-	      LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(10);
-	tsc_writel(tsc, LPC32XX_TSC_CON, tmp);
-
-	/* These values are all preset */
-	tsc_writel(tsc, LPC32XX_TSC_SEL, LPC32XX_TSC_SEL_DEFVAL);
-	tsc_writel(tsc, LPC32XX_TSC_MIN_X, LPC32XX_TSC_MIN_XY_VAL);
-	tsc_writel(tsc, LPC32XX_TSC_MAX_X, LPC32XX_TSC_MAX_XY_VAL);
-	tsc_writel(tsc, LPC32XX_TSC_MIN_Y, LPC32XX_TSC_MIN_XY_VAL);
-	tsc_writel(tsc, LPC32XX_TSC_MAX_Y, LPC32XX_TSC_MAX_XY_VAL);
-
-	/* Aux support is not used */
-	tsc_writel(tsc, LPC32XX_TSC_AUX_UTR, 0);
-	tsc_writel(tsc, LPC32XX_TSC_AUX_MIN, 0);
-	tsc_writel(tsc, LPC32XX_TSC_AUX_MAX, 0);
+	tmp = __raw_readl(LPC32XX_TSC_CON(lpc32xx_tsc_dat->tsc_base));
+	tmp &= ~LPC32XX_TSC_ADCCON_POWER_UP;
+	__raw_writel(tmp, LPC32XX_TSC_CON(lpc32xx_tsc_dat->tsc_base));
+
+	/* Set the TSC FIFO depth to 4 samples @ 10-bits sample */
+	tmp = (LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4 |
+		LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(10) |
+		LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(10));
+	__raw_writel(tmp, LPC32XX_TSC_CON(lpc32xx_tsc_dat->tsc_base));
+
+	__raw_writel(0x0284, LPC32XX_TSC_SEL(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x0000, LPC32XX_TSC_MIN_X(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x03FF, LPC32XX_TSC_MAX_X(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x0000, LPC32XX_TSC_MIN_Y(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x03FF, LPC32XX_TSC_MAX_Y(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x0000, LPC32XX_TSC_AUX_UTR(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x0000, LPC32XX_TSC_AUX_MIN(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x0000, LPC32XX_TSC_AUX_MAX(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x2, LPC32XX_TSC_RTR(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(446, LPC32XX_TSC_UTR(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x2, LPC32XX_TSC_DTR(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x10, LPC32XX_TSC_TTR(lpc32xx_tsc_dat->tsc_base));
+	__raw_writel(0x4, LPC32XX_TSC_DXP(lpc32xx_tsc_dat->tsc_base));
 
 	/*
-	 * Set sample rate to about 240Hz per X/Y pair. A single measurement
-	 * consists of 4 pairs which gives about a 60Hz sample rate based on
-	 * a stable 32768Hz clock source. Values are in clocks.
-	 * Rate is (32768 / (RTR + XCONV + RTR + YCONV + DXP + TTR + UTR) / 4
+	 * Set sample rate to about 60Hz, this rate is based on the
+	 * RTC clock, which should be a stable 32768Hz
 	 */
-	tsc_writel(tsc, LPC32XX_TSC_RTR, 0x2);
-	tsc_writel(tsc, LPC32XX_TSC_DTR, 0x2);
-	tsc_writel(tsc, LPC32XX_TSC_TTR, 0x10);
-	tsc_writel(tsc, LPC32XX_TSC_DXP, 0x4);
-	tsc_writel(tsc, LPC32XX_TSC_UTR, 88);
+	__raw_writel(88, LPC32XX_TSC_UTR(lpc32xx_tsc_dat->tsc_base));
 
-	lpc32xx_fifo_clear(tsc);
+	lpc32xx_fifo_clear(lpc32xx_tsc_dat);
 
-	/* Enable automatic ts event capture */
-	tsc_writel(tsc, LPC32XX_TSC_CON, tmp | LPC32XX_TSC_ADCCON_AUTO_EN);
-}
-
-static int lpc32xx_ts_open(struct input_dev *dev)
-{
-	struct lpc32xx_tsc *tsc = input_get_drvdata(dev);
-
-	lpc32xx_setup_tsc(tsc);
-
-	return 0;
-}
-
-static void lpc32xx_ts_close(struct input_dev *dev)
-{
-	struct lpc32xx_tsc *tsc = input_get_drvdata(dev);
-
-	lpc32xx_stop_tsc(tsc);
+	tmp = __raw_readl(LPC32XX_TSC_CON(lpc32xx_tsc_dat->tsc_base));
+	tmp |= LPC32XX_TSC_ADCCON_AUTO_EN;
+	__raw_writel(tmp, LPC32XX_TSC_CON(lpc32xx_tsc_dat->tsc_base));
 }
 
 static int __devinit lpc32xx_ts_probe(struct platform_device *pdev)
 {
-	struct lpc32xx_tsc *tsc;
-	struct input_dev *input;
+	struct lpc32xx_tsc_t *lpc32xx_tsc_dat = NULL;
 	struct resource *res;
-	resource_size_t size;
-	int irq;
-	int error;
+	int retval = -ENODEV;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
-		dev_err(&pdev->dev, "Can't get memory resource\n");
-		return -ENOENT;
+		dev_err(&pdev->dev, "failed to get platform I/O memory\n");
+		retval = -EBUSY;
+		goto errout;
 	}
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		dev_err(&pdev->dev, "Can't get interrupt resource\n");
-		return irq;
-	}
-
-	tsc = kzalloc(sizeof(*tsc), GFP_KERNEL);
-	input = input_allocate_device();
-	if (!tsc || !input) {
+	lpc32xx_tsc_dat = kzalloc(sizeof(struct lpc32xx_tsc_t), GFP_KERNEL);
+	if (unlikely(!lpc32xx_tsc_dat)) {
 		dev_err(&pdev->dev, "failed allocating memory\n");
-		error = -ENOMEM;
-		goto err_free_mem;
+		retval = -ENOMEM;
+		goto errout;
 	}
 
-	tsc->dev = input;
-	tsc->irq = irq;
-
-	size = resource_size(res);
-
-	if (!request_mem_region(res->start, size, pdev->name)) {
-		dev_err(&pdev->dev, "TSC registers are not free\n");
-		error = -EBUSY;
-		goto err_free_mem;
+	lpc32xx_tsc_dat->tsc_base = ioremap(res->start,
+		res->end - res->start + 1);
+	if (!lpc32xx_tsc_dat->tsc_base) {
+		dev_err(&pdev->dev, "failed mapping memory\n");
+		retval = -EBUSY;
+		goto errout;
 	}
 
-	tsc->tsc_base = ioremap(res->start, size);
-	if (!tsc->tsc_base) {
-		dev_err(&pdev->dev, "Can't map memory\n");
-		error = -ENOMEM;
-		goto err_release_mem;
+	lpc32xx_tsc_dat->dev = input_allocate_device();
+	if (!lpc32xx_tsc_dat->dev) {
+		dev_err(&pdev->dev, "failed allocating input device\n");
+		retval = -ENOMEM;
+		goto errout;
 	}
 
-	tsc->clk = clk_get(&pdev->dev, NULL);
-	if (IS_ERR(tsc->clk)) {
+	lpc32xx_tsc_dat->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(lpc32xx_tsc_dat->clk)) {
 		dev_err(&pdev->dev, "failed getting clock\n");
-		error = PTR_ERR(tsc->clk);
-		goto err_unmap;
+		goto errout;
+	}
+	clk_enable(lpc32xx_tsc_dat->clk);
+
+	setup_tsc(lpc32xx_tsc_dat);
+
+	lpc32xx_tsc_dat->irq = platform_get_irq(pdev, 0);
+	if ((lpc32xx_tsc_dat->irq < 0) || (lpc32xx_tsc_dat->irq >= NR_IRQS)) {
+		dev_err(&pdev->dev, "failed getting interrupt resource\n");
+		retval = -EINVAL;
+		goto errout;
 	}
 
-	input->name = MOD_NAME;
-	input->phys = "lpc32xx/input0";
-	input->id.bustype = BUS_HOST;
-	input->id.vendor = 0x0001;
-	input->id.product = 0x0002;
-	input->id.version = 0x0100;
-	input->dev.parent = &pdev->dev;
-	input->open = lpc32xx_ts_open;
-	input->close = lpc32xx_ts_close;
-
-	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
-	input_set_abs_params(input, ABS_X, LPC32XX_TSC_MIN_XY_VAL,
-			     LPC32XX_TSC_MAX_XY_VAL, 0, 0);
-	input_set_abs_params(input, ABS_Y, LPC32XX_TSC_MIN_XY_VAL,
-			     LPC32XX_TSC_MAX_XY_VAL, 0, 0);
-
-	input_set_drvdata(input, tsc);
-
-	error = request_irq(tsc->irq, lpc32xx_ts_interrupt,
-			    IRQF_DISABLED, pdev->name, tsc);
-	if (error) {
+	retval = request_irq(lpc32xx_tsc_dat->irq, lpc32xx_ts_interrupt,
+		0, MOD_NAME, lpc32xx_tsc_dat);
+	if (retval < 0) {
 		dev_err(&pdev->dev, "failed requesting interrupt\n");
-		goto err_put_clock;
+		goto err_free_irq;
 	}
 
-	error = input_register_device(input);
-	if (error) {
+	platform_set_drvdata(pdev, lpc32xx_tsc_dat);
+
+	lpc32xx_tsc_dat->dev->name = MOD_NAME;
+	lpc32xx_tsc_dat->dev->phys = "lpc32xx/input0";
+	lpc32xx_tsc_dat->dev->id.bustype = BUS_HOST;
+	lpc32xx_tsc_dat->dev->id.vendor = 0x0001;
+	lpc32xx_tsc_dat->dev->id.product = 0x0002;
+	lpc32xx_tsc_dat->dev->id.version = 0x0100;
+	lpc32xx_tsc_dat->dev->dev.parent = &pdev->dev;
+
+	lpc32xx_tsc_dat->dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	lpc32xx_tsc_dat->dev->keybit[BIT_WORD(BTN_TOUCH)] =
+		BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(lpc32xx_tsc_dat->dev, ABS_X, 0, 1023, 0, 0);
+	input_set_abs_params(lpc32xx_tsc_dat->dev, ABS_Y, 0, 1023, 0, 0);
+	input_set_abs_params(lpc32xx_tsc_dat->dev, ABS_PRESSURE, 0, 1, 0, 0);
+
+	retval = input_register_device(lpc32xx_tsc_dat->dev);
+	if (retval) {
 		dev_err(&pdev->dev, "failed registering input device\n");
 		goto err_free_irq;
 	}
 
-	platform_set_drvdata(pdev, tsc);
 	device_init_wakeup(&pdev->dev, 1);
 
 	return 0;
 
 err_free_irq:
-	free_irq(tsc->irq, tsc);
-err_put_clock:
-	clk_put(tsc->clk);
-err_unmap:
-	iounmap(tsc->tsc_base);
-err_release_mem:
-	release_mem_region(res->start, size);
-err_free_mem:
-	input_free_device(input);
-	kfree(tsc);
-
-	return error;
+	stop_tsc(lpc32xx_tsc_dat);
+	platform_set_drvdata(pdev, NULL);
+	free_irq(lpc32xx_tsc_dat->irq, lpc32xx_tsc_dat->dev);
+
+errout:
+	if (lpc32xx_tsc_dat) {
+		if (lpc32xx_tsc_dat->clk) {
+			clk_disable(lpc32xx_tsc_dat->clk);
+			clk_put(lpc32xx_tsc_dat->clk);
+		}
+
+		if (lpc32xx_tsc_dat->dev)
+			input_free_device(lpc32xx_tsc_dat->dev);
+
+		if (lpc32xx_tsc_dat->tsc_base)
+			iounmap(lpc32xx_tsc_dat->tsc_base);
+
+		kfree(lpc32xx_tsc_dat);
+	}
+
+	return retval;
 }
 
 static int __devexit lpc32xx_ts_remove(struct platform_device *pdev)
 {
-	struct lpc32xx_tsc *tsc = platform_get_drvdata(pdev);
-	struct resource *res;
-
-	device_init_wakeup(&pdev->dev, 0);
-	free_irq(tsc->irq, tsc);
+	struct lpc32xx_tsc_t *lpc32xx_tsc_dat = platform_get_drvdata(pdev);
 
-	input_unregister_device(tsc->dev);
+	stop_tsc(lpc32xx_tsc_dat);
+	free_irq(lpc32xx_tsc_dat->irq, lpc32xx_tsc_dat->dev);
+	platform_set_drvdata(pdev, NULL);
+	input_unregister_device(lpc32xx_tsc_dat->dev);
 
-	clk_put(tsc->clk);
+	if (lpc32xx_tsc_dat->clk) {
+		clk_disable(lpc32xx_tsc_dat->clk);
+		clk_put(lpc32xx_tsc_dat->clk);
+	}
 
-	iounmap(tsc->tsc_base);
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	release_mem_region(res->start, resource_size(res));
+	if (lpc32xx_tsc_dat->tsc_base)
+		iounmap(lpc32xx_tsc_dat->tsc_base);
 
-	kfree(tsc);
+	kfree(lpc32xx_tsc_dat);
 
 	return 0;
 }
 
-#ifdef CONFIG_PM
+#if defined (CONFIG_PM)
 static int lpc32xx_ts_suspend(struct device *dev)
 {
-	struct lpc32xx_tsc *tsc = dev_get_drvdata(dev);
-	struct input_dev *input = tsc->dev;
-
-	/*
-	 * Suspend and resume can be called when the device hasn't been
-	 * enabled. If there are no users that have the device open, then
-	 * avoid calling the TSC stop and start functions as the TSC
-	 * isn't yet clocked.
-	 */
-	mutex_lock(&input->mutex);
-
-	if (input->users) {
-		if (device_may_wakeup(dev))
-			enable_irq_wake(tsc->irq);
-		else
-			lpc32xx_stop_tsc(tsc);
+	struct lpc32xx_tsc_t *lpc32xx_tsc_dat = dev_get_drvdata(dev);
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(lpc32xx_tsc_dat->irq);
+	else {
+		lpc32xx_tsc_dat->suspended = 1;
+		stop_tsc(lpc32xx_tsc_dat);
+		clk_disable(lpc32xx_tsc_dat->clk);
 	}
 
-	mutex_unlock(&input->mutex);
-
 	return 0;
 }
 
 static int lpc32xx_ts_resume(struct device *dev)
 {
-	struct lpc32xx_tsc *tsc = dev_get_drvdata(dev);
-	struct input_dev *input = tsc->dev;
+	struct lpc32xx_tsc_t *lpc32xx_tsc_dat = dev_get_drvdata(dev);
 
-	mutex_lock(&input->mutex);
-
-	if (input->users) {
-		if (device_may_wakeup(dev))
-			disable_irq_wake(tsc->irq);
-		else
-			lpc32xx_setup_tsc(tsc);
-	}
-
-	mutex_unlock(&input->mutex);
+	if (lpc32xx_tsc_dat->suspended) {
+		clk_enable(lpc32xx_tsc_dat->clk);
+		setup_tsc(lpc32xx_tsc_dat);
+		lpc32xx_tsc_dat->suspended = 0;
+	} else
+		disable_irq_wake(lpc32xx_tsc_dat->irq);
 
 	return 0;
 }
@@ -397,15 +357,15 @@ static int __init lpc32xx_ts_init(void)
 {
 	return platform_driver_register(&lpc32xx_ts_driver);
 }
-module_init(lpc32xx_ts_init);
 
 static void __exit lpc32xx_ts_exit(void)
 {
 	platform_driver_unregister(&lpc32xx_ts_driver);
 }
+
+module_init(lpc32xx_ts_init);
 module_exit(lpc32xx_ts_exit);
 
 MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com");
 MODULE_DESCRIPTION("LPC32XX TSC Driver");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:lpc32xx_ts");
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index b4a7e4f..3316773 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -34,11 +34,257 @@
 #include <asm/io.h>
 #include <asm/sizes.h>
 
+#ifdef CONFIG_ARCH_LPC32XX
+#include <mach/clkdev.h>
+#include <mach/dmac.h>
+#include <mach/sdcard.h>
+#include <mach/dma.h>
+#include <mach/hardware.h>
+#endif
+
 #include "mmci.h"
 
 #define DRIVER_NAME "mmci-pl18x"
 
+#ifdef CONFIG_ARCH_LPC32XX
+static unsigned int fmax = 26000000;
+#else
 static unsigned int fmax = 515633;
+#endif
+
+#ifdef CONFIG_ARCH_LPC32XX
+#define DMA_BUFF_SIZE SZ_64K
+
+struct LPC32XX_SDDRV_DATA {
+	struct dma_config dmacfgtx;
+	struct dma_config dmacfgrx;
+	struct device *dev;
+	int lastch;
+	dma_addr_t dma_handle_tx;
+	void *dma_v_base;
+	int mapped;
+};
+static struct LPC32XX_SDDRV_DATA lpc32xx_drvdat;
+
+#define MCI_WIDEBUS (1 << 11)
+#undef MCI_IRQENABLE
+#define MCI_IRQENABLE   \
+        (MCI_CMDCRCFAILMASK|MCI_DATACRCFAILMASK|MCI_CMDTIMEOUTMASK|     \
+        MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|       \
+        MCI_CMDRESPENDMASK|MCI_CMDSENTMASK)
+
+static int mmc_dma_setup(void)
+{
+	u32 llptrrx, llptrtx;
+	int ret = 0;
+
+	/*
+	 * There is a quirk with the LPC32XX and SD burst DMA. DMA sg
+	 * transfers where DMA is the flow controller will not transfer
+	 * the last few bytes to or from the SD card controller and
+	 * memory. For RX, the last few bytes in the SD transfer can be
+	 * forced out with a software DMA burst request. For TX, this
+	 * can't be done, so TX sg support cannot be supported. For TX,
+	 * a temporary bouncing buffer is used if more than 1 sg segment
+	 * is passed in the data request. The bouncing buffer will get a
+	 * contiguous copy of the TX data and it will be used instead.
+	 */
+
+	/* Allocate a chunk of memory for the DMA TX buffers */
+	lpc32xx_drvdat.dma_v_base = dma_alloc_coherent(lpc32xx_drvdat.dev,
+			DMA_BUFF_SIZE, &lpc32xx_drvdat.dma_handle_tx, GFP_KERNEL);
+	if (lpc32xx_drvdat.dma_v_base == NULL) {
+		dev_err(lpc32xx_drvdat.dev, "error getting DMA region\n");
+		ret = -ENOMEM;
+		goto dma_no_tx_buff;
+	}
+	dev_info(lpc32xx_drvdat.dev, "DMA buffer: phy:%p, virt:%p\n",
+			(void *) lpc32xx_drvdat.dma_handle_tx, lpc32xx_drvdat.dma_v_base);
+
+	/* Setup TX DMA channel */
+	lpc32xx_drvdat.dmacfgtx.ch = DMA_CH_SDCARD_TX;
+	lpc32xx_drvdat.dmacfgtx.tc_inten = 0;
+	lpc32xx_drvdat.dmacfgtx.err_inten = 0;
+	lpc32xx_drvdat.dmacfgtx.src_size = 4;
+	lpc32xx_drvdat.dmacfgtx.src_inc = 1;
+	lpc32xx_drvdat.dmacfgtx.src_ahb1 = 0;
+	lpc32xx_drvdat.dmacfgtx.src_bsize = DMAC_CHAN_SRC_BURST_8;
+	lpc32xx_drvdat.dmacfgtx.src_prph = DMAC_SRC_PERIP(DMA_PERID_SDCARD);
+	lpc32xx_drvdat.dmacfgtx.dst_size = 4;
+	lpc32xx_drvdat.dmacfgtx.dst_inc = 0;
+	lpc32xx_drvdat.dmacfgtx.dst_ahb1 = 0;
+	lpc32xx_drvdat.dmacfgtx.dst_bsize = DMAC_CHAN_DEST_BURST_8;
+	lpc32xx_drvdat.dmacfgtx.dst_prph = DMAC_DEST_PERIP(DMA_PERID_SDCARD);
+	lpc32xx_drvdat.dmacfgtx.flowctrl = DMAC_CHAN_FLOW_P_M2P;
+	if (lpc32xx_dma_ch_get(&lpc32xx_drvdat.dmacfgtx, "dma_sd_tx",
+				NULL, NULL) < 0) {
+		dev_err(lpc32xx_drvdat.dev, "Error setting up SD card TX DMA channel\n");
+		ret = -ENODEV;
+		goto dma_no_txch;
+	}
+
+	/* Allocate a linked list for DMA support */
+	llptrtx = lpc32xx_dma_alloc_llist(lpc32xx_drvdat.dmacfgtx.ch, NR_SG * 2);
+	if (llptrtx == 0) {
+		dev_err(lpc32xx_drvdat.dev, "Error allocating list buffer (MMC TX)\n");
+		ret = -ENOMEM;
+		goto dma_no_txlist;
+	}
+
+	/* Setup RX DMA channel */
+	lpc32xx_drvdat.dmacfgrx.ch = DMA_CH_SDCARD_RX;
+	lpc32xx_drvdat.dmacfgrx.tc_inten = 0;
+	lpc32xx_drvdat.dmacfgrx.err_inten = 0;
+	lpc32xx_drvdat.dmacfgrx.src_size = 4;
+	lpc32xx_drvdat.dmacfgrx.src_inc = 0;
+	lpc32xx_drvdat.dmacfgrx.src_ahb1 = 0;
+	lpc32xx_drvdat.dmacfgrx.src_bsize = DMAC_CHAN_SRC_BURST_8;
+	lpc32xx_drvdat.dmacfgrx.src_prph = DMAC_SRC_PERIP(DMA_PERID_SDCARD);
+	lpc32xx_drvdat.dmacfgrx.dst_size = 4;
+	lpc32xx_drvdat.dmacfgrx.dst_inc = 1;
+	lpc32xx_drvdat.dmacfgrx.dst_ahb1 = 0;
+	lpc32xx_drvdat.dmacfgrx.dst_bsize = DMAC_CHAN_DEST_BURST_8;
+	lpc32xx_drvdat.dmacfgrx.dst_prph = DMAC_DEST_PERIP(DMA_PERID_SDCARD);
+	lpc32xx_drvdat.dmacfgrx.flowctrl = DMAC_CHAN_FLOW_D_P2M;
+	if (lpc32xx_dma_ch_get(&lpc32xx_drvdat.dmacfgrx, "dma_sd_rx", NULL,
+				NULL) < 0) {
+		dev_err(lpc32xx_drvdat.dev, "Error setting up SD card RX DMA channel\n");
+		ret = -ENODEV;
+		goto dma_no_rxch;
+	}
+
+	/* Allocate a linked list for DMA support */
+	llptrrx = lpc32xx_dma_alloc_llist(lpc32xx_drvdat.dmacfgrx.ch, NR_SG * 2);
+	if (llptrrx == 0) {
+		dev_err(lpc32xx_drvdat.dev, "Error allocating list buffer (MMC RX)\n");
+		ret = -ENOMEM;
+		goto dma_no_rxlist;
+	}
+
+	return 0;
+
+dma_no_rxlist:
+	lpc32xx_dma_ch_put(lpc32xx_drvdat.dmacfgrx.ch);
+	lpc32xx_drvdat.dmacfgrx.ch = -1;
+dma_no_rxch:
+	lpc32xx_dma_dealloc_llist(lpc32xx_drvdat.dmacfgtx.ch);
+dma_no_txlist:
+	lpc32xx_dma_ch_put(lpc32xx_drvdat.dmacfgtx.ch);
+	lpc32xx_drvdat.dmacfgtx.ch = -1;
+dma_no_txch:
+	dma_free_coherent(lpc32xx_drvdat.dev, DMA_BUFF_SIZE,
+			lpc32xx_drvdat.dma_v_base, lpc32xx_drvdat.dma_handle_tx);
+dma_no_tx_buff:
+	return ret;
+}
+
+static void mmc_dma_dealloc(void)
+{
+	lpc32xx_dma_dealloc_llist(lpc32xx_drvdat.dmacfgrx.ch);
+	lpc32xx_dma_ch_put(lpc32xx_drvdat.dmacfgrx.ch);
+	lpc32xx_drvdat.dmacfgrx.ch = -1;
+	lpc32xx_dma_dealloc_llist(lpc32xx_drvdat.dmacfgtx.ch);
+	lpc32xx_dma_ch_put(lpc32xx_drvdat.dmacfgtx.ch);
+	lpc32xx_drvdat.dmacfgtx.ch = -1;
+	dma_free_coherent(lpc32xx_drvdat.dev, DMA_BUFF_SIZE,
+			lpc32xx_drvdat.dma_v_base, lpc32xx_drvdat.dma_handle_tx);
+}
+
+/* Supports scatter/gather */
+static void mmc_dma_rx_start(struct mmci_host *host)
+{
+	unsigned int len;
+	int i, dma_len;
+	struct scatterlist *sg;
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *reqdata = mrq->data;
+	void *dmaaddr;
+	u32 dmalen, dmaxferlen;
+
+	sg = reqdata->sg;
+	len = reqdata->sg_len;
+
+	dma_len = dma_map_sg(mmc_dev(host->mmc), reqdata->sg, reqdata->sg_len,
+			DMA_FROM_DEVICE);
+	if (dma_len == 0)
+		return;
+
+	/* Setup transfer */
+	for (i = 0; i < len; i++) {
+		dmalen = (u32) sg_dma_len(&sg[i]);
+		dmaaddr = (void *) sg_dma_address(&sg[i]);
+
+		/* Build a list with a max size if 15872 bytes per seg */
+		while (dmalen > 0) {
+			dmaxferlen = dmalen;
+			if (dmaxferlen > 15872)
+				dmaxferlen = 15872;
+
+			lpc32xx_dma_queue_llist_entry(lpc32xx_drvdat.lastch,
+				(void *) SD_FIFO(LPC32XX_SD_BASE),
+				dmaaddr, dmaxferlen);
+
+				dmaaddr += dmaxferlen;
+				dmalen -= dmaxferlen;
+		}
+	}
+
+//printk("DMARX %d\n", len);
+}
+
+/* May need to reorganize buffer for scatter/gather */
+static void mmc_dma_tx_start(struct mmci_host *host)
+{
+	unsigned int len;
+	int dma_len;
+	struct scatterlist *sg;
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *reqdata = mrq->data;
+	struct sg_mapping_iter *sg_miter = &host->sg_miter;
+	void *dmaaddr;
+	char *src_buffer, *dst_buffer;
+	unsigned long flags;
+
+	sg = reqdata->sg;
+	len = reqdata->sg_len;
+
+	/* Only 1 segment? */
+	if (len == 1) {
+		dma_len = dma_map_sg(mmc_dev(host->mmc), reqdata->sg,
+			reqdata->sg_len, DMA_TO_DEVICE);
+		if (dma_len == 0)
+			return;
+
+		dmaaddr = (void *) sg_dma_address(&sg[0]);
+		lpc32xx_drvdat.mapped = 1;
+	}
+	else {
+		/* Move data to contiguous buffer first, then transfer it */
+		dst_buffer = (char *) lpc32xx_drvdat.dma_v_base;
+		local_irq_save(flags);
+		do
+		{
+			/*
+			 * Map the current scatter buffer, copy data, and unmap
+			 */
+			if (!sg_miter_next(sg_miter))
+				break;
+
+			src_buffer = sg_miter->addr;
+			memcpy(dst_buffer, src_buffer, sg_miter->length);
+			dst_buffer += sg_miter->length;
+		} while (1);
+
+		sg_miter_stop(sg_miter);
+		local_irq_restore(flags);
+		lpc32xx_drvdat.mapped = 0;
+		dmaaddr = (void *) lpc32xx_drvdat.dma_handle_tx;
+	}
+
+	lpc32xx_dma_start_pflow_xfer(DMA_CH_SDCARD_TX, dmaaddr,
+		(void *) SD_FIFO(LPC32XX_SD_BASE), 1);
+}
+#endif
 
 /**
  * struct variant_data - MMCI variant-specific quirks
@@ -129,7 +375,7 @@ static void mmci_set_clkreg(struct mmci_host *host, unsigned int desired)
 		clk |= variant->clkreg_enable;
 		clk |= MCI_CLK_ENABLE;
 		/* This hasn't proven to be worthwhile */
-		/* clk |= MCI_CLK_PWRSAVE; */
+		clk |= MCI_CLK_PWRSAVE;
 	}
 
 	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4)
@@ -439,7 +685,7 @@ static inline int mmci_dma_start_data(struct mmci_host *host, unsigned int datac
 static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
 {
 	struct variant_data *variant = host->variant;
-	unsigned int datactrl, timeout, irqmask;
+	unsigned int datactrl, timeout, irqmask = 0;
 	unsigned long long clks;
 	void __iomem *base;
 	int blksz_bits;
@@ -463,6 +709,28 @@ static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
 	blksz_bits = ffs(data->blksz) - 1;
 	BUG_ON(1 << blksz_bits != data->blksz);
 
+#ifdef CONFIG_ARCH_LPC32XX
+	datactrl = MCI_DPSM_ENABLE | MCI_DPSM_DMAENABLE | blksz_bits << 4;
+
+	/* IRQ mode, map the SG list for CPU reading/writing */
+	mmci_init_sg(host, data);
+
+	if (data->flags & MMC_DATA_READ) {
+		datactrl |= MCI_DPSM_DIRECTION;
+		lpc32xx_drvdat.lastch = DMA_CH_SDCARD_RX;
+		mmc_dma_rx_start(host);
+	}
+	else {
+		lpc32xx_drvdat.lastch = DMA_CH_SDCARD_TX;
+		mmc_dma_tx_start(host);
+	}
+
+	writel(datactrl, base + MMCIDATACTRL);
+	datactrl = readl(base + MMCIMASK0) & ~MCI_DATABLOCKENDMASK;
+	writel(datactrl | MCI_DATAENDMASK, base + MMCIMASK0);
+	mmci_set_mask1(host, irqmask);
+
+#else
 	datactrl = MCI_DPSM_ENABLE | blksz_bits << 4;
 
 	if (data->flags & MMC_DATA_READ)
@@ -504,6 +772,7 @@ static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
 	writel(datactrl, base + MMCIDATACTRL);
 	writel(readl(base + MMCIMASK0) & ~MCI_DATAENDMASK, base + MMCIMASK0);
 	mmci_set_mask1(host, irqmask);
+#endif
 }
 
 static void
@@ -542,9 +811,11 @@ mmci_data_irq(struct mmci_host *host, struct mmc_data *data,
 	if (status & (MCI_DATACRCFAIL|MCI_DATATIMEOUT|MCI_TXUNDERRUN|MCI_RXOVERRUN)) {
 		u32 remain, success;
 
+#ifndef CONFIG_ARCH_LPC32XX
 		/* Terminate the DMA transfer */
 		if (dma_inprogress(host))
 			mmci_dma_data_error(host);
+#endif
 
 		/*
 		 * Calculate how far we are into the transfer.  Note that
@@ -580,8 +851,22 @@ mmci_data_irq(struct mmci_host *host, struct mmc_data *data,
 		dev_err(mmc_dev(host->mmc), "stray MCI_DATABLOCKEND interrupt\n");
 
 	if (status & MCI_DATAEND || data->error) {
+#ifdef CONFIG_ARCH_LPC32XX
+		if (data->flags & MMC_DATA_READ) {
+			lpc32xx_dma_force_burst(lpc32xx_drvdat.lastch, DMA_PERID_SDCARD);
+			lpc32xx_dma_flush_llist(lpc32xx_drvdat.lastch);
+			dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, DMA_FROM_DEVICE);
+		}
+		else {
+			lpc32xx_dma_ch_disable(lpc32xx_drvdat.lastch);
+			if (lpc32xx_drvdat.mapped)
+				dma_unmap_sg(mmc_dev(host->mmc), data->sg,
+					data->sg_len, DMA_TO_DEVICE);
+		}
+#else
 		if (dma_inprogress(host))
 			mmci_dma_unmap(host, data);
+#endif
 		mmci_stop_data(host);
 
 		if (!data->error)
@@ -1088,12 +1373,21 @@ static int __devinit mmci_probe(struct amba_device *dev,
 	 */
 	mmc->max_segs = NR_SG;
 
+#ifdef CONFIG_ARCH_LPC32XX
+	/*
+	 * The LPC32x0 DMA controller can handle up to a 65535 byte DMA
+	 * transfer. We'll rely on the mmc core to make sure the passed
+	 * size for a request is block aligned.
+	 */
+	mmc->max_seg_size = 65535;
+#else
 	/*
 	 * Since only a certain number of bits are valid in the data length
 	 * register, we must ensure that we don't exceed 2^num-1 bytes in a
 	 * single request.
 	 */
 	mmc->max_req_size = (1 << variant->datalength_bits) - 1;
+#endif
 
 	/*
 	 * Set the maximum segment size.  Since we aren't doing DMA
@@ -1111,6 +1405,17 @@ static int __devinit mmci_probe(struct amba_device *dev,
 	 */
 	mmc->max_blk_count = mmc->max_req_size;
 
+#ifdef CONFIG_ARCH_LPC32XX
+	/*
+	 * Setup DMA for the interface
+	 */
+	lpc32xx_drvdat.dev = &dev->dev;
+	if (mmc_dma_setup()) {
+		dev_err(&dev->dev, "error in setting up DMA \n");
+		goto irq0_free;
+	}
+#endif
+
 	spin_lock_init(&host->lock);
 
 	writel(0, host->base + MMCIMASK0);
@@ -1168,7 +1473,9 @@ static int __devinit mmci_probe(struct amba_device *dev,
 		 amba_rev(dev), (unsigned long long)dev->res.start,
 		 dev->irq[0], dev->irq[1]);
 
+#ifndef CONFIG_ARCH_LPC32XX
 	mmci_dma_setup(host);
+#endif
 
 	mmc_add_host(mmc);
 
@@ -1215,7 +1522,10 @@ static int __devexit mmci_remove(struct amba_device *dev)
 		writel(0, host->base + MMCICOMMAND);
 		writel(0, host->base + MMCIDATACTRL);
 
+#ifndef CONFIG_ARCH_LPC32XX
 		mmci_dma_release(host);
+#endif
+
 		free_irq(dev->irq[0], host);
 		if (!host->singleirq)
 			free_irq(dev->irq[1], host);
@@ -1227,6 +1537,10 @@ static int __devexit mmci_remove(struct amba_device *dev)
 		if (host->gpio_cd != -ENOSYS)
 			gpio_free(host->gpio_cd);
 
+#ifdef CONFIG_ARCH_LPC32XX
+		mmc_dma_dealloc();
+#endif
+
 		iounmap(host->base);
 		clk_disable(host->clk);
 		clk_put(host->clk);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index edec457..3f6d013 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -399,6 +399,13 @@ config MTD_NAND_PXA3xx
 	  This enables the driver for the NAND flash device found on
 	  PXA3xx processors
 
+config MTD_NAND_SLC_LPC32XX
+	bool "Support for NAND Flash on the LPC32XX"
+	depends on ARCH_LPC32XX
+	help
+		Enables support for NAND Flash using the LPC32XX SLC NAND 
+		controller.
+
 config MTD_NAND_CM_X270
 	tristate "Support for NAND Flash on CM-X270 modules"
 	depends on MACH_ARMCORE
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 5745d83..91a9c2b 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -32,6 +32,7 @@ obj-$(CONFIG_MTD_NAND_GPIO)		+= gpio.o
 obj-$(CONFIG_MTD_NAND_OMAP2) 		+= omap2.o
 obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx270_nand.o
 obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
+obj-$(CONFIG_MTD_NAND_SLC_LPC32XX) += lpc32xx_nand.o
 obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
 obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
 obj-$(CONFIG_MTD_ALAUDA)		+= alauda.o
diff --git a/drivers/mtd/nand/lpc32xx_nand.c b/drivers/mtd/nand/lpc32xx_nand.c
new file mode 100644
index 0000000..694ff97
--- /dev/null
+++ b/drivers/mtd/nand/lpc32xx_nand.c
@@ -0,0 +1,1098 @@
+/*
+ * drivers/mtd/nand/lpc32xx_nand.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2011 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/nand_ecc.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/slcnand.h>
+#include <mach/dmac.h>
+#include <mach/dma.h>
+
+#define LPC32XX_MODNAME			"lpc32xx-nand"
+
+/*
+ * DMA requires storage space for the DMA local buffer and the hardware ECC
+ * storage area. The DMA local buffer is only used if DMA mapping fails
+ * during runtime.
+ */
+#define LPC32XX_DMA_DATA_SIZE		4096
+#define LPC32XX_ECC_SAVE_SIZE		((4096 / 256) * 4)
+
+/* Number of bytes used for ECC stored in NAND per 256 bytes */
+#define LPC32XX_SLC_DEV_ECC_BYTES	3
+
+/*
+ * 2 DMA descriptors are needed for every 256 byte data transfer, 1 descriptor
+ * is for the data, and the other is for the saved ECC data. These are not
+ * needed for OOB data.
+ */
+#define LPC32XX_MAX_DMA_DESCRIPTORS	(((4096 / 256) * 2) + 1)
+
+/*
+ * If the NAND base clock frequency can't be fetched, this frequency will be
+ * used instead as the base. This rate is used to setup the timing registers
+ * used for NAND accesses.
+ */
+#define LPC32XX_DEF_BUS_RATE		133250000
+
+/* DMA transfer completion failure timeout */
+#define LPC32XX_DMA_WAIT_TIMEOUT_MS	20
+
+/*
+ * This timeout is used for verifying the NAND buffer has commited it's
+ * FIFO to memory or FLASH, or verifying the DMA transfer has completed.
+ * The timeout is used as a count for simple polled checks of the hardware.
+ * For most hardware, the actual timeouts are much lower than this, but
+ * very slow hardware may use most of this time.
+ */
+#define LPC32XX_DMA_SIMPLE_TIMEOUT	10000
+
+/*
+ * This is the number of reads of the ECC register after a DMA write to
+ * the NAND device. On writes, the DMA data is buffered in the NAND controller
+ * prior to ECC calculation, so the DMA transfer 'completes' prior to the
+ * NAND controller completing the transfer and ECC calculation for the write
+ * data. Because of this, the initial reads of the ECC register by the DMA
+ * controller may be incorrect as the data is still in transfer, so multiple
+ * reads are needed. With very slow NAND devices, this count may need to be
+ * increased. This doesn't apply to read operations.
+ */
+#define LPC32XX_DMA_ECC_REP_READ	10
+
+/*
+ * NAND ECC Layout for small page NAND devices
+ * Note: For large and huge page devices, the default layouts are used
+ */
+static struct nand_ecclayout lpc32xx_nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = {10, 11, 12, 13, 14, 15},
+	.oobfree = {
+	        {.offset = 0,
+	         . length = 4},
+	        {.offset = 6,
+	         . length = 4}}
+};
+
+static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+/*
+ * Small page FLASH BBT descriptors, marker at offset 0, version at offset 6
+ * Note: Large page devices used the default layout
+ */
+static struct nand_bbt_descr bbt_smallpage_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 4,
+	.veroffs = 6,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_smallpage_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 4,
+	.veroffs = 6,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+struct lpc32xx_nand_host {
+	struct nand_chip	nand_chip;
+	struct clk		*clk;
+	struct mtd_info		mtd;
+	void __iomem		*io_base;
+	struct lpc32XX_nand_cfg	*ncfg;
+
+	wait_queue_head_t	dma_waitq;
+	volatile u32		dmapending;
+	struct dma_config	dmacfg;
+	int			dmach;
+	volatile uint32_t	dma_xfer_status;
+	uint32_t		llptr;
+	uint32_t		dma_buf_len;
+	/*
+	 * DMA and CPU addresses of ECC work area and data buffer
+	 */
+	dma_addr_t		ecc_buf_dma;
+	uint32_t		*ecc_buf;
+	dma_addr_t		data_buf_dma;
+	uint8_t			*data_buf;
+	dma_addr_t		io_base_dma;
+};
+
+static void lpc32xx_nand_setup(struct lpc32xx_nand_host *host)
+{
+	u32 clkrate, tmp;
+
+	/* Reset SLC controller */
+	__raw_writel(SLCCTRL_SW_RESET, SLC_CTRL(host->io_base));
+	udelay(1000);
+
+	/* Basic setup */
+	__raw_writel(0, SLC_CFG(host->io_base));
+	__raw_writel(0, SLC_IEN(host->io_base));
+	__raw_writel((SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN),
+		SLC_ICR(host->io_base));
+
+	/* Get base clock for SLC block */
+	clkrate = clk_get_rate(host->clk);
+	if (clkrate == 0)
+		clkrate = LPC32XX_DEF_BUS_RATE;
+
+	/* Compute clock setup values */
+	tmp = SLCTAC_WDR(host->ncfg->wdr_clks) |
+		SLCTAC_WWIDTH(1 + (clkrate / host->ncfg->wwidth)) |
+		SLCTAC_WHOLD(1 + (clkrate / host->ncfg->whold)) |
+		SLCTAC_WSETUP(1 + (clkrate / host->ncfg->wsetup)) |
+		SLCTAC_RDR(host->ncfg->rdr_clks) |
+		SLCTAC_RWIDTH(1 + (clkrate / host->ncfg->rwidth)) |
+		SLCTAC_RHOLD(1 + (clkrate / host->ncfg->rhold)) |
+		SLCTAC_RSETUP(1 + (clkrate / host->ncfg->rsetup));
+	__raw_writel(tmp, SLC_TAC(host->io_base));
+}
+
+/*
+ * Hardware specific access to control lines
+ */
+static void lpc32xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+	unsigned int ctrl)
+{
+	u32 tmp;
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+
+	/* Does CE state need to be changed? */
+	tmp = __raw_readl(SLC_CFG(host->io_base));
+	if (ctrl & NAND_NCE)
+		tmp |= SLCCFG_CE_LOW;
+	else
+		tmp &= ~SLCCFG_CE_LOW;
+	__raw_writel(tmp, SLC_CFG(host->io_base));
+
+	if (cmd != NAND_CMD_NONE) {
+		if (ctrl & NAND_CLE)
+			__raw_writel(cmd, SLC_CMD(host->io_base));
+		else
+			__raw_writel(cmd, SLC_ADDR(host->io_base));
+	}
+}
+
+/*
+ * Read the Device Ready pin
+ */
+static int lpc32xx_nand_device_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+	int rdy = 0;
+
+	if ((__raw_readl(SLC_STAT(host->io_base)) & SLCSTAT_NAND_READY) != 0)
+		rdy = 1;
+
+	return rdy;
+}
+
+/*
+ * Enable NAND write protect
+ */
+static void lpc32xx_wp_enable(struct lpc32xx_nand_host *host)
+{
+	if (host->ncfg->enable_write_prot != NULL)
+		/* Disable write protection */
+		host->ncfg->enable_write_prot(1);
+}
+
+/*
+ * Disable NAND write protect
+ */
+static void lpc32xx_wp_disable(struct lpc32xx_nand_host *host)
+{
+	if (host->ncfg->enable_write_prot != NULL)
+		/* Enable write protection */
+		host->ncfg->enable_write_prot(0);
+}
+
+/*
+ * Prepares SLC for transfers with H/W ECC enabled
+ */
+static void lpc32xx_nand_ecc_enable(struct mtd_info *mtd, int mode)
+{
+	(void)mtd;
+	(void)mode;
+
+	/* Hardware ECC is enabled automatically in hardware as needed */
+}
+
+/*
+ * Calculates the ECC for the data
+ */
+static int lpc32xx_nand_ecc_calculate(struct mtd_info *mtd,
+	const unsigned char *buf, unsigned char *code)
+{
+	(void) mtd;
+	(void) buf;
+	(void) code;
+
+	/*
+	 * ECC is calculated automatically in hardware during syndrome read
+	 * and write operations, so it doesn't need to be calculated here.
+	 */
+
+	return 0;
+}
+
+/*
+ * Read a single byte from NAND device
+ */
+static uint8_t lpc32xx_nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+
+	return (uint8_t) __raw_readl(SLC_DATA(host->io_base));
+}
+
+/*
+ * Simple device read without ECC
+ */
+static void lpc32xx_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+
+	/* Direct device read with no ECC */
+	while (len-- > 0)
+		*buf++ = (uint8_t) __raw_readl(SLC_DATA(host->io_base));
+}
+
+/*
+ * Simple device write without ECC
+ */
+static void lpc32xx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
+	int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+
+	/* Direct device write with no ECC */
+	while (len-- > 0)
+		__raw_writel((u32) *buf++, SLC_DATA(host->io_base));
+}
+
+/*
+ * Verify data in buffer to data on device
+ */
+static int lpc32xx_verify_buf(struct mtd_info *mtd, const uint8_t *buf,
+	int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+	int i;
+
+	/* DATA register must be read as 32 bits or it will fail */
+	for (i = 0; i < len; i++) {
+		if (buf[i] != (uint8_t) __raw_readl(SLC_DATA(host->io_base)))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*
+ * Read the OOB data from the device without ECC using FIFO method
+ */
+static int lpc32xx_nand_read_oob_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, int page, int sndcmd)
+{
+	(void)page;
+
+	if (sndcmd) {
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+		sndcmd = 0;
+	}
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return sndcmd;
+}
+
+/*
+ * Write the OOB data to the device without ECC using FIFO method
+ */
+static int lpc32xx_nand_write_oob_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, int page)
+{
+	int status;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/*
+ * Fills in the ECC fields in the OOB buffer with the hardware generated ECC
+ */
+static void lpc32xx_slc_ecc_copy(uint8_t *spare, const uint32_t *ecc,
+	int count)
+{
+	int i;
+
+	for (i = 0; i < (count * 3); i += 3) {
+		uint32_t ce = ecc[i / 3];
+		ce = ~(ce << 2) & 0xFFFFFF;
+		spare[i + 2] = (uint8_t)(ce & 0xFF);
+		ce >>= 8;
+		spare[i + 1] = (uint8_t)(ce & 0xFF);
+		ce >>= 8;
+		spare[i] = (uint8_t)(ce & 0xFF);
+	}
+}
+
+/*
+ * Configure DMA descriptors and enable DMA channel for data and ECC reads
+ */
+static void lpc32xx_nand_dma_configure(struct mtd_info *mtd,
+	dma_addr_t databuf, int eccsubpages, int read)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+	uint32_t ecc_ctrl, *ecc_buf;
+	uint32_t dataaddr, data_ctrl;
+	int i;
+
+	/* DMA buffer pointer for calculated ECC values */
+	ecc_buf = (uint32_t *)host->ecc_buf_dma;
+
+	/*
+	 * ctrl descriptor entry for reading ECC
+	 */
+	ecc_ctrl = DMAC_CHAN_SRC_BURST_1 |
+		DMAC_CHAN_DEST_BURST_1 |
+		DMAC_CHAN_SRC_WIDTH_32 |
+		DMAC_CHAN_DEST_WIDTH_32 |
+		DMAC_CHAN_DEST_AHB1;
+
+	/* data descriptor entry for reading/writing data */
+	data_ctrl = ((mtd->writesize / eccsubpages) / 4) |
+		DMAC_CHAN_SRC_BURST_4 |
+		DMAC_CHAN_DEST_BURST_4 |
+		DMAC_CHAN_SRC_WIDTH_32 |
+		DMAC_CHAN_DEST_WIDTH_32 |
+		DMAC_CHAN_DEST_AHB1;
+
+	if (read) {
+		data_ctrl |= DMAC_CHAN_DEST_AUTOINC;
+		ecc_ctrl |= DMAC_CHAN_TRANSFER_SIZE(1);
+	} else {
+		data_ctrl |= DMAC_CHAN_SRC_AUTOINC;
+		ecc_ctrl |= DMAC_CHAN_TRANSFER_SIZE(LPC32XX_DMA_ECC_REP_READ);
+	}
+
+	/*
+	 * Only transfer the data areas plus ECC from hardware. The last ECC
+	 * from hardware and OOB area will be transferred later.
+	 */
+	dataaddr = (uint32_t)databuf;
+
+	for (i = 0; i < eccsubpages; i++) {
+		if ((i == (eccsubpages - 1)) &&
+			(!host->ncfg->polled_completion))
+			data_ctrl |= DMAC_CHAN_INT_TC_EN;
+
+		if (read)
+			lpc32xx_dma_queue_llist(host->dmach,
+				(void *)SLC_DMA_DATA(host->io_base_dma),
+				(void *)dataaddr, -1, data_ctrl);
+		else
+			lpc32xx_dma_queue_llist(host->dmach, (void *)dataaddr,
+				(void *)SLC_DMA_DATA(host->io_base_dma), -1,
+				data_ctrl);
+
+		dataaddr += (uint32_t)chip->ecc.size;;
+
+		if (i != (eccsubpages - 1)) {
+			lpc32xx_dma_queue_llist(host->dmach,
+				(void *)SLC_ECC(host->io_base_dma),
+				(void *)ecc_buf, -1, ecc_ctrl);
+			ecc_buf++;;
+		}
+	}
+}
+
+/*
+ * DMA read/write transfers with ECC support
+ */
+static int lpc32xx_dma_xfer(struct mtd_info *mtd, uint8_t *buf,
+	int eccsubpages, int read)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+	uint32_t config, tmpreg;
+	dma_addr_t buf_phy;
+	int i, timeout, dma_mapped = 0, status = 0;
+
+	/* Map DMA buffer */
+	if (likely((void *) buf < high_memory)) {
+		buf_phy = dma_map_single(mtd->dev.parent, buf, mtd->writesize,
+			read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+		if (unlikely(dma_mapping_error(mtd->dev.parent, buf_phy))) {
+			dev_err(mtd->dev.parent,
+				"Unable to map DMA buffer\n");
+			dma_mapped = 0;
+		} else
+			dma_mapped = 1;
+	}
+
+	/* If a buffer can't be mapped, use the local buffer */
+	if (!dma_mapped) {
+		buf_phy = host->data_buf_dma;
+		if (!read)
+			memcpy(host->data_buf, buf, mtd->writesize);
+	}
+
+	if (read)
+		config = DMAC_CHAN_ITC | DMAC_CHAN_IE | DMAC_CHAN_FLOW_D_P2M |
+			DMAC_DEST_PERIP (0) |
+			DMAC_SRC_PERIP(DMA_PERID_NAND1) | DMAC_CHAN_ENABLE;
+	else
+		config = DMAC_CHAN_ITC | DMAC_CHAN_IE | DMAC_CHAN_FLOW_D_M2P |
+			DMAC_DEST_PERIP(DMA_PERID_NAND1) |
+			DMAC_SRC_PERIP (0) | DMAC_CHAN_ENABLE;
+
+	/* DMA mode with ECC enabled */
+	tmpreg = __raw_readl(SLC_CFG(host->io_base));
+	__raw_writel(SLCCFG_ECC_EN | SLCCFG_DMA_ECC | tmpreg,
+		SLC_CFG(host->io_base));
+
+	/* Clear initial ECC */
+	__raw_writel(SLCCTRL_ECC_CLEAR, SLC_CTRL(host->io_base));
+
+	/* Prepare DMA descriptors */
+	lpc32xx_nand_dma_configure(mtd, buf_phy, chip->ecc.steps, read);
+
+	/* Setup DMA direction and burst mode */
+	if (read)
+		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) |
+			SLCCFG_DMA_DIR, SLC_CFG(host->io_base));
+	else
+		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) &
+			~SLCCFG_DMA_DIR, SLC_CFG(host->io_base));
+	__raw_writel(__raw_readl(SLC_CFG(host->io_base)) | SLCCFG_DMA_BURST,
+		SLC_CFG(host->io_base));
+
+	/* Transfer size is data area only */
+	__raw_writel(mtd->writesize, SLC_TC(host->io_base));
+
+	/* Start transfer in the NAND controller */
+	__raw_writel(__raw_readl(SLC_CTRL(host->io_base)) | SLCCTRL_DMA_START,
+		SLC_CTRL(host->io_base));
+
+	/* Start DMA to process NAND controller DMA FIFO */
+	host->dmapending = 0;
+	lpc32xx_dma_start_xfer(host->dmach, config);
+
+	/*
+	 * On some systems, the DMA transfer will be very fast, so there is no
+	 * point in waiting for the transfer to complete using the interrupt
+	 * method. It's best to just poll the transfer here to prevent several
+	 * costly context changes. This is especially true for systems that
+	 * use small page devices or NAND devices with very fast access.
+	 */
+	if (host->ncfg->polled_completion) {
+		timeout = LPC32XX_DMA_SIMPLE_TIMEOUT;
+		while ((timeout > 0) && lpc32xx_dma_is_active(host->dmach))
+			timeout--;
+		if (timeout == 0) {
+			dev_err(mtd->dev.parent,
+				"DMA transfer timeout error\n");
+			status = -EIO;
+
+			/* Switch to non-polled mode */
+			host->ncfg->polled_completion = false;
+		}
+	}
+
+	if (!host->ncfg->polled_completion) {
+		/* Wait till DMA transfer is done or timeout occurs */
+		wait_event_timeout(host->dma_waitq, host->dmapending,
+			msecs_to_jiffies(LPC32XX_DMA_WAIT_TIMEOUT_MS));
+		if (host->dma_xfer_status != 0) {
+			dev_err(mtd->dev.parent, "DMA transfer error\n");
+			status = -EIO;
+		}
+	}
+
+	/*
+	 * The DMA is finished, but the NAND controller may still have
+	 * buffered data. Wait until all the data is sent.
+	 */
+	timeout = LPC32XX_DMA_SIMPLE_TIMEOUT;
+	while ((__raw_readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO)
+		&& (timeout > 0))
+		timeout--;
+	if (timeout == 0) {
+		dev_err(mtd->dev.parent, "FIFO held data too long\n");
+		status = -EIO;
+	}
+
+	/* Read last calculated ECC value */
+	if (read)
+		host->ecc_buf[chip->ecc.steps - 1] =
+			__raw_readl(SLC_ECC(host->io_base));
+	else {
+		for (i = 0; i < LPC32XX_DMA_ECC_REP_READ; i++)
+			host->ecc_buf[chip->ecc.steps - 1] =
+				__raw_readl(SLC_ECC(host->io_base));
+	}
+
+	/*
+	 * For reads, get the OOB data. For writes, the data will be written
+	 * later
+	 */
+	if (read)
+		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* Flush DMA link list */
+	lpc32xx_dma_flush_llist(host->dmach);
+
+	if (__raw_readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO ||
+		__raw_readl(SLC_TC(host->io_base))) {
+		/* Something is left in the FIFO, something is wrong */
+		dev_err(mtd->dev.parent, "DMA FIFO failure\n");
+		status = -EIO;
+	}
+
+	if (dma_mapped)
+		dma_unmap_single(mtd->dev.parent, buf_phy, mtd->writesize,
+			read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+	else if (read)
+		memcpy(buf, host->data_buf, mtd->writesize);
+
+	/* Stop DMA & HW ECC */
+	__raw_writel(__raw_readl(SLC_CTRL(host->io_base)) &
+		~SLCCTRL_DMA_START, SLC_CTRL(host->io_base));
+	__raw_writel(tmpreg, SLC_CFG(host->io_base));
+
+	return status;
+}
+
+/*
+ * Read the data and OOB data from the device, use ECC correction with the
+ * data, disable ECC for the OOB data
+ */
+static int lpc32xx_nand_read_page_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, uint8_t *buf, int page)
+{
+	struct lpc32xx_nand_host *host = chip->priv;
+	int stat, i, status;
+	uint8_t *oobecc, tmpecc[LPC32XX_ECC_SAVE_SIZE];
+
+	/* Issue read command */
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+
+	/* Read data and oob, calculate ECC */
+	status = lpc32xx_dma_xfer(mtd, buf, chip->ecc.steps, 1);
+
+	/* Convert to stored ECC format */
+	lpc32xx_slc_ecc_copy(tmpecc, (uint32_t *) host->ecc_buf,
+		chip->ecc.steps);
+
+	/* Pointer to ECC data retrieved from NAND spare area */
+	oobecc = chip->oob_poi + chip->ecc.layout->eccpos[0];
+
+	for (i = 0; i < chip->ecc.steps; i++) {
+		stat = chip->ecc.correct(mtd, buf, oobecc,
+			&tmpecc[i * chip->ecc.bytes]);
+		if (stat < 0)
+			mtd->ecc_stats.failed++;
+		else
+			mtd->ecc_stats.corrected += stat;
+
+		buf += chip->ecc.size;
+		oobecc += chip->ecc.bytes;
+	}
+
+	return status;
+}
+
+/*
+ * Read the data and OOB data from the device, no ECC correction with the
+ * data or OOB data
+ */
+static int lpc32xx_nand_read_page_raw_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, uint8_t *buf, int page)
+{
+	/* Issue read command */
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+
+	/* Raw reads can just use the FIFO interface */
+	chip->read_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/*
+ * Write the data and OOB data to the device, use ECC with the data,
+ * disable ECC for the OOB data
+ */
+static void lpc32xx_nand_write_page_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, const uint8_t *buf)
+{
+	struct lpc32xx_nand_host *host = chip->priv;
+	uint8_t *pb = chip->oob_poi + chip->ecc.layout->eccpos[0];
+
+	/* Write data, calculate ECC on outbound data */
+	lpc32xx_dma_xfer(mtd, (uint8_t *)buf, chip->ecc.steps, 0);
+
+	/*
+	 * The calculated ECC needs some manual work done to it before
+	 * committing it to NAND. Process the calculated ECC and place
+	 * the resultant values directly into the OOB buffer. */
+	lpc32xx_slc_ecc_copy(pb, (uint32_t *) host->ecc_buf, chip->ecc.steps);
+
+	/* Write ECC data to device */
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+
+/*
+ * Write the data and OOB data to the device, no ECC correction with the
+ * data or OOB data
+ */
+static void lpc32xx_nand_write_page_raw_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, const uint8_t *buf)
+{
+	/* Raw writes can just use the FIFO interface */
+	chip->write_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+
+/*
+ * DMA ISR - occurs when DMA transfer complete.
+ */
+static void lpc3xxx_nand_dma_irq(int channel, int cause,
+			struct lpc32xx_nand_host *host)
+{
+	host->dma_xfer_status = (cause & DMA_TC_INT) ? 0: 1;
+	host->dmapending = 1;
+	wake_up(&host->dma_waitq);
+}
+
+/*
+ * Get DMA channel and allocate DMA descriptors memory.
+ * Prepare DMA descriptors link lists
+ */
+static int lpc32xx_nand_dma_setup(struct lpc32xx_nand_host *host,
+	int num_entries)
+{
+	int ret = 0;
+
+	host->dmach = DMA_CH_SLCNAND;
+	host->dmacfg.ch = DMA_CH_SLCNAND;
+
+	/*
+	 * All the DMA configuration parameters will
+	 * be overwritten in lpc32xx_nand_dma_configure().
+	 */
+	host->dmacfg.tc_inten = 1;
+	host->dmacfg.err_inten = 1;
+	host->dmacfg.src_size = 4;
+	host->dmacfg.src_inc = 1;
+	host->dmacfg.src_ahb1 = 1;
+	host->dmacfg.src_bsize = DMAC_CHAN_SRC_BURST_4;
+	host->dmacfg.src_prph = 0;
+	host->dmacfg.dst_size = 4;
+	host->dmacfg.dst_inc = 0;
+	host->dmacfg.dst_bsize = DMAC_CHAN_DEST_BURST_4;
+	host->dmacfg.dst_ahb1 = 0;
+	host->dmacfg.dst_prph = DMAC_DEST_PERIP(DMA_PERID_NAND1);
+	host->dmacfg.flowctrl = DMAC_CHAN_FLOW_D_M2P;
+	if (lpc32xx_dma_ch_get(&host->dmacfg, LPC32XX_MODNAME,
+		&lpc3xxx_nand_dma_irq, host) < 0) {
+		dev_err(host->mtd.dev.parent, "Error setting up SLC NAND "
+			"DMA channel\n");
+		ret = -ENODEV;
+		goto dma_ch_err;
+	}
+
+	/*
+	 * Allocate Linked list of DMA Descriptors
+	 */
+	host->llptr = lpc32xx_dma_alloc_llist(host->dmach, num_entries);
+	if (host->llptr == 0) {
+		lpc32xx_dma_ch_put(host->dmach);
+		host->dmach = -1;
+		dev_err(host->mtd.dev.parent,
+			"Error allocating list buffer for SLC NAND\n");
+		ret = -ENOMEM;
+		goto dma_alloc_err;
+	}
+
+	return ret;
+dma_alloc_err:
+	lpc32xx_dma_ch_put(host->dmach);
+dma_ch_err:
+	return ret;
+}
+
+static int __init lpc32xx_add_partitions(struct lpc32xx_nand_host *host)
+{
+#ifdef CONFIG_MTD_PARTITIONS
+	struct mtd_info *mtd = &host->mtd;
+	struct mtd_partition *partitions = NULL;
+	int num_partitions = 0;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	static const char *part_probes[] = { "cmdlinepart", NULL };
+
+	mtd->name = LPC32XX_MODNAME;
+	num_partitions = parse_mtd_partitions(mtd, part_probes,
+					      &partitions, 0);
+#endif
+	if ((num_partitions <= 0) && (host->ncfg->partition_info))
+		partitions = host->ncfg->partition_info(mtd->size,
+			&num_partitions);
+
+	if ((!partitions) || (num_partitions == 0)) {
+		dev_err(mtd->dev.parent,"No parititions defined,"
+			" or unsupported device.\n");
+		return ENXIO;
+	}
+
+	return add_mtd_partitions(mtd, partitions, num_partitions);
+#else
+	return add_mtd_device(mtd);
+#endif
+}
+
+/*
+ * Probe for NAND controller
+ */
+static int __devinit lpc32xx_nand_probe(struct platform_device *pdev)
+{
+	struct lpc32xx_nand_host *host;
+	struct mtd_info *mtd;
+	struct nand_chip *chip;
+	struct resource *rc;
+	int res;
+
+	rc = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (rc == NULL) {
+		dev_err(&pdev->dev,"No memory resource found for"
+			" device\n");
+		return -ENXIO;
+	}
+
+	/* Allocate memory for the device structure (and zero it) */
+	host = kzalloc(sizeof(struct lpc32xx_nand_host), GFP_KERNEL);
+	if (!host) {
+		dev_err(&pdev->dev,"failed to allocate device structure\n");
+		return -ENOMEM;
+	}
+	host->io_base_dma = (dma_addr_t) rc->start;
+
+	host->io_base = ioremap(rc->start, rc->end - rc->start + 1);
+	if (host->io_base == NULL) {
+		dev_err(&pdev->dev,"ioremap failed\n");
+		res = -EIO;
+		goto err_exit1;
+	}
+
+	host->ncfg = pdev->dev.platform_data;
+	if (!host->ncfg) {
+		dev_err(&pdev->dev,"Missing platform data\n");
+		res = -ENOENT;
+		goto err_exit1;
+	}
+
+	mtd = &host->mtd;
+	chip = &host->nand_chip;
+	chip->priv = host;
+	mtd->priv = chip;
+	mtd->owner = THIS_MODULE;
+	mtd->dev.parent = &pdev->dev;
+
+	/* Get NAND clock */
+	host->clk = clk_get(&pdev->dev, "nand_ck");
+	if (IS_ERR(host->clk)) {
+		 dev_err(&pdev->dev,"Clock failure\n");
+		res = -ENOENT;
+		goto err_exit2;
+	}
+	clk_enable(host->clk);
+
+	/* Set NAND IO addresses and command/ready functions */
+	chip->IO_ADDR_R = SLC_DATA(host->io_base);
+	chip->IO_ADDR_W = SLC_DATA(host->io_base);
+	chip->cmd_ctrl = lpc32xx_nand_cmd_ctrl;
+	chip->dev_ready = lpc32xx_nand_device_ready;
+	chip->chip_delay = 20; /* 20us command delay time */
+
+	/* Init NAND controller */
+	lpc32xx_nand_setup(host);
+	lpc32xx_wp_disable(host);
+
+	platform_set_drvdata(pdev, host);
+
+	/* NAND callbacks for LPC32xx SLC hardware */
+	chip->ecc.mode = NAND_ECC_HW_SYNDROME;
+	chip->read_byte = lpc32xx_nand_read_byte;
+	chip->read_buf = lpc32xx_nand_read_buf;
+	chip->write_buf = lpc32xx_nand_write_buf;
+	chip->ecc.read_page_raw = lpc32xx_nand_read_page_raw_syndrome;
+	chip->ecc.read_page = lpc32xx_nand_read_page_syndrome;
+	chip->ecc.write_page_raw = lpc32xx_nand_write_page_raw_syndrome;
+	chip->ecc.write_page = lpc32xx_nand_write_page_syndrome;
+	chip->ecc.write_oob = lpc32xx_nand_write_oob_syndrome;
+	chip->ecc.read_oob = lpc32xx_nand_read_oob_syndrome;
+	chip->ecc.calculate = lpc32xx_nand_ecc_calculate;
+	chip->ecc.correct   = nand_correct_data;
+	chip->ecc.hwctl = lpc32xx_nand_ecc_enable;
+	chip->verify_buf = lpc32xx_verify_buf;
+
+	/*
+	 * Allocate a large enough buffer for a single huge page plus
+	 * extra space for the spare area and ECC storage area
+	 */
+	host->dma_buf_len = LPC32XX_DMA_DATA_SIZE + LPC32XX_ECC_SAVE_SIZE;
+	host->data_buf = dma_alloc_coherent(&pdev->dev, host->dma_buf_len,
+		&host->data_buf_dma, GFP_KERNEL);
+	if (host->data_buf == NULL) {
+		dev_err(&pdev->dev, "Error allocating memory\n");
+		res = -ENOMEM;
+		goto err_exit3;
+	}
+
+	/* Get free DMA channel and alloc DMA descriptor link list */
+	res = lpc32xx_nand_dma_setup(host, LPC32XX_MAX_DMA_DESCRIPTORS);
+	if(res) {
+		res = -EIO;
+		goto err_exit4;
+	}
+
+	init_waitqueue_head(&host->dma_waitq);
+
+	/* Find NAND device */
+	if (nand_scan_ident(mtd, 1, NULL)) {
+		res = -ENXIO;
+		goto err_exit5;
+	}
+
+	/* OOB and ECC CPU and DMA work areas */
+	host->ecc_buf_dma = host->data_buf_dma + LPC32XX_DMA_DATA_SIZE;
+	host->ecc_buf = (uint32_t *) (host->data_buf + LPC32XX_DMA_DATA_SIZE);
+
+	/*
+	 * Small page FLASH has a unique OOB layout, but large and huge
+	 * page FLASH use the standard layout. Small page FLASH uses a
+	 * custom BBT marker layout.
+	 */
+	if (mtd->writesize <= 512)
+		chip->ecc.layout = &lpc32xx_nand_oob_16;
+
+	/* These sizes remain the same regardless of page size */
+	chip->ecc.size = 256;
+	chip->ecc.bytes = LPC32XX_SLC_DEV_ECC_BYTES;
+	chip->ecc.prepad = chip->ecc.postpad = 0;
+
+	/* Avoid extra scan if using BBT, setup BBT support */
+	if (host->ncfg->use_bbt) {
+		chip->options |= NAND_USE_FLASH_BBT | NAND_SKIP_BBTSCAN;
+
+		/*
+		 * Use a custom BBT marker setup for small page FLASH that
+		 * won't interfere with the ECC layout. Large and huge page
+		 * FLASH use the standard layout.
+		 */
+		if (mtd->writesize <= 512) {
+			chip->bbt_td = &bbt_smallpage_main_descr;
+			chip->bbt_md = &bbt_smallpage_mirror_descr;
+		}
+	}
+
+	/*
+	 * Fills out all the uninitialized function pointers with the defaults
+	 */
+	if (nand_scan_tail(mtd)) {
+		res = -ENXIO;
+		goto err_exit5;
+	}
+
+	/* Standard layout in FLASH for bad block tables */
+	if (host->ncfg->use_bbt) {
+		if (nand_default_bbt(mtd) < 0)
+			dev_err(&pdev->dev, "Error initializing default bad"
+				" block tables\n");
+	}
+
+	res = lpc32xx_add_partitions(host);
+	if (!res)
+		return res;
+
+	nand_release(mtd);
+
+err_exit5:
+	/* Free the DMA channel used by us */
+	lpc32xx_dma_ch_disable(host->dmach);
+	lpc32xx_dma_dealloc_llist(host->dmach);
+	lpc32xx_dma_ch_put(host->dmach);
+	host->dmach = -1;
+err_exit4:
+	dma_free_coherent(&pdev->dev, host->dma_buf_len,
+		host->data_buf, host->data_buf_dma);
+err_exit3:
+	clk_disable(host->clk);
+	clk_put(host->clk);
+	platform_set_drvdata(pdev, NULL);
+err_exit2:
+	lpc32xx_wp_enable(host);
+	iounmap(host->io_base);
+err_exit1:
+	kfree(host);
+
+	return res;
+}
+
+/*
+ * Remove NAND device.
+ */
+static int __devexit lpc32xx_nand_remove(struct platform_device *pdev)
+{
+	u32 tmp;
+	struct lpc32xx_nand_host *host = platform_get_drvdata(pdev);
+	struct mtd_info *mtd = &host->mtd;
+
+	nand_release(mtd);
+
+	/* Free the DMA channel used by us */
+	lpc32xx_dma_ch_disable(host->dmach);
+	lpc32xx_dma_dealloc_llist(host->dmach);
+	lpc32xx_dma_ch_put(host->dmach);
+	host->dmach = -1;
+
+	dma_free_coherent(&pdev->dev, host->dma_buf_len,
+		host->data_buf, host->data_buf_dma);
+
+	/* Force CE high */
+	tmp = __raw_readl(SLC_CTRL(host->io_base));
+	tmp &= ~SLCCFG_CE_LOW;
+	__raw_writel(tmp, SLC_CTRL(host->io_base));
+
+	lpc32xx_wp_enable(host);
+	clk_disable(host->clk);
+	clk_put(host->clk);
+
+	iounmap(host->io_base);
+
+	kfree(host);
+
+	return 0;
+}
+
+#if defined (CONFIG_PM)
+static int lpc32xx_nand_resume(struct platform_device *pdev)
+{
+	struct lpc32xx_nand_host *host = platform_get_drvdata(pdev);
+
+	/* Re-enable NAND clock */
+	clk_enable(host->clk);
+
+	/* Fresh init of NAND controller */
+	lpc32xx_nand_setup(host);
+
+	/* Disable write protect */
+	lpc32xx_wp_disable(host);
+
+	return 0;
+}
+
+static int lpc32xx_nand_suspend(struct platform_device *pdev, pm_message_t pm)
+{
+	u32 tmp;
+	struct lpc32xx_nand_host *host = platform_get_drvdata(pdev);
+
+	/* Force CE high */
+	tmp = __raw_readl(SLC_CTRL(host->io_base));
+	tmp &= ~SLCCFG_CE_LOW;
+	__raw_writel(tmp, SLC_CTRL(host->io_base));
+
+	/* Enable write protect for safety */
+	lpc32xx_wp_enable(host);
+
+	/* Disable clock */
+	clk_disable(host->clk);
+
+	return 0;
+}
+
+#else
+#define lpc32xx_nand_resume NULL
+#define lpc32xx_nand_suspend NULL
+#endif
+
+static struct platform_driver lpc32xx_nand_driver = {
+	.probe		= lpc32xx_nand_probe,
+	.remove		= __devexit_p(lpc32xx_nand_remove),
+	.resume		= lpc32xx_nand_resume,
+	.suspend	= lpc32xx_nand_suspend,
+	.driver		= {
+		.name	= LPC32XX_MODNAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lpc32xx_nand_init(void)
+{
+	return platform_driver_register(&lpc32xx_nand_driver);
+}
+
+static void __exit lpc32xx_nand_exit(void)
+{
+	platform_driver_unregister(&lpc32xx_nand_driver);
+}
+
+module_init(lpc32xx_nand_init);
+module_exit(lpc32xx_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kevin Wells(kevin.wells@nxp.com)");
+MODULE_DESCRIPTION("NAND driver for the NXP LPC32XX SLC controller");
+
diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index 6c884ef..74db259 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2008,6 +2008,14 @@ config BCM63XX_ENET
 	  This driver supports the ethernet MACs in the Broadcom 63xx
 	  MIPS chipset family (BCM63XX).
 
+config LPC_ENET
+	tristate "NXP ethernet MAC on LPC devices"
+	depends on ARCH_LPC32XX
+	select PHYLIB
+	help
+		Say Y here if you want to use the NXP ethernet MAC included
+		on some NXP LPC devices.
+
 config FTMAC100
 	tristate "Faraday FTMAC100 10/100 Ethernet support"
 	depends on ARM
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index e5a7375..4a58445 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -147,6 +147,7 @@ obj-$(CONFIG_FORCEDETH) += forcedeth.o
 obj-$(CONFIG_NE_H8300) += ne-h8300.o
 obj-$(CONFIG_AX88796) += ax88796.o
 obj-$(CONFIG_BCM63XX_ENET) += bcm63xx_enet.o
+obj-$(CONFIG_LPC_ENET) += lpc_eth.o
 obj-$(CONFIG_FTMAC100) += ftmac100.o
 
 obj-$(CONFIG_TSI108_ETH) += tsi108_eth.o
diff --git a/drivers/net/lpc_eth.c b/drivers/net/lpc_eth.c
new file mode 100644
index 0000000..75711f5
--- /dev/null
+++ b/drivers/net/lpc_eth.c
@@ -0,0 +1,1346 @@
+/*
+ * drivers/net/lpc-eth.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/crc32.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <mach/board.h>
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+#include <mach/hardware.h>
+#endif
+#include "lpc_eth.h"
+
+#define MODNAME "lpc-net"
+#define DRV_VERSION "$Revision: 1.00 $"
+#define PHYDEF_ADDR 0x00
+
+#define ENET_MAXF_SIZE 1536
+#define ENET_RX_DESC 48
+#define ENET_TX_DESC 16
+
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+extern u32 lpc32xx_return_iram_size(void);
+#endif
+
+// FIXME
+// Dynamic buffer allocation as needed
+// Check/fix ethtool support
+// Better MAC address support
+// Better DMA allocation support (dma pool)
+// MII/RMII support (only supports RMII as of now)
+
+static int lpc_net_hard_start_xmit(struct sk_buff *skb,
+	struct net_device *ndev);
+
+/*
+ * Transmit timeout, default 2.5 seconds.
+ */
+static int watchdog = 2500;
+module_param(watchdog, int, 0400);
+MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
+
+/*
+ * Default local config if board config is not defined
+ */
+static struct lpc_net_cfg __lpc_local_net_config = {
+	.phy_irq = -1,
+	.phy_mask = 0xFFFFFFF0,
+};
+
+/*
+ * Device driver data structure
+ */
+struct netdata_local {
+	struct platform_device	*pdev;
+	struct net_device	*ndev;
+	spinlock_t		lock;
+	void __iomem		*net_base;
+	unsigned long		net_region_start;
+	unsigned long		net_region_size;
+	u32			msg_enable;
+	struct sk_buff		*skb[ENET_TX_DESC];
+	unsigned int		last_tx_idx;
+	unsigned int		num_used_tx_buffs;
+	struct mii_bus		*mii_bus;
+	struct phy_device	*phy_dev;
+	struct clk		*clk;
+	u32			dma_buff_base_p;
+	u32			dma_buff_base_v;
+	u32			dma_buff_size;
+	u32			tx_desc_v [ENET_TX_DESC];
+	u32			tx_stat_v [ENET_TX_DESC];
+	u32			tx_buff_v [ENET_TX_DESC];
+	u32			rx_desc_v [ENET_RX_DESC];
+	u32			rx_stat_v [ENET_RX_DESC];
+	u32			rx_buff_v [ENET_RX_DESC];
+	struct lpc_net_cfg	*ncfg;
+	int			link;
+	int			speed;
+	int			duplex;
+};
+
+/*
+ * MAC address is provided as a boot paramter (ethaddr) via u-boot
+ */
+static u8 mac_address[6] = {0};
+
+static int __init ethaddr(char *str)
+{
+        char *s, *e;
+        int i;
+
+        s = str;
+        for (i = 0; i < 6; ++i) {
+                mac_address[i] = s ? simple_strtoul (s, &e, 16) : 0;
+                if (s)
+                        s = (*e) ? e + 1 : e;
+        }
+        return 1;
+}
+__setup("ethaddr=", ethaddr);
+
+static int get_mac_addr(u8 *mac)
+{
+        int i;
+
+        for (i = 0; i < 6; i++) {
+                mac[i] = mac_address[i];
+        }
+        return 0;
+}
+
+/*
+ * MAC support functions
+ */
+static void __lpc_set_mac(struct netdata_local *pldat, u8 *mac)
+{
+	u32 tmp;
+
+	/* Set station address */
+	tmp = (u32) mac[0] | ((u32) mac[1] << 8);
+	writel(tmp, LPC_ENET_SA2(pldat->net_base));
+	tmp = (u32) mac[2] | ((u32) mac[3] << 8);
+	writel(tmp, LPC_ENET_SA1(pldat->net_base));
+	tmp = (u32) mac[4] | ((u32) mac[5] << 8);
+	writel(tmp, LPC_ENET_SA0(pldat->net_base));
+
+	pr_debug("Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
+		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+}
+
+static void __lpc_net_clock_enable(struct netdata_local *pldat,
+	int enable)
+{
+	if (enable)
+		clk_enable(pldat->clk);
+	else
+		clk_disable(pldat->clk);
+}
+
+static void __lpc_params_setup(struct netdata_local *pldat)
+{
+	u32 tmp;
+
+	if (pldat->duplex == DUPLEX_FULL) {
+		tmp = readl(LPC_ENET_MAC2(pldat->net_base));
+		tmp |= LPC_MAC2_FULL_DUPLEX;
+		writel(tmp, LPC_ENET_MAC2(pldat->net_base));
+		tmp = readl(LPC_ENET_COMMAND(pldat->net_base));
+		tmp |= LPC_COMMAND_FULLDUPLEX;
+		writel(tmp, LPC_ENET_COMMAND(pldat->net_base));
+		writel(LPC_IPGT_LOAD(0x15), LPC_ENET_IPGT(pldat->net_base));
+	} else {
+		tmp = readl(LPC_ENET_MAC2(pldat->net_base));
+		tmp &= ~LPC_MAC2_FULL_DUPLEX;
+		writel(tmp, LPC_ENET_MAC2(pldat->net_base));
+		tmp = readl(LPC_ENET_COMMAND(pldat->net_base));
+		tmp &= ~LPC_COMMAND_FULLDUPLEX;
+		writel(tmp, LPC_ENET_COMMAND(pldat->net_base));
+		writel(LPC_IPGT_LOAD(0x12), LPC_ENET_IPGT(pldat->net_base));
+	}
+
+	if (pldat->speed == SPEED_100)
+		writel(LPC_SUPP_SPEED, LPC_ENET_SUPP(pldat->net_base));
+	else
+		writel(0, LPC_ENET_SUPP(pldat->net_base));
+}
+
+static void __lpc_eth_reset(struct netdata_local *pldat)
+{
+	/* Reset all MAC logic */
+	writel((LPC_MAC1_RESET_TX | LPC_MAC1_RESET_MCS_TX | LPC_MAC1_RESET_RX |
+		LPC_MAC1_RESET_MCS_RX | LPC_MAC1_SIMULATION_RESET |
+		LPC_MAC1_SOFT_RESET), LPC_ENET_MAC1(pldat->net_base));
+	writel((LPC_COMMAND_REG_RESET | LPC_COMMAND_TXRESET |
+		LPC_COMMAND_RXRESET), LPC_ENET_COMMAND(pldat->net_base));
+}
+
+static int __lpc_mii_mngt_reset(struct netdata_local *pldat)
+{
+	/* Reset MII management hardware */
+	writel(LPC_MCFG_RESET_MII_MGMT, LPC_ENET_MCFG(pldat->net_base));
+
+	/* Setup MII clock to slowest rate with a /28 divider */
+	writel(LPC_MCFG_CLOCK_SELECT(LPC_MCFG_CLOCK_HOST_DIV_28),
+		LPC_ENET_MCFG(pldat->net_base));
+
+	return 0;
+}
+
+static u32 __ptr_align(u32 pbuff)
+{
+	pbuff &= 0xFFFFFFF0;
+	pbuff += 0x10;
+
+	return pbuff;
+}
+
+static inline u32 __va_to_pa(u32 addr, struct netdata_local *pldat)
+{
+	u32 phaddr;
+
+	phaddr = addr - pldat->dma_buff_base_v;
+	phaddr += pldat->dma_buff_base_p;
+
+	return phaddr;
+}
+
+/* Setup TX/RX descriptors */
+static void __lpc_txrx_desc_setup(struct netdata_local *pldat)
+{
+	u32 tbuff, *ptxstat;
+	int i;
+	struct txrx_desc_t *ptxrxdesc;
+	struct rx_status_t *prxstat;
+
+	tbuff = __ptr_align(pldat->dma_buff_base_v);
+
+	/* Setup TX descriptors, status, and buffers */
+	for (i = 0; i < ENET_TX_DESC; i++) {
+		pldat->tx_desc_v [i] = tbuff;
+		tbuff += sizeof(struct txrx_desc_t);
+	}
+	for (i = 0; i < ENET_TX_DESC; i++) {
+		pldat->tx_stat_v [i] = tbuff;
+		tbuff += sizeof(u32);
+	}
+	tbuff = __ptr_align(tbuff);
+	for (i = 0; i < ENET_TX_DESC; i++) {
+		pldat->tx_buff_v [i] = tbuff;
+		tbuff += ENET_MAXF_SIZE;
+	}
+
+	/* Setup RX descriptors, status, and buffers */
+	for (i = 0; i < ENET_RX_DESC; i++) {
+		pldat->rx_desc_v [i] = tbuff;
+		tbuff += sizeof(struct txrx_desc_t);
+	}
+	tbuff = __ptr_align(tbuff);
+	for (i = 0; i < ENET_RX_DESC; i++) {
+		pldat->rx_stat_v [i] = tbuff;
+		tbuff += sizeof(struct rx_status_t);
+	}
+	tbuff = __ptr_align(tbuff);
+	for (i = 0; i < ENET_RX_DESC; i++) {
+		pldat->rx_buff_v [i] = tbuff;
+		tbuff += ENET_MAXF_SIZE;
+	}
+
+	/* Map the TX descriptors to the TX buffers in hardware */
+	for (i = 0; i < ENET_TX_DESC; i++) {
+		ptxstat = (u32 *) pldat->tx_stat_v [i];
+		ptxrxdesc = (struct txrx_desc_t *) pldat->tx_desc_v [i];
+
+		ptxrxdesc->packet = __va_to_pa(pldat->tx_buff_v [i], pldat);
+		ptxrxdesc->control = 0;
+		*ptxstat = 0;
+	}
+
+	/* Map the RX descriptors to the RX buffers in hardware */
+	for (i = 0; i < ENET_RX_DESC; i++) {
+		prxstat = (struct rx_status_t *) pldat->rx_stat_v [i];
+		ptxrxdesc = (struct txrx_desc_t *) pldat->rx_desc_v [i];
+
+		ptxrxdesc->packet = __va_to_pa(pldat->rx_buff_v [i], pldat);
+		ptxrxdesc->control = 0x80000000 | (ENET_MAXF_SIZE - 1);
+		prxstat->statusinfo = 0;
+		prxstat->statushashcrc = 0;
+	}
+
+	/* Setup base addresses in hardware to point to buffers and
+	   descriptors */
+	writel((ENET_TX_DESC - 1),
+		LPC_ENET_TXDESCRIPTORNUMBER(pldat->net_base));
+	writel(__va_to_pa(pldat->tx_desc_v [0], pldat),
+		LPC_ENET_TXDESCRIPTOR(pldat->net_base));
+	writel(__va_to_pa(pldat->tx_stat_v [0], pldat),
+		LPC_ENET_TXSTATUS(pldat->net_base));
+	writel((ENET_RX_DESC - 1),
+		LPC_ENET_RXDESCRIPTORNUMBER(pldat->net_base));
+	writel(__va_to_pa(pldat->rx_desc_v [0], pldat),
+		LPC_ENET_RXDESCRIPTOR(pldat->net_base));
+	writel(__va_to_pa(pldat->rx_stat_v [0], pldat),
+		LPC_ENET_RXSTATUS(pldat->net_base));
+}
+
+static void __lpc_eth_init(struct netdata_local *pldat)
+{
+	u32 tmp;
+
+	/* Disable controller and reset */
+	tmp = readl(LPC_ENET_COMMAND(pldat->net_base));
+	tmp &= ~LPC_COMMAND_RXENABLE | LPC_COMMAND_TXENABLE;
+	writel(tmp, LPC_ENET_COMMAND(pldat->net_base));
+	tmp = readl(LPC_ENET_MAC1(pldat->net_base));
+	tmp &= ~LPC_MAC1_RECV_ENABLE;
+	writel(tmp, LPC_ENET_MAC1(pldat->net_base));
+
+	/* Initial MAC setup */
+	writel(LPC_MAC1_PASS_ALL_RX_FRAMES, LPC_ENET_MAC1(pldat->net_base));
+	writel((LPC_MAC2_PAD_CRC_ENABLE | LPC_MAC2_CRC_ENABLE),
+		LPC_ENET_MAC2(pldat->net_base));
+	writel(ENET_MAXF_SIZE, LPC_ENET_MAXF(pldat->net_base));
+
+	/* Collision window, gap */
+	writel((LPC_CLRT_LOAD_RETRY_MAX(0xF) |
+		LPC_CLRT_LOAD_COLLISION_WINDOW(0x37)),
+		LPC_ENET_CLRT(pldat->net_base));
+	writel(LPC_IPGR_LOAD_PART2(0x12), LPC_ENET_IPGR(pldat->net_base));
+
+#if defined (CONFIG_ARCH_LPC32XX_MII_SUPPORT)
+	writel(LPC_COMMAND_PASSRUNTFRAME, LPC_ENET_COMMAND(pldat->net_base));
+#else
+	writel((LPC_COMMAND_PASSRUNTFRAME | LPC_COMMAND_RMII),
+		LPC_ENET_COMMAND(pldat->net_base));
+	writel(LPC_SUPP_RESET_RMII, LPC_ENET_SUPP(pldat->net_base));
+#endif
+
+	__lpc_params_setup(pldat);
+
+	/* Setup TX and RX descriptors */
+	__lpc_txrx_desc_setup(pldat);
+
+	/* Setup packet filtering */
+	writel((LPC_RXFLTRW_ACCEPTUBROADCAST | LPC_RXFLTRW_ACCEPTPERFECT),
+		LPC_ENET_RXFILTER_CTRL(pldat->net_base));
+
+	/* Clear and enable interrupts */
+	writel(0xFFFF, LPC_ENET_INTCLEAR(pldat->net_base));
+	writel((LPC_MACINT_RXDONEINTEN | LPC_MACINT_TXDONEINTEN),
+		LPC_ENET_INTENABLE(pldat->net_base));
+
+	/* Get the next TX buffer output index */
+	pldat->num_used_tx_buffs = 0;
+	pldat->last_tx_idx =
+		readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));
+
+	/* Enable controller */
+	tmp = readl(LPC_ENET_COMMAND(pldat->net_base));
+	tmp |= LPC_COMMAND_RXENABLE | LPC_COMMAND_TXENABLE;
+	writel(tmp, LPC_ENET_COMMAND(pldat->net_base));
+	tmp = readl(LPC_ENET_MAC1(pldat->net_base));
+	tmp |= LPC_MAC1_RECV_ENABLE;
+	writel(tmp, LPC_ENET_MAC1(pldat->net_base));
+}
+
+static void __lpc_net_shutdown(struct netdata_local *pldat)
+{
+	/* Reset ethernet and power down PHY */
+	__lpc_eth_reset(pldat);
+	writel(0, LPC_ENET_MAC1(pldat->net_base));
+	writel(0, LPC_ENET_MAC2(pldat->net_base));
+}
+
+/*
+ * MAC<--->PHY support functions
+ */
+static int lpc_mdio_read(struct mii_bus *bus, int phy_id, int phyreg)
+{
+	struct netdata_local *pldat = bus->priv;
+	unsigned long timeout = jiffies + ((HZ * 100) / 1000); /* 100mS */
+	int lps;
+
+	writel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));
+	writel(LPC_MCMD_READ, LPC_ENET_MCMD(pldat->net_base));
+
+	/* Wait for unbusy status */
+	while (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {
+		if (jiffies > timeout)
+			return -EIO;
+		cpu_relax();
+	}
+
+	lps = (int) readl(LPC_ENET_MRDD(pldat->net_base));
+	writel(0, LPC_ENET_MCMD(pldat->net_base));
+
+	return lps;
+}
+
+static int lpc_mdio_write(struct mii_bus *bus, int phy_id, int phyreg,
+			u16 phydata)
+{
+	struct netdata_local *pldat = bus->priv;
+	unsigned long timeout = jiffies + ((HZ * 100) / 1000); /* 100mS */
+
+	writel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));
+	writel(phydata, LPC_ENET_MWTD(pldat->net_base));
+
+	/* Wait for completion */
+	while (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {
+		if (jiffies > timeout)
+			return -EIO;
+		cpu_relax();
+	}
+
+	return 0;
+}
+
+static int lpc_mdio_reset(struct mii_bus *bus)
+{
+	return __lpc_mii_mngt_reset((struct netdata_local *) bus->priv);
+}
+
+static void lpc_handle_link_change(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = pldat->phy_dev;
+	unsigned long flags;
+
+	int status_change = 0;
+
+	spin_lock_irqsave(&pldat->lock, flags);
+
+	if (phydev->link) {
+		if ((pldat->speed != phydev->speed) ||
+		    (pldat->duplex != phydev->duplex)) {
+			pldat->speed = phydev->speed;
+			pldat->duplex = phydev->duplex;
+			status_change = 1;
+		}
+	}
+
+	if (phydev->link != pldat->link) {
+		if (!phydev->link) {
+			pldat->speed = 0;
+			pldat->duplex = -1;
+		}
+		pldat->link = phydev->link;
+
+		status_change = 1;
+	}
+
+	spin_unlock_irqrestore(&pldat->lock, flags);
+
+	if (status_change)
+		__lpc_params_setup(pldat);
+}
+
+static int lpc_mii_probe(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = NULL;
+	int phy_addr;
+
+	/* find the first phy */
+	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
+		if (pldat->mii_bus->phy_map[phy_addr]) {
+			phydev = pldat->mii_bus->phy_map[phy_addr];
+			break;
+		}
+	}
+
+	if (!phydev) {
+		pr_err("%s: no PHY found\n", ndev->name);
+		return -ENODEV;
+	}
+
+	/* Attach to the PHY */
+#if defined (CONFIG_ARCH_LPC32XX_MII_SUPPORT)
+	pr_info("%s: using MII interface\n", ndev->name);
+	phydev = phy_connect(ndev, dev_name(&phydev->dev),
+		&lpc_handle_link_change, 0, PHY_INTERFACE_MODE_MII);
+#else
+	pr_info("%s: using RMII interface\n", ndev->name);
+	phydev = phy_connect(ndev, dev_name(&phydev->dev),
+		&lpc_handle_link_change, 0, PHY_INTERFACE_MODE_RMII);
+#endif
+
+	if (IS_ERR(phydev)) {
+		pr_err("%s: Could not attach to PHY\n", ndev->name);
+		return PTR_ERR(phydev);
+	}
+
+	/* mask with MAC supported features */
+	phydev->supported &= PHY_BASIC_FEATURES;
+
+	phydev->advertising = phydev->supported;
+
+	pldat->link = 0;
+	pldat->speed = 0;
+	pldat->duplex = -1;
+	pldat->phy_dev = phydev;
+
+	return 0;
+}
+
+static int lpc_mii_init(struct netdata_local *pldat)
+{
+	int err = -ENXIO, i;
+
+	pldat->mii_bus = mdiobus_alloc();
+	if (!pldat->mii_bus) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	/* Setup MII mode */
+#if defined (CONFIG_ARCH_LPC32XX_MII_SUPPORT)
+	writel(LPC_COMMAND_PASSRUNTFRAME, LPC_ENET_COMMAND(pldat->net_base));
+#else
+	writel((LPC_COMMAND_PASSRUNTFRAME | LPC_COMMAND_RMII),
+		LPC_ENET_COMMAND(pldat->net_base));
+	writel(LPC_SUPP_RESET_RMII, LPC_ENET_SUPP(pldat->net_base));
+#endif
+
+	pldat->mii_bus->name = "lpc_mii_bus";
+	pldat->mii_bus->read = &lpc_mdio_read;
+	pldat->mii_bus->write = &lpc_mdio_write;
+	pldat->mii_bus->reset = &lpc_mdio_reset;
+	snprintf(pldat->mii_bus->id, MII_BUS_ID_SIZE, "%x", pldat->pdev->id);
+	pldat->mii_bus->priv = pldat;
+	pldat->mii_bus->parent = &pldat->pdev->dev;
+	pldat->mii_bus->phy_mask = 0xFFFFFFF0;
+
+	if (pldat->ncfg)
+		pldat->mii_bus->phy_mask = pldat->ncfg->phy_mask;
+
+	pldat->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	if (!pldat->mii_bus->irq) {
+		err = -ENOMEM;
+		goto err_out_1;
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		pldat->mii_bus->irq[i] = PHY_POLL;
+
+	//platform_set_drvdata(pldat->ndev, pldat->mii_bus);
+
+	if (mdiobus_register(pldat->mii_bus)) {
+		goto err_out_free_mdio_irq;
+	}
+
+	if (lpc_mii_probe(pldat->ndev) != 0) {
+		goto err_out_unregister_bus;
+	}
+
+	return 0;
+
+err_out_unregister_bus:
+	mdiobus_unregister(pldat->mii_bus);
+err_out_free_mdio_irq:
+	kfree(pldat->mii_bus->irq);
+err_out_1:
+	mdiobus_free(pldat->mii_bus);
+err_out:
+	return err;
+}
+
+static void __lpc_handle_xmit(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct sk_buff *skb;
+	unsigned int txcidx, *ptxstat, txstat;
+
+	txcidx = readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));
+	while (pldat->last_tx_idx != txcidx)
+	{
+		skb = (struct sk_buff *) pldat->skb[pldat->last_tx_idx];
+
+		/* A buffer is available, get buffer status */
+		ptxstat = (unsigned int *) pldat->tx_stat_v[pldat->last_tx_idx];
+		txstat = *ptxstat;
+
+		/* Next buffer and decrement used buffer counter */
+		pldat->num_used_tx_buffs--;
+		pldat->last_tx_idx++;
+		if (pldat->last_tx_idx >= ENET_TX_DESC)
+			pldat->last_tx_idx = 0;
+
+		/* Update collision counter */
+		ndev->stats.collisions += ((txstat >> 21) & 0xF);
+
+		/* Any errors occurred? */
+		if (txstat & 0x80000000) {
+			if (txstat & 0x20000000) {
+				/* FIFO underrun */
+				ndev->stats.tx_fifo_errors++;
+				ndev->stats.tx_errors++;
+			}
+			if (txstat & 0x10000000) {
+				/* Late collision */
+				ndev->stats.tx_aborted_errors++;
+				ndev->stats.tx_errors++;
+			}
+			if (txstat & 0x08000000) {
+				/* Excessive collision */
+				ndev->stats.tx_aborted_errors++;
+				ndev->stats.tx_errors++;
+			}
+			if (txstat & 0x04000000) {
+				/* Defer limit */
+				ndev->stats.tx_aborted_errors++;
+				ndev->stats.tx_errors++;
+			}
+
+			/* Buffer transmit failed, requeue it */
+			lpc_net_hard_start_xmit(skb, ndev);
+		} else {
+			/* Update stats */
+			ndev->stats.tx_packets++;
+			ndev->stats.tx_bytes += skb->len;
+
+			/* Free buffer */
+			dev_kfree_skb_irq(skb);
+		}
+
+		txcidx = readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));
+	}
+
+	if (netif_queue_stopped(ndev))
+		netif_wake_queue(ndev);
+}
+
+static void __lpc_handle_recv(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct sk_buff *skb;
+	int rxconsidx, len, ethst;
+	struct rx_status_t *prxstat;
+	u8 *prdbuf;
+
+	/* Get the current RX buffer indexes */
+	rxconsidx = (int) readl(LPC_ENET_RXCONSUMEINDEX(pldat->net_base));
+	while (rxconsidx != (int) readl(LPC_ENET_RXPRODUCEINDEX(pldat->net_base)))
+	{
+		/* Get pointer to receive status */
+		prxstat = (struct rx_status_t *) pldat->rx_stat_v [rxconsidx];
+		len = (prxstat->statusinfo & 0x7FF) + 1;
+
+		/* Status error? */
+		ethst = prxstat->statusinfo;
+		if ((ethst & 0xBF800000) == 0x84000000)
+			ethst &= ~0x80000000;
+
+		if (ethst & 0x80000000) {
+			/* Check statuses */
+			if (prxstat->statusinfo & (1 << 28)) {
+				/* Overrun error */
+				ndev->stats.rx_fifo_errors++;
+			} else if (prxstat->statusinfo & (1 << 23)) {
+				/* CRC error */
+				ndev->stats.rx_crc_errors++;
+			} else if (prxstat->statusinfo & (1 << 25)) {
+				/* Length error */
+				ndev->stats.rx_length_errors++;
+			} else if (prxstat->statusinfo & 0x80000000) {
+				/* Other error */
+				ndev->stats.rx_length_errors++;
+			}
+			ndev->stats.rx_errors++;
+		} else {
+			/* Packet is good */
+			skb = dev_alloc_skb(len + 8);
+			if (!skb)
+				ndev->stats.rx_dropped++;
+			else {
+				skb_reserve(skb, 8);
+				prdbuf = skb_put(skb, (len - 0));
+
+				/* Copy packer from buffer */
+				memcpy(prdbuf, (void *) pldat->rx_buff_v [rxconsidx], len);
+
+				/* Pass to upper layer */
+				skb->protocol = eth_type_trans(skb, ndev);
+				netif_rx(skb);
+				ndev->last_rx = jiffies;
+				ndev->stats.rx_packets++;
+				ndev->stats.rx_bytes += len;
+			}
+		}
+
+		/* Increment consume index */
+		rxconsidx = rxconsidx + 1;
+		if (rxconsidx >= ENET_RX_DESC)
+			rxconsidx = 0;
+		writel((u32) rxconsidx, LPC_ENET_RXCONSUMEINDEX(pldat->net_base));
+	}
+}
+
+static irqreturn_t __lpc_eth_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = dev_id;
+	struct netdata_local *pldat = netdev_priv(ndev);
+	u32 tmp;
+	unsigned long flags;
+
+	//spin_lock(&pldat->lock);
+	spin_lock_irqsave(&pldat->lock, flags);
+
+	/* Get the interrupt status */
+	tmp = readl(LPC_ENET_INTSTATUS(pldat->net_base));
+
+	while (tmp) {
+		/* Clear interrupts */
+		writel(tmp, LPC_ENET_INTCLEAR(pldat->net_base));
+
+		/* Transmit complete? */
+		if (tmp & (LPC_MACINT_TXUNDERRUNINTEN | LPC_MACINT_TXERRORINTEN |
+			LPC_MACINT_TXFINISHEDINTEN | LPC_MACINT_TXDONEINTEN))
+			__lpc_handle_xmit(ndev);
+
+		/* Receive buffer available */
+		if (tmp & (LPC_MACINT_RXOVERRUNINTEN | LPC_MACINT_RXERRORONINT |
+			LPC_MACINT_RXFINISHEDINTEN | LPC_MACINT_RXDONEINTEN))
+			__lpc_handle_recv(ndev);
+
+		/* Recheck the interrupt status */
+		tmp = readl(LPC_ENET_INTSTATUS(pldat->net_base));
+	}
+
+	//spin_unlock(&pldat->lock);
+	spin_unlock_irqrestore(&pldat->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int lpc_net_close(struct net_device *ndev)
+{
+	unsigned long flags;
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	if (netif_msg_ifdown(pldat))
+	{
+		dev_dbg(&pldat->pdev->dev, "shutting down %s\n", ndev->name);
+	}
+
+	netif_stop_queue(ndev);
+
+	if (pldat->phy_dev)
+	{
+		phy_stop(pldat->phy_dev);
+	}
+
+	spin_lock_irqsave(&pldat->lock, flags);
+	__lpc_eth_reset(pldat);
+	netif_carrier_off(ndev);
+	writel(0, LPC_ENET_MAC1(pldat->net_base));
+	writel(0, LPC_ENET_MAC2(pldat->net_base));
+	spin_unlock_irqrestore(&pldat->lock, flags);
+
+	__lpc_net_clock_enable(pldat, 0);
+
+	return 0;
+}
+
+static int lpc_net_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	unsigned int len, txidx;
+	u32 *ptxstat;
+	struct txrx_desc_t *ptxrxdesc;
+
+	len = skb->len;
+
+	spin_lock_irq(&pldat->lock);
+
+	if (pldat->num_used_tx_buffs >= (ENET_TX_DESC - 1)) {
+		/* This function should never be called when there are no
+		   buffers, log the error */
+		netif_stop_queue(ndev);
+		spin_unlock_irq(&pldat->lock);
+		dev_err(&pldat->pdev->dev,
+			"BUG! TX request when no free TX buffers!\n");
+		return 1;
+	}
+
+	/* Get the next TX descriptor index */
+	txidx = readl(LPC_ENET_TXPRODUCEINDEX(pldat->net_base));
+
+	/* Setup control for the transfer */
+	ptxstat = (u32 *) pldat->tx_stat_v [txidx];
+	*ptxstat = 0;
+	ptxrxdesc = (struct txrx_desc_t *) pldat->tx_desc_v [txidx];
+	ptxrxdesc->control = (len - 1) | 0xC0000000;
+
+	/* Copy data to the DMA buffer */
+	memcpy((void *) pldat->tx_buff_v [txidx], skb->data, len);
+
+	/* Save the buffer and increment the buffer counter */
+	pldat->skb[txidx] = skb;
+	pldat->num_used_tx_buffs++;
+
+	/* Start transmit */
+	txidx++;
+	if (txidx >= ENET_TX_DESC)
+		txidx = 0;
+	writel((u32) txidx, LPC_ENET_TXPRODUCEINDEX(pldat->net_base));
+
+	/* Stop queue if no more TX buffers */
+	if (pldat->num_used_tx_buffs >= (ENET_TX_DESC - 1))
+		netif_stop_queue(ndev);
+
+	spin_unlock_irq(&pldat->lock);
+	ndev->trans_start = jiffies;
+
+	return 0;
+}
+
+static void lpc_net_timeout(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	/* This should never happen and indicates a problem */
+	dev_err(&pldat->pdev->dev, "BUG! TX timeout occurred!\n");
+}
+
+static int lpc_set_mac_address(struct net_device *ndev, void *p)
+{
+        struct sockaddr *addr = p;
+	struct netdata_local *pldat = netdev_priv(ndev);
+	unsigned long flags;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+                return -EADDRNOTAVAIL;
+        memcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);
+
+	spin_lock_irqsave(&pldat->lock, flags);
+
+	/* Set station address */
+	__lpc_set_mac(pldat, ndev->dev_addr);
+
+	spin_unlock_irqrestore(&pldat->lock, flags);
+
+	return 0;
+}
+
+static void lpc_net_set_multicast_list(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct netdev_hw_addr *ha;
+	u32 tmp32, hash_val, hashlo, hashhi;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pldat->lock, flags);
+
+	/* Set station address */
+	__lpc_set_mac(pldat, ndev->dev_addr);
+
+	tmp32 =  LPC_RXFLTRW_ACCEPTUBROADCAST | LPC_RXFLTRW_ACCEPTPERFECT;
+
+	if (ndev->flags & IFF_PROMISC)
+		tmp32 |= LPC_RXFLTRW_ACCEPTUNICAST | LPC_RXFLTRW_ACCEPTUMULTICAST;
+	if (ndev->flags & IFF_ALLMULTI)
+		tmp32 |= LPC_RXFLTRW_ACCEPTUMULTICAST;
+
+	if(!netdev_mc_empty(ndev))
+		tmp32 |= LPC_RXFLTRW_ACCEPTUMULTICASTHASH;
+
+	writel(tmp32, LPC_ENET_RXFILTER_CTRL(pldat->net_base));
+
+
+	/* Set initial hash table */
+	hashlo = 0x0;
+	hashhi = 0x0;
+
+	/* 64 bits : multicast address in hash table */
+	netdev_for_each_mc_addr(ha, ndev) {
+		hash_val = (ether_crc(6, ha->addr) >> 23) & 0x3F;
+
+		if (hash_val >= 32)
+			hashhi |= 1 << (hash_val - 32);
+		else
+			hashlo |= 1 << hash_val;
+	}
+
+	writel(hashlo, LPC_ENET_HASHFILTERL(pldat->net_base));
+	writel(hashhi, LPC_ENET_HASHFILTERH(pldat->net_base));
+
+	spin_unlock_irqrestore(&pldat->lock, flags);
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void lpc_net_poll_controller(struct net_device *ndev)
+{
+	disable_irq(ndev->irq);
+	__lpc_eth_interrupt(dev->irq, ndev);
+	enable_irq(ndev->irq);
+}
+#endif
+
+static int lpc_net_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = pldat->phy_dev;
+
+	if (!netif_running(ndev))
+	{
+		return -EINVAL;
+	}
+
+	if (!phydev)
+	{
+		return -ENODEV;
+	}
+
+	//return phy_mii_ioctl(phydev, if_mii(req), cmd);
+	return phy_mii_ioctl(phydev, req, cmd);
+}
+
+static int lpc_net_open(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	/* if the phy is not yet registered, retry later*/
+	if (!pldat->phy_dev)
+	{
+		return -EAGAIN;
+	}
+
+	if (netif_msg_ifup(pldat))
+	{
+		dev_dbg(&pldat->pdev->dev, "enabling %s\n", ndev->name);
+	}
+
+	if (!is_valid_ether_addr(ndev->dev_addr))
+	{
+		return -EADDRNOTAVAIL;
+	}
+
+	__lpc_net_clock_enable(pldat, 1);
+
+	/* Reset and initialize */
+	__lpc_eth_reset(pldat);
+	__lpc_eth_init(pldat);
+
+	/* schedule a link state check */
+	phy_start(pldat->phy_dev);
+	netif_start_queue(ndev);
+
+	return 0;
+}
+
+/*
+ * Ethtool ops
+ */
+static void lpc_net_ethtool_getdrvinfo(struct net_device *ndev,
+	struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, MODNAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, dev_name(ndev->dev.parent));
+}
+
+static u32 lpc_net_ethtool_getmsglevel(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	return pldat->msg_enable;
+}
+
+static void lpc_net_ethtool_setmsglevel(struct net_device *ndev, u32 level)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	pldat->msg_enable = level;
+}
+
+static int lpc_net_ethtool_getsettings(struct net_device *ndev,
+	struct ethtool_cmd *cmd)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = pldat->phy_dev;
+
+	if (!phydev)
+	{
+		return -ENODEV;
+	}
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int lpc_net_ethtool_setsettings(struct net_device *ndev,
+	struct ethtool_cmd *cmd)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = pldat->phy_dev;
+
+	if (!phydev)
+	{
+		return -ENODEV;
+	}
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static const struct ethtool_ops lpc_net_ethtool_ops = {
+	.get_drvinfo	= lpc_net_ethtool_getdrvinfo,
+	.get_settings	= lpc_net_ethtool_getsettings,
+	.set_settings	= lpc_net_ethtool_setsettings,
+	.get_msglevel	= lpc_net_ethtool_getmsglevel,
+	.set_msglevel	= lpc_net_ethtool_setmsglevel,
+	.get_link	= ethtool_op_get_link,
+};
+
+static const struct net_device_ops lpc_netdev_ops = {
+	.ndo_open		= lpc_net_open,
+	.ndo_stop		= lpc_net_close,
+	.ndo_start_xmit		= lpc_net_hard_start_xmit,
+	.ndo_set_multicast_list	= lpc_net_set_multicast_list,
+//	.ndo_get_stats		= tsi108_get_stats,
+	.ndo_do_ioctl		= lpc_net_ioctl,
+	.ndo_tx_timeout		= lpc_net_timeout,
+	.ndo_set_mac_address	= lpc_set_mac_address,
+//	.ndo_validate_addr	= eth_validate_addr,
+//	.ndo_change_mtu		= eth_change_mtu,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.poll_controller	= lpc_net_poll_controller;
+#endif
+};
+
+static int lpc_net_drv_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct net_device *ndev;
+	struct netdata_local *pldat;
+	struct phy_device *phydev;
+	dma_addr_t dma_handle;
+	int irq, ret;
+
+	/* Get platform resources */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if ((!res) || (irq < 0) || (irq >= NR_IRQS)) {
+		dev_err(&pdev->dev, "error getting resources.\n");
+		ret = -ENXIO;
+		goto err_exit;
+	}
+
+	/* Allocate net driver data structure */
+	ndev = alloc_etherdev(sizeof(struct netdata_local));
+	if (!ndev) {
+		dev_err(&pdev->dev, "could not allocate device.\n");
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	pldat = netdev_priv(ndev);
+	pldat->pdev = pdev;
+	pldat->ndev = ndev;
+
+	spin_lock_init(&pldat->lock);
+
+	/* Save resources */
+	pldat->net_region_start = res->start;
+	pldat->net_region_size = res->end - res->start + 1;
+	ndev->irq = irq;
+
+	/* Get clock for the device */
+	pldat->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pldat->clk)) {
+		dev_err(&pdev->dev, "error getting clock.\n");
+		ret = PTR_ERR(pldat->clk);
+		goto err_out_free_dev;
+	}
+
+	/* Enable network clock */
+	__lpc_net_clock_enable(pldat, 1);
+
+	/* Map IO space */
+	pldat->net_base = ioremap(pldat->net_region_start, pldat->net_region_size);
+	if (!pldat->net_base) {
+		dev_err(&pdev->dev, "failed to map registers\n");
+		ret = -ENOMEM;
+		goto err_out_disable_clocks;
+	}
+	ret = request_irq(ndev->irq, __lpc_eth_interrupt, 0,
+			  ndev->name, ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "error requesting interrupt.\n");
+		goto err_out_iounmap;
+	}
+
+	/* Fill in the fields of the device structure with ethernet values. */
+	ether_setup(ndev);
+
+	/* Setup driver functions */
+	ndev->netdev_ops = &lpc_netdev_ops;
+	ndev->ethtool_ops = &lpc_net_ethtool_ops;
+	ndev->base_addr = pldat->net_region_start;
+	ndev->watchdog_timeo = msecs_to_jiffies(watchdog);
+
+	/* Save board specific configuration */
+	pldat->ncfg = (struct lpc_net_cfg *) pdev->dev.platform_data;
+	if (pldat->ncfg == NULL) {
+		dev_err(&pdev->dev, "error requesting interrupt.\n");
+		pldat->ncfg = &__lpc_local_net_config;
+	}
+
+	/* Get size of DMA buffers/descriptors region */
+	pldat->dma_buff_size = (ENET_TX_DESC + ENET_RX_DESC) * (ENET_MAXF_SIZE +
+		sizeof(struct txrx_desc_t) + sizeof(struct rx_status_t));
+	pldat->dma_buff_base_v = 0;
+
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+	dma_handle = (dma_addr_t) LPC32XX_IRAM_BASE;
+	if (pldat->dma_buff_size <= lpc32xx_return_iram_size())
+		pldat->dma_buff_base_v = (u32) io_p2v(LPC32XX_IRAM_BASE);
+	else
+		pr_err("%s: IRAM not big enough for net buffers, "
+			"using SDRAM instead.\n", MODNAME);
+#endif
+
+	if (pldat->dma_buff_base_v == 0) {
+		pldat->dma_buff_size += 4096; /* Allows room for alignment */
+
+		/* Align on the next highest page entry size */
+		pldat->dma_buff_size &= 0Xfffff000;
+		pldat->dma_buff_size += 0X00001000;
+
+		/* Allocate a chunk of memory for the DMA ethernet buffers and descriptors */
+		pldat->dma_buff_base_v = (u32) dma_alloc_coherent(&pldat->pdev->dev,
+			pldat->dma_buff_size, &dma_handle, GFP_KERNEL);
+
+		if (pldat->dma_buff_base_v == (u32) NULL)
+		{
+			dev_err(&pdev->dev, "error getting DMA region.\n");
+			ret = -ENOMEM;
+			goto err_out_free_irq;
+		}
+	}
+	pldat->dma_buff_base_p = (u32) dma_handle;
+
+	pr_debug("IO address start     :0x%08x\n", (u32) pldat->net_region_start);
+	pr_debug("IO address size      :%d\n", (u32) pldat->net_region_size);
+	pr_debug("IO address (mapped)  :0x%08x\n", (u32) pldat->net_base);
+	pr_debug("IRQ number           :%d\n", ndev->irq);
+	pr_debug("DMA buffer size      :%d\n", pldat->dma_buff_size);
+	pr_debug("DMA buffer P address :0x%08x\n", pldat->dma_buff_base_p);
+	pr_debug("DMA buffer V address :0x%08x\n", pldat->dma_buff_base_v);
+
+	/* Get the board MAC address */
+	ret = get_mac_addr(ndev->dev_addr);
+	if (ret) {
+		/* Mac address load error */
+		goto err_out_dma_unmap;
+	}
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		pr_info("%s: Invalid ethernet MAC address.  Please "
+		       "set using ifconfig\n", ndev->name);
+	}
+
+	/* Reset the ethernet controller */
+	__lpc_eth_reset(pldat);
+
+	/* then shut everything down to save power */
+	__lpc_net_shutdown(pldat);
+
+	/* Set default parameters */
+	pldat->msg_enable = NETIF_MSG_LINK;
+
+	/* Force an MII interface reset and clock setup */
+	__lpc_mii_mngt_reset(pldat);
+
+	/* Force default PHY interface setup in chip, this will probably be
+	   changed by the PHY driver */
+	pldat->link = 0;
+	pldat->speed = 100;
+	pldat->duplex = DUPLEX_FULL;
+	__lpc_params_setup(pldat);
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
+		goto err_out_dma_unmap;
+	}
+	platform_set_drvdata(pdev, ndev);
+
+	if (lpc_mii_init(pldat) != 0) {
+		goto err_out_unregister_netdev;
+	}
+
+	pr_info("%s: LPC mac at 0x%08lx irq %d\n",
+	       ndev->name, ndev->base_addr, ndev->irq);
+
+	phydev = pldat->phy_dev;
+	pr_info("%s: attached PHY driver [%s] "
+		"(mii_bus:phy_addr=%s, irq=%d)\n",
+		ndev->name, phydev->drv->name, dev_name(&phydev->dev),
+		phydev->irq);
+
+	device_init_wakeup(&pdev->dev, 1);
+	device_set_wakeup_enable(&pdev->dev, 0);
+
+	return 0;
+
+err_out_unregister_netdev:
+	platform_set_drvdata(pdev, NULL);
+	unregister_netdev(ndev);
+err_out_dma_unmap:
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+	if (pldat->dma_buff_size > lpc32xx_return_iram_size())
+#endif
+	dma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,
+		(void *) pldat->dma_buff_base_v, (dma_addr_t) pldat->dma_buff_base_p);
+err_out_free_irq:
+	free_irq(ndev->irq, ndev);
+err_out_iounmap:
+	iounmap(pldat->net_base);
+err_out_disable_clocks:
+	clk_disable(pldat->clk);
+	clk_put(pldat->clk);
+err_out_free_dev:
+	free_netdev(ndev);
+err_exit:
+	pr_err("%s: not found (%d).\n", MODNAME, ret);
+	return ret;
+}
+
+static int lpc_net_drv_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	unregister_netdev(ndev);
+	platform_set_drvdata(pdev, NULL);
+
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+	if (pldat->dma_buff_size > lpc32xx_return_iram_size())
+#endif
+	dma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,
+		(void *) pldat->dma_buff_base_v,
+		(dma_addr_t) pldat->dma_buff_base_p);
+	free_irq(ndev->irq, ndev);
+	iounmap(pldat->net_base);
+	clk_disable(pldat->clk);
+	clk_put(pldat->clk);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static int lpc_net_drv_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	if (device_may_wakeup(&pdev->dev))
+		enable_irq_wake(ndev->irq);
+
+	if (ndev) {
+		if (netif_running(ndev)) {
+			netif_device_detach(ndev);
+			__lpc_net_shutdown(pldat);
+			clk_disable(pldat->clk);
+
+			/*
+			 * Reset again now clock is disable to be sure
+			 * EMC_MDC is down
+			 */
+			__lpc_eth_reset(pldat);
+		}
+	}
+
+	return 0;
+}
+
+static int lpc_net_drv_resume(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat;
+
+	if (device_may_wakeup(&pdev->dev))
+		disable_irq_wake(ndev->irq);
+
+	if (ndev) {
+		if (netif_running(ndev)) {
+			pldat = netdev_priv(ndev);
+
+			/* Enable interface clock */
+			clk_enable(pldat->clk);
+
+			/* Reset and initialize */
+			__lpc_eth_reset(pldat);
+			__lpc_eth_init(pldat);
+
+			netif_device_attach(ndev);
+		}
+	}
+
+	return 0;
+}
+
+static struct platform_driver lpc_net_driver = {
+	.probe		= lpc_net_drv_probe,
+	.remove		= __devexit_p(lpc_net_drv_remove),
+	.suspend	= lpc_net_drv_suspend,
+	.resume		= lpc_net_drv_resume,
+	.driver		= {
+		.name	= MODNAME,
+	},
+};
+
+static int __init lpc_net_init(void)
+{
+	return platform_driver_register(&lpc_net_driver);
+}
+
+static void __exit lpc_net_cleanup(void)
+{
+	platform_driver_unregister(&lpc_net_driver);
+}
+
+module_init(lpc_net_init);
+module_exit(lpc_net_cleanup);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com");
+MODULE_DESCRIPTION("LPC Ethernet Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/lpc_eth.h b/drivers/net/lpc_eth.h
new file mode 100644
index 0000000..1835a9d
--- /dev/null
+++ b/drivers/net/lpc_eth.h
@@ -0,0 +1,317 @@
+/*
+ * drivers/net/lpc-eth.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LPC_ETH_H
+#define __LPC_ETH_H
+
+#include <linux/types.h>
+
+/*
+ * Ethernet MAC controller Register offsets
+ */
+#define LPC_ENET_MAC1(x)			(x + 0x000)
+#define LPC_ENET_MAC2(x)			(x + 0x004)
+#define LPC_ENET_IPGT(x)			(x + 0x008)
+#define LPC_ENET_IPGR(x)			(x + 0x00C)
+#define LPC_ENET_CLRT(x)			(x + 0x010)
+#define LPC_ENET_MAXF(x)			(x + 0x014)
+#define LPC_ENET_SUPP(x)			(x + 0x018)
+#define LPC_ENET_TEST(x)			(x + 0x01C)
+#define LPC_ENET_MCFG(x)			(x + 0x020)
+#define LPC_ENET_MCMD(x)			(x + 0x024)
+#define LPC_ENET_MADR(x)			(x + 0x028)
+#define LPC_ENET_MWTD(x)			(x + 0x02C)
+#define LPC_ENET_MRDD(x)			(x + 0x030)
+#define LPC_ENET_MIND(x)			(x + 0x034)
+#define LPC_ENET_SA0(x)				(x + 0x040)
+#define LPC_ENET_SA1(x)				(x + 0x044)
+#define LPC_ENET_SA2(x)				(x + 0x048)
+#define LPC_ENET_COMMAND(x)			(x + 0x100)
+#define LPC_ENET_STATUS(x)			(x + 0x104)
+#define LPC_ENET_RXDESCRIPTOR(x)		(x + 0x108)
+#define LPC_ENET_RXSTATUS(x)			(x + 0x10C)
+#define LPC_ENET_RXDESCRIPTORNUMBER(x)		(x + 0x110)
+#define LPC_ENET_RXPRODUCEINDEX(x)		(x + 0x114)
+#define LPC_ENET_RXCONSUMEINDEX(x)		(x + 0x118)
+#define LPC_ENET_TXDESCRIPTOR(x)		(x + 0x11C)
+#define LPC_ENET_TXSTATUS(x)			(x + 0x120)
+#define LPC_ENET_TXDESCRIPTORNUMBER(x)		(x + 0x124)
+#define LPC_ENET_TXPRODUCEINDEX(x)		(x + 0x128)
+#define LPC_ENET_TXCONSUMEINDEX(x)		(x + 0x12C)
+#define LPC_ENET_TSV0(x)			(x + 0x158)
+#define LPC_ENET_TSV1(x)			(x + 0x15C)
+#define LPC_ENET_RSV(x)				(x + 0x160)
+#define LPC_ENET_FLOWCONTROLCOUNTER(x)		(x + 0x170)
+#define LPC_ENET_FLOWCONTROLSTATUS(x)		(x + 0x174)
+#define LPC_ENET_RXFILTER_CTRL(x)		(x + 0x200)
+#define LPC_ENET_RXFILTERWOLSTATUS(x)		(x + 0x204)
+#define LPC_ENET_RXFILTERWOLCLEAR(x)		(x + 0x208)
+#define LPC_ENET_HASHFILTERL(x)			(x + 0x210)
+#define LPC_ENET_HASHFILTERH(x)			(x + 0x214)
+#define LPC_ENET_INTSTATUS(x)			(x + 0xFE0)
+#define LPC_ENET_INTENABLE(x)			(x + 0xFE4)
+#define LPC_ENET_INTCLEAR(x)			(x + 0xFE8)
+#define LPC_ENET_INTSET(x)			(x + 0xFEC)
+#define LPC_ENET_POWERDOWN(x)			(x + 0xFF4)
+
+/*
+ * Structure of a TX/RX descriptors and RX status
+ */
+struct txrx_desc_t {
+	volatile u32 packet;
+	volatile u32 control;
+};
+struct rx_status_t {
+	volatile u32 statusinfo;
+	volatile u32 statushashcrc;
+};
+
+/*
+ * mac1 register definitions
+ */
+#define LPC_MAC1_RECV_ENABLE			(1 << 0)
+#define LPC_MAC1_PASS_ALL_RX_FRAMES		(1 << 1)
+#define LPC_MAC1_RX_FLOW_CONTROL		(1 << 2)
+#define LPC_MAC1_TX_FLOW_CONTROL		(1 << 3)
+#define LPC_MAC1_LOOPBACK			(1 << 4)
+#define LPC_MAC1_RESET_TX			(1 << 8)
+#define LPC_MAC1_RESET_MCS_TX			(1 << 9)
+#define LPC_MAC1_RESET_RX			(1 << 10)
+#define LPC_MAC1_RESET_MCS_RX			(1 << 11)
+#define LPC_MAC1_SIMULATION_RESET		(1 << 14)
+#define LPC_MAC1_SOFT_RESET			(1 << 15)
+
+/*
+ * mac2 register definitions
+ */
+#define LPC_MAC2_FULL_DUPLEX			(1 << 0)
+#define LPC_MAC2_FRAME_LENGTH_CHECKING		(1 << 1)
+#define LPC_MAC2_HUGH_LENGTH_CHECKING		(1 << 2)
+#define LPC_MAC2_DELAYED_CRC			(1 << 3)
+#define LPC_MAC2_CRC_ENABLE			(1 << 4)
+#define LPC_MAC2_PAD_CRC_ENABLE			(1 << 5)
+#define LPC_MAC2_VLAN_PAD_ENABLE		(1 << 6)
+#define LPC_MAC2_AUTO_DETECT_PAD_ENABLE		(1 << 7)
+#define LPC_MAC2_PURE_PREAMBLE_ENFORCEMENT	(1 << 8)
+#define LPC_MAC2_LONG_PREAMBLE_ENFORCEMENT	(1 << 9)
+#define LPC_MAC2_NO_BACKOFF			(1 << 12)
+#define LPC_MAC2_BACK_PRESSURE			(1 << 13)
+#define LPC_MAC2_EXCESS_DEFER			(1 << 14)
+
+/*
+ * ipgt register definitions
+ */
+#define LPC_IPGT_LOAD(n)			((n) & 0x7F)
+
+/*
+ * ipgr register definitions
+ */
+#define LPC_IPGR_LOAD_PART2(n)			((n) & 0x7F)
+#define LPC_IPGR_LOAD_PART1(n)			(((n) & 0x7F) << 8)
+
+/*
+ * clrt register definitions
+ */
+#define LPC_CLRT_LOAD_RETRY_MAX(n)		((n) & 0xF)
+#define LPC_CLRT_LOAD_COLLISION_WINDOW(n)	(((n) & 0x3F) << 8)
+
+/*
+ * maxf register definitions
+ */
+#define LPC_MAXF_LOAD_MAX_FRAME_LEN(n)		((n) & 0xFFFF)
+
+/*
+ * supp register definitions
+ */
+#define LPC_SUPP_SPEED				(1 << 8)
+#define LPC_SUPP_RESET_RMII			(1 << 11)
+
+/*
+ * test register definitions
+ */
+#define LPC_TEST_SHORTCUT_PAUSE_QUANTA		(1 << 0)
+#define LPC_TEST_PAUSE				(1 << 1)
+#define LPC_TEST_BACKPRESSURE			(1 << 2)
+
+/*
+ * mcfg register definitions
+ */
+#define LPC_MCFG_SCAN_INCREMENT			(1 << 0)
+#define LPC_MCFG_SUPPRESS_PREAMBLE		(1 << 1)
+#define LPC_MCFG_CLOCK_SELECT(n)		(((n) & 0x7) << 2)
+#define LPC_MCFG_CLOCK_HOST_DIV_4		0
+#define LPC_MCFG_CLOCK_HOST_DIV_6		2
+#define LPC_MCFG_CLOCK_HOST_DIV_8		3
+#define LPC_MCFG_CLOCK_HOST_DIV_10		4
+#define LPC_MCFG_CLOCK_HOST_DIV_14		5
+#define LPC_MCFG_CLOCK_HOST_DIV_20		6
+#define LPC_MCFG_CLOCK_HOST_DIV_28		7
+#define LPC_MCFG_RESET_MII_MGMT			(1 << 15)
+
+/*
+ * mcmd register definitions
+ */
+#define LPC_MCMD_READ				(1 << 0)
+#define LPC_MCMD_SCAN				(1 << 1)
+
+/*
+ * madr register definitions
+ */
+#define LPC_MADR_REGISTER_ADDRESS(n)		((n) & 0x1F)
+#define LPC_MADR_PHY_0ADDRESS(n)		(((n) & 0x1F) << 8)
+
+/*
+ * mwtd register definitions
+ */
+#define LPC_MWDT_WRITE(n)			((n) & 0xFFFF)
+
+/*
+ * mrdd register definitions
+ */
+#define LPC_MRDD_READ_MASK			0xFFFF
+
+/*
+ * mind register definitions
+ */
+#define LPC_MIND_BUSY				(1 << 0)
+#define LPC_MIND_SCANNING			(1 << 1)
+#define LPC_MIND_NOT_VALID			(1 << 2)
+#define LPC_MIND_MII_LINK_FAIL			(1 << 3)
+
+/*
+ * command register definitions
+ */
+#define LPC_COMMAND_RXENABLE			(1 << 0)
+#define LPC_COMMAND_TXENABLE			(1 << 1)
+#define LPC_COMMAND_REG_RESET			(1 << 3)
+#define LPC_COMMAND_TXRESET			(1 << 4)
+#define LPC_COMMAND_RXRESET			(1 << 5)
+#define LPC_COMMAND_PASSRUNTFRAME		(1 << 6)
+#define LPC_COMMAND_PASSRXFILTER		(1 << 7)
+#define LPC_COMMAND_TXFLOWCONTROL		(1 << 8)
+#define LPC_COMMAND_RMII			(1 << 9)
+#define LPC_COMMAND_FULLDUPLEX			(1 << 10)
+
+/*
+ * status register definitions
+ */
+#define LPC_STATUS_RXACTIVE			(1 << 0)
+#define LPC_STATUS_TXACTIVE			(1 << 1)
+
+/*
+ * tsv0 register definitions
+ */
+#define LPC_TSV0_CRC_ERROR			(1 << 0)
+#define LPC_TSV0_LENGTH_CHECK_ERROR		(1 << 1)
+#define LPC_TSV0_LENGTH_OUT_OF_RANGE		(1 << 2)
+#define LPC_TSV0_DONE				(1 << 3)
+#define LPC_TSV0_MULTICAST			(1 << 4)
+#define LPC_TSV0_BROADCAST			(1 << 5)
+#define LPC_TSV0_PACKET_DEFER			(1 << 6)
+#define LPC_TSV0_ESCESSIVE_DEFER		(1 << 7)
+#define LPC_TSV0_ESCESSIVE_COLLISION		(1 << 8)
+#define LPC_TSV0_LATE_COLLISION			(1 << 9)
+#define LPC_TSV0_GIANT				(1 << 10)
+#define LPC_TSV0_UNDERRUN			(1 << 11)
+#define LPC_TSV0_TOTAL_BYTES(n)			(((n) >> 12) & 0xFFFF)
+#define LPC_TSV0_CONTROL_FRAME			(1 << 28)
+#define LPC_TSV0_PAUSE				(1 << 29)
+#define LPC_TSV0_BACKPRESSURE			(1 << 30)
+#define LPC_TSV0_VLAN				(1 << 31)
+
+/*
+ * tsv1 register definitions
+ */
+#define LPC_TSV1_TRANSMIT_BYTE_COUNT(n)		((n) & 0xFFFF)
+#define LPC_TSV1_COLLISION_COUNT(n)		(((n) >> 16) & 0xF)
+
+/*
+ * rsv register definitions
+ */
+#define LPC_RSV_RECEIVED_BYTE_COUNT(n)		((n) & 0xFFFF)
+#define LPC_RSV_RXDV_EVENT_IGNORED		(1 << 16)
+#define LPC_RSV_RXDV_EVENT_PREVIOUSLY_SEEN	(1 << 17)
+#define LPC_RSV_CARRIER_EVNT_PREVIOUS_SEEN	(1 << 18)
+#define LPC_RSV_RECEIVE_CODE_VIOLATION		(1 << 19)
+#define LPC_RSV_CRC_ERROR			(1 << 20)
+#define LPC_RSV_LENGTH_CHECK_ERROR		(1 << 21)
+#define LPC_RSV_LENGTH_OUT_OF_RANGE		(1 << 22)
+#define LPC_RSV_RECEIVE_OK			(1 << 23)
+#define LPC_RSV_MULTICAST			(1 << 24)
+#define LPC_RSV_BROADCAST			(1 << 25)
+#define LPC_RSV_DRIBBLE_NIBBLE			(1 << 26)
+#define LPC_RSV_CONTROL_FRAME			(1 << 27)
+#define LPC_RSV_PAUSE				(1 << 28)
+#define LPC_RSV_UNSUPPORTED_OPCODE		(1 << 29)
+#define LPC_RSV_VLAN				(1 << 30)
+
+/*
+ * flowcontrolcounter register definitions
+ */
+#define LPC_FCCR_MIRRORCOUNTER(n)		((n) & 0xFFFF)
+#define LPC_FCCR_PAUSETIMER(n)			(((n) >> 16) & 0xFFFF)
+
+/*
+ * flowcontrolstatus register definitions
+ */
+#define LPC_FCCR_MIRRORCOUNTERCURRENT(n)	((n) & 0xFFFF)
+
+/*
+ * rxfliterctrl, rxfilterwolstatus, and rxfilterwolclear shared
+ * register definitions
+ */
+#define LPC_RXFLTRW_ACCEPTUNICAST		(1 << 0)
+#define LPC_RXFLTRW_ACCEPTUBROADCAST		(1 << 1)
+#define LPC_RXFLTRW_ACCEPTUMULTICAST		(1 << 2)
+#define LPC_RXFLTRW_ACCEPTUNICASTHASH		(1 << 3)
+#define LPC_RXFLTRW_ACCEPTUMULTICASTHASH	(1 << 4)
+#define LPC_RXFLTRW_ACCEPTPERFECT		(1 << 5)
+
+/*
+ * rxfliterctrl register definitions
+ */
+#define LPC_RXFLTRWSTS_MAGICPACKETENWOL		(1 << 12)
+#define LPC_RXFLTRWSTS_RXFILTERENWOL		(1 << 13)
+
+/*
+ * rxfilterwolstatus/rxfilterwolclear register definitions
+ */
+#define LPC_RXFLTRWSTS_RXFILTERWOL		(1 << 7)
+#define LPC_RXFLTRWSTS_MAGICPACKETWOL		(1 << 8)
+
+/*
+ * intstatus, intenable, intclear, and Intset shared register
+ * definitions
+ */
+#define LPC_MACINT_RXOVERRUNINTEN		(1 << 0)
+#define LPC_MACINT_RXERRORONINT			(1 << 1)
+#define LPC_MACINT_RXFINISHEDINTEN		(1 << 2)
+#define LPC_MACINT_RXDONEINTEN			(1 << 3)
+#define LPC_MACINT_TXUNDERRUNINTEN		(1 << 4)
+#define LPC_MACINT_TXERRORINTEN			(1 << 5)
+#define LPC_MACINT_TXFINISHEDINTEN		(1 << 6)
+#define LPC_MACINT_TXDONEINTEN			(1 << 7)
+#define LPC_MACINT_SOFTINTEN			(1 << 12)
+#define LPC_MACINT_WAKEUPINTEN			(1 << 13)
+
+/*
+ * powerdown register definitions
+ */
+#define LPC_POWERDOWN_MACAHB			(1 << 31)
+
+#endif
diff --git a/drivers/rtc/rtc-lpc32xx.c b/drivers/rtc/rtc-lpc32xx.c
index ae16250..5beb875 100644
--- a/drivers/rtc/rtc-lpc32xx.c
+++ b/drivers/rtc/rtc-lpc32xx.c
@@ -202,7 +202,7 @@ static int __devinit lpc32xx_rtc_probe(struct platform_device *pdev)
 	struct lpc32xx_rtc *rtc;
 	resource_size_t size;
 	int rtcirq;
-	u32 tmp;
+	u32 tmp, ucount, dcount;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -272,6 +272,24 @@ static int __devinit lpc32xx_rtc_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, rtc);
 
+	/*
+	* Check SRAM integrity by comparing UP and DOWN counters
+	* If they don't match, reset them.
+	*/
+
+	/* Disable RTC during read (preventing count between reads) */
+	tmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);
+	rtc_writel(rtc, LPC32XX_RTC_CTRL, tmp | LPC32XX_RTC_CTRL_CNTR_DIS);
+	ucount = rtc_readl(rtc, LPC32XX_RTC_UCOUNT);
+	dcount = rtc_readl(rtc, LPC32XX_RTC_DCOUNT);
+	rtc_writel(rtc, LPC32XX_RTC_CTRL, tmp &= ~LPC32XX_RTC_CTRL_CNTR_DIS);
+
+	if( (dcount + ucount) != 0xFFFFFFFF )
+	{
+		dev_dbg(&pdev->dev, "Dcount (%08X) and Ucount (%08X) mismatch, reset them.\n", dcount, ucount );
+		lpc32xx_rtc_set_mmss(&pdev->dev, 0);
+	}
+
 	rtc->rtc = rtc_device_register(RTC_NAME, &pdev->dev, &lpc32xx_rtc_ops,
 		THIS_MODULE);
 	if (IS_ERR(rtc->rtc)) {
diff --git a/drivers/tty/serial/8250.c b/drivers/tty/serial/8250.c
index 6611535..e17b192 100644
--- a/drivers/tty/serial/8250.c
+++ b/drivers/tty/serial/8250.c
@@ -194,10 +194,18 @@ static const struct serial8250_config uart_config[] = {
 	},
 	[PORT_16550A] = {
 		.name		= "16550A",
+#ifdef CONFIG_ARCH_LPC32XX
+		.fifo_size  = 64,
+		.tx_loadsz  = 32,
+		.fcr        = UART_FCR_DMA_SELECT | UART_FCR_ENABLE_FIFO |
+									UART_FCR_R_TRIG_00 | UART_FCR_T_TRIG_00,
+		.flags      = UART_CAP_FIFO,
+#else
 		.fifo_size	= 16,
 		.tx_loadsz	= 16,
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
 		.flags		= UART_CAP_FIFO,
+#endif
 	},
 	[PORT_CIRRUS] = {
 		.name		= "Cirrus",
@@ -946,7 +954,7 @@ static int broken_efr(struct uart_8250_port *up)
 	/*
 	 * Exar ST16C2550 "A2" devices incorrectly detect as
 	 * having an EFR, and report an ID of 0x0201.  See
-	 * http://linux.derkeiler.com/Mailing-Lists/Kernel/2004-11/4812.html 
+	 * http://linux.derkeiler.com/Mailing-Lists/Kernel/2004-11/4812.html
 	 */
 	if (autoconfig_read_divisor_id(up) == 0x0201 && size_fifo(up) == 16)
 		return 1;
@@ -2069,6 +2077,10 @@ static int serial8250_startup(struct uart_port *port)
 
 	if (is_real_interrupt(up->port.irq)) {
 		unsigned char iir1;
+#ifdef CONFIG_ARCH_LPC32XX
+		serial_outp(up, UART_FCR, UART_FCR_DMA_SELECT | UART_FCR_ENABLE_FIFO |
+				UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
+#endif
 		/*
 		 * Test for UARTs that do not reassert THRE when the
 		 * transmitter is idle and the interrupt has already
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 80484af..6065751 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -1007,6 +1007,22 @@ config SERIAL_PNX8XXX_CONSOLE
 	  If you have a MIPS-based Philips SoC such as PNX8550 or PNX8330
 	  and you want to use serial console, say Y. Otherwise, say N.
 
+config SERIAL_HS_LPC32XX
+	tristate "LPC32xx high serial port support"
+	depends on ARCH_LPC32XX
+	select SERIAL_CORE
+	help
+		Support for the LPC32XX high speed serial ports
+
+config SERIAL_HS_LPC32XX_CONSOLE
+	bool "Enable LPC32XX high speed UART serial console"
+	depends on SERIAL_HS_LPC32XX
+	select SERIAL_CORE_CONSOLE
+	help
+		If you would like to be able to use one of the high speed serial
+		ports on the LPC32XX as the console, you can do so by answering
+		Y to this option.
+
 config SERIAL_CORE
 	tristate
 
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index fee0690..cd811e3 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -54,6 +54,7 @@ obj-$(CONFIG_SERIAL_68328) += 68328serial.o
 obj-$(CONFIG_SERIAL_68360) += 68360serial.o
 obj-$(CONFIG_SERIAL_MCF) += mcf.o
 obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
+obj-$(CONFIG_SERIAL_HS_LPC32XX) += lpc32xx_hs.o
 obj-$(CONFIG_SERIAL_DZ) += dz.o
 obj-$(CONFIG_SERIAL_ZS) += zs.o
 obj-$(CONFIG_SERIAL_SH_SCI) += sh-sci.o
diff --git a/drivers/tty/serial/lpc32xx_hs.c b/drivers/tty/serial/lpc32xx_hs.c
new file mode 100644
index 0000000..e1bcf2d
--- /dev/null
+++ b/drivers/tty/serial/lpc32xx_hs.c
@@ -0,0 +1,768 @@
+/*
+ * drivers/serial/lpc32xx_hs.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/nmi.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+
+#include <mach/board.h>
+
+/*
+ * High speed UART register offsets
+ */
+#define LPC32XX_HSUART_FIFO(x)			(x + 0x00)
+#define LPC32XX_HSUART_LEVEL(x)			(x + 0x04)
+#define LPC32XX_HSUART_IIR(x)			(x + 0x08)
+#define LPC32XX_HSUART_CTRL(x)			(x + 0x0C)
+#define LPC32XX_HSUART_RATE(x)			(x + 0x10)
+
+#define LPC32XX_HSU_BREAK_DATA			(1 << 10)
+#define LPC32XX_HSU_ERROR_DATA			(1 << 9)
+#define LPC32XX_HSU_RX_EMPTY			(1 << 8)
+
+#define LPC32XX_HSU_TX_LEV(n)			(((n) >> 8) & 0xFF)
+#define LPC32XX_HSU_RX_LEV(n)			((n) & 0xFF)
+
+#define LPC32XX_HSU_TX_INT_SET			(1 << 6)
+#define LPC32XX_HSU_RX_OE_INT			(1 << 5)
+#define LPC32XX_HSU_BRK_INT			(1 << 4)
+#define LPC32XX_HSU_FE_INT			(1 << 3)
+#define LPC32XX_HSU_RX_TIMEOUT_INT		(1 << 2)
+#define LPC32XX_HSU_RX_TRIG_INT			(1 << 1)
+#define LPC32XX_HSU_TX_INT			(1 << 0)
+
+#define LPC32XX_HSU_HRTS_INV			(1 << 21)
+#define LPC32XX_HSU_HRTS_TRIG_8B		(0x0 << 19)
+#define LPC32XX_HSU_HRTS_TRIG_16B		(0x1 << 19)
+#define LPC32XX_HSU_HRTS_TRIG_32B		(0x2 << 19)
+#define LPC32XX_HSU_HRTS_TRIG_48B		(0x3 << 19)
+#define LPC32XX_HSU_HRTS_EN			(1 << 18)
+#define LPC32XX_HSU_TMO_DISABLED		(0x0 << 16)
+#define LPC32XX_HSU_TMO_INACT_4B		(0x1 << 16)
+#define LPC32XX_HSU_TMO_INACT_8B		(0x2 << 16)
+#define LPC32XX_HSU_TMO_INACT_16B		(0x3 << 16)
+#define LPC32XX_HSU_HCTS_INV			(1 << 15)
+#define LPC32XX_HSU_HCTS_EN			(1 << 14)
+#define LPC32XX_HSU_OFFSET(n)			((n) << 9)
+#define LPC32XX_HSU_BREAK			(1 << 8)
+#define LPC32XX_HSU_ERR_INT_EN			(1 << 7)
+#define LPC32XX_HSU_RX_INT_EN			(1 << 6)
+#define LPC32XX_HSU_TX_INT_EN			(1 << 5)
+#define LPC32XX_HSU_RX_TL1B			(0x0 << 2)
+#define LPC32XX_HSU_RX_TL4B			(0x1 << 2)
+#define LPC32XX_HSU_RX_TL8B			(0x2 << 2)
+#define LPC32XX_HSU_RX_TL16B			(0x3 << 2)
+#define LPC32XX_HSU_RX_TL32B			(0x4 << 2)
+#define LPC32XX_HSU_RX_TL48B			(0x5 << 2)
+#define LPC32XX_HSU_TX_TLEMPTY			(0x0 << 0)
+#define LPC32XX_HSU_TX_TL0B			(0x0 << 0)
+#define LPC32XX_HSU_TX_TL4B			(0x1 << 0)
+#define LPC32XX_HSU_TX_TL8B			(0x2 << 0)
+#define LPC32XX_HSU_TX_TL16B			(0x3 << 0)
+
+#define MODNAME "lpc32xx_hsuart"
+
+#define FIFO_READ_LIMIT 128
+#define MAX_PORTS 3
+#define LPC32XX_TTY_NAME "ttyTX"
+#define LPC32XX_TTY_MINOR_START	196
+#define LPC32XX_TTY_MAJOR 204
+static struct lpc32xx_hsuart_port lpc32xx_hs_ports[MAX_PORTS];
+
+#ifdef CONFIG_SERIAL_HS_LPC32XX_CONSOLE
+static void wait_for_xmit_empty(struct uart_port *port)
+{
+	unsigned int timeout = 10000;
+
+	do {
+		if (LPC32XX_HSU_TX_LEV(__raw_readl(LPC32XX_HSUART_LEVEL(
+			port->membase))) == 0)
+			break;
+		if (--timeout == 0)
+			break;
+		udelay(1);
+	} while (1);
+}
+
+static void wait_for_xmit_ready(struct uart_port *port)
+{
+	unsigned int timeout = 10000;
+
+	while (1) {
+		if (LPC32XX_HSU_TX_LEV(__raw_readl(LPC32XX_HSUART_LEVEL(
+			port->membase))) < 32)
+			break;
+		if (--timeout == 0)
+			break;
+		udelay(1);
+	}
+}
+
+static void lpc32xx_hsuart_console_putchar(struct uart_port *port, int ch)
+{
+	wait_for_xmit_ready(port);
+	__raw_writel((u32) ch, LPC32XX_HSUART_FIFO(port->membase));
+}
+
+static void lpc32xx_hsuart_console_write(struct console *co, const char *s,
+	unsigned int count) {
+	struct lpc32xx_hsuart_port *up = &lpc32xx_hs_ports[co->index];
+	unsigned long flags;
+	int locked = 1;
+
+	touch_nmi_watchdog();
+	local_irq_save(flags);
+	if (up->port.sysrq)
+		locked = 0;
+	else if (oops_in_progress)
+		locked = spin_trylock(&up->port.lock);
+	else
+		spin_lock(&up->port.lock);
+
+	uart_console_write(&up->port, s, count,
+		lpc32xx_hsuart_console_putchar);
+	wait_for_xmit_empty(&up->port);
+
+	if (locked)
+		spin_unlock(&up->port.lock);
+	local_irq_restore(flags);
+}
+
+static int __init lpc32xx_hsuart_console_setup(struct console *co,
+	char *options) {
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index >= MAX_PORTS)
+		co->index = 0;
+
+	port = &lpc32xx_hs_ports[co->index].port;
+	if (!port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver lpc32xx_hs_reg;
+static struct console lpc32xx_hsuart_console = {
+	.name		= LPC32XX_TTY_NAME,
+	.write		= lpc32xx_hsuart_console_write,
+	.device		= uart_console_device,
+	.setup		= lpc32xx_hsuart_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &lpc32xx_hs_reg,
+};
+
+static int __init lpc32xx_hsuart_console_init(void)
+{
+	register_console(&lpc32xx_hsuart_console);
+	return 0;
+}
+console_initcall(lpc32xx_hsuart_console_init);
+
+#define LPC32XX_HSUART_CONSOLE	(&lpc32xx_hsuart_console)
+#else
+#define LPC32XX_HSUART_CONSOLE NULL
+#endif
+
+static struct uart_driver lpc32xx_hs_reg = {
+	.owner		= THIS_MODULE,
+	.driver_name	= MODNAME,
+	.dev_name	= LPC32XX_TTY_NAME,
+	.major		= LPC32XX_TTY_MAJOR,
+	.minor		= LPC32XX_TTY_MINOR_START,
+	.nr		= MAX_PORTS,
+	.cons		= LPC32XX_HSUART_CONSOLE,
+};
+static int uarts_registered;
+
+static unsigned int __serial_get_clock_div(unsigned long uartclk,
+	unsigned long rate) {
+	u32 div, goodrate, hsu_rate, l_hsu_rate, comprate;
+	u32 rate_diff;
+
+	/* Find the closest divider to get the desired clock rate */
+	div = uartclk / rate;
+	goodrate = hsu_rate = (div / 14) - 1;
+	if (hsu_rate != 0)
+		hsu_rate--;
+
+	/* Tweak divider */
+	l_hsu_rate = hsu_rate + 3;
+	rate_diff = 0xFFFFFFFF;
+
+	while (hsu_rate < l_hsu_rate) {
+		comprate = uartclk / ((hsu_rate + 1) * 14);
+		if (abs(comprate - rate) < rate_diff) {
+			goodrate = hsu_rate;
+			rate_diff = abs(comprate - rate);
+		}
+
+		hsu_rate++;
+	}
+	if (hsu_rate > 0xFF)
+		hsu_rate = 0xFF;
+
+	return goodrate;
+}
+
+static void __serial_uart_flush(struct uart_port *port)
+{
+	u32 tmp;
+	int cnt = 0;
+
+	while ((__raw_readl(LPC32XX_HSUART_LEVEL(port->membase)) > 0) &&
+		(cnt++ < FIFO_READ_LIMIT))
+		tmp = __raw_readl(LPC32XX_HSUART_FIFO(port->membase));
+}
+
+static void __serial_lpc32xx_rx(struct uart_port *port)
+{
+	unsigned int tmp, flag;
+
+	/* Read data from FIFO and push into terminal */
+	tmp = __raw_readl(LPC32XX_HSUART_FIFO(port->membase));
+	while (!(tmp & LPC32XX_HSU_RX_EMPTY)) {
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (tmp & LPC32XX_HSU_ERROR_DATA) {
+			/* Framing error */
+			__raw_writel(LPC32XX_HSU_FE_INT,
+				LPC32XX_HSUART_IIR(port->membase));
+			port->icount.frame++;
+			flag = TTY_FRAME;
+			tty_insert_flip_char(port->state->port.tty, 0,
+				TTY_FRAME);
+			tty_schedule_flip(port->state->port.tty);
+		}
+
+		tty_insert_flip_char(port->state->port.tty, (tmp & 0xFF),
+			flag);
+
+		tmp = __raw_readl(LPC32XX_HSUART_FIFO(port->membase));
+	}
+}
+
+static void __serial_lpc32xx_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned int tmp;
+
+	if (port->x_char) {
+		__raw_writel((u32) port->x_char,
+			LPC32XX_HSUART_FIFO(port->membase));
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port))
+		goto exit_tx;
+
+	/* Transfer data */
+	while (LPC32XX_HSU_TX_LEV(__raw_readl(
+		LPC32XX_HSUART_LEVEL(port->membase))) < 64) {
+		__raw_writel((u32) xmit->buf[xmit->tail],
+			LPC32XX_HSUART_FIFO(port->membase));
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+exit_tx:
+	if (uart_circ_empty(xmit)) {
+		tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+		tmp &= ~LPC32XX_HSU_TX_INT_EN;
+		__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+	}
+}
+
+static irqreturn_t serial_lpc32xx_interrupt(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	u32 status;
+
+	spin_lock(&port->lock);
+
+	/* Read UART status and clear latched interrupts */
+	status = __raw_readl(LPC32XX_HSUART_IIR(port->membase));
+
+	if (status & LPC32XX_HSU_BRK_INT) {
+		/* Break received */
+		__raw_writel(LPC32XX_HSU_BRK_INT,
+			LPC32XX_HSUART_IIR(port->membase));
+		port->icount.brk++;
+		uart_handle_break(port);
+	}
+
+	/* Framing error */
+	if (status & LPC32XX_HSU_FE_INT)
+		__raw_writel(LPC32XX_HSU_FE_INT,
+			LPC32XX_HSUART_IIR(port->membase));
+
+	if (status & LPC32XX_HSU_RX_OE_INT) {
+		/* Receive FIFO overrun */
+		__raw_writel(LPC32XX_HSU_RX_OE_INT,
+			LPC32XX_HSUART_IIR(port->membase));
+		port->icount.overrun++;
+		tty_insert_flip_char(port->state->port.tty, 0, TTY_OVERRUN);
+		tty_schedule_flip(port->state->port.tty);
+	}
+
+	/* Data received? */
+	if (status & (LPC32XX_HSU_RX_TIMEOUT_INT | LPC32XX_HSU_RX_TRIG_INT)) {
+		__serial_lpc32xx_rx(port);
+		spin_unlock(&port->lock);
+		tty_flip_buffer_push(port->state->port.tty);
+		spin_lock(&port->lock);
+	}
+
+	/* Transmit data request? */
+	if ((status & LPC32XX_HSU_TX_INT) && (!uart_tx_stopped(port))) {
+		__raw_writel(LPC32XX_HSU_TX_INT,
+			LPC32XX_HSUART_IIR(port->membase));
+		__serial_lpc32xx_tx(port);
+	}
+
+	spin_unlock(&port->lock);
+
+	return IRQ_HANDLED;
+}
+
+/* port->lock is not held.  */
+static unsigned int serial_lpc32xx_tx_empty(struct uart_port *port)
+{
+	unsigned int ret = 0;
+
+	if (LPC32XX_HSU_TX_LEV(__raw_readl(
+		LPC32XX_HSUART_LEVEL(port->membase))) == 0)
+		ret = TIOCSER_TEMT;
+
+	return ret;
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_set_mctrl(struct uart_port *port,
+	unsigned int mctrl) {
+	/* No signals are supported on HS UARTs */
+}
+
+/* port->lock is held by caller and interrupts are disabled.  */
+static unsigned int serial_lpc32xx_get_mctrl(struct uart_port *port)
+{
+	/* No signals are supported on HS UARTs */
+	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_stop_tx(struct uart_port *port)
+{
+	u32 tmp;
+
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	tmp &= ~LPC32XX_HSU_TX_INT_EN;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_start_tx(struct uart_port *port)
+{
+	u32 tmp;
+
+	__serial_lpc32xx_tx(port);
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	tmp |= LPC32XX_HSU_TX_INT_EN;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_stop_rx(struct uart_port *port)
+{
+	u32 tmp;
+
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	tmp &= ~(LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN);
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+
+	__raw_writel((LPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT |
+		LPC32XX_HSU_FE_INT), LPC32XX_HSUART_IIR(port->membase));
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_enable_ms(struct uart_port *port)
+{
+	/* Modem status is not supported */
+}
+
+/* port->lock is not held.  */
+static void serial_lpc32xx_break_ctl(struct uart_port *port,
+	int break_state) {
+	unsigned long flags;
+	u32 tmp;
+
+	spin_lock_irqsave(&port->lock, flags);
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	if (break_state != 0)
+		tmp |= LPC32XX_HSU_BREAK;
+	else
+		tmp &= ~LPC32XX_HSU_BREAK;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/* port->lock is not held.  */
+static int serial_lpc32xx_startup(struct uart_port *port)
+{
+	int retval;
+	unsigned long flags;
+	u32 tmp;
+	struct lpc32xx_hsuart_port *p = (struct lpc32xx_hsuart_port *)port;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	__serial_uart_flush(port);
+
+	__raw_writel((LPC32XX_HSU_TX_INT | LPC32XX_HSU_FE_INT |
+		LPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT),
+		LPC32XX_HSUART_IIR(port->membase));
+
+	__raw_writel(0xFF, LPC32XX_HSUART_RATE(port->membase));
+
+	/*
+	 * Set receiver timeout, HSU offset of 20, no break, no interrupts,
+	 * and default FIFO trigger levels
+	 */
+	tmp = LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |
+		LPC32XX_HSU_OFFSET(p->fbit_sam) | LPC32XX_HSU_TMO_INACT_4B;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	retval = request_irq(port->irq, serial_lpc32xx_interrupt,
+			     0, MODNAME, port);
+	if (!retval)
+		__raw_writel((tmp | LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN),
+			LPC32XX_HSUART_CTRL(port->membase));
+
+	return retval;
+}
+
+/* port->lock is not held.  */
+static void serial_lpc32xx_shutdown(struct uart_port *port)
+{
+	u32 tmp;
+	unsigned long flags;
+	struct lpc32xx_hsuart_port *p = (struct lpc32xx_hsuart_port *)port;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	tmp = LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |
+		LPC32XX_HSU_OFFSET(p->fbit_sam) | LPC32XX_HSU_TMO_INACT_4B;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	free_irq(port->irq, port);
+}
+
+/* port->lock is not held.  */
+static void serial_lpc32xx_set_termios(struct uart_port *port,
+	struct ktermios *termios, struct ktermios *old)
+{
+	unsigned long flags;
+	unsigned int baud, quot;
+	u32 tmp;
+
+	/* Always 8-bit, no parity, 1 stop bit */
+	termios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD);
+	termios->c_cflag |= CS8;
+
+	termios->c_cflag &= ~(HUPCL | CMSPAR | CLOCAL | CRTSCTS);
+
+	baud = uart_get_baud_rate(port, termios, old, 0,
+		(port->uartclk / 14));
+	quot = __serial_get_clock_div(port->uartclk, baud);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* Ignore characters? */
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	if ((termios->c_cflag & CREAD) == 0)
+		tmp &= ~(LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN);
+	else
+		tmp |= LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+
+	__raw_writel(quot, LPC32XX_HSUART_RATE(port->membase));
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *serial_lpc32xx_type(struct uart_port *port)
+{
+	return MODNAME;
+}
+
+static void serial_lpc32xx_release_port(struct uart_port *port)
+{
+	if ((port->iotype == UPIO_MEM32) && (port->mapbase)) {
+		if (port->flags & UPF_IOREMAP) {
+			iounmap(port->membase);
+			port->membase = NULL;
+		}
+
+		release_mem_region(port->mapbase, SZ_4K);
+	}
+}
+
+static int serial_lpc32xx_request_port(struct uart_port *port)
+{
+	int ret = -ENODEV;
+
+	if ((port->iotype == UPIO_MEM32) && (port->mapbase)) {
+		ret = 0;
+
+		if (!request_mem_region(port->mapbase, SZ_4K, MODNAME))
+			ret = -EBUSY;
+		else if (port->flags & UPF_IOREMAP) {
+			port->membase = ioremap(port->mapbase, SZ_4K);
+			if (!port->membase) {
+				release_mem_region(port->mapbase, SZ_4K);
+				ret = -ENOMEM;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static void serial_lpc32xx_config_port(struct uart_port *port, int uflags)
+{
+	int ret;
+	struct lpc32xx_hsuart_port *p = (struct lpc32xx_hsuart_port *)port;
+
+	ret = serial_lpc32xx_request_port(port);
+	if (ret < 0)
+		return;
+	port->type = PORT_UART00;
+	port->fifosize = 64;
+
+	__serial_uart_flush(port);
+
+	__raw_writel((LPC32XX_HSU_TX_INT | LPC32XX_HSU_FE_INT |
+		LPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT),
+		LPC32XX_HSUART_IIR(port->membase));
+
+	__raw_writel(0xFF, LPC32XX_HSUART_RATE(port->membase));
+
+	/* Set receiver timeout, HSU offset of 20, no break, no interrupts,
+	   and default FIFO trigger levels */
+	__raw_writel(LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |
+		LPC32XX_HSU_OFFSET(p->fbit_sam) | LPC32XX_HSU_TMO_INACT_4B,
+		LPC32XX_HSUART_CTRL(port->membase));
+}
+
+static int serial_lpc32xx_verify_port(struct uart_port *port,
+	struct serial_struct *ser)
+{
+	int ret = 0;
+
+	if (ser->type != PORT_UART00)
+		ret = -EINVAL;
+
+	return ret;
+}
+
+static struct uart_ops serial_lpc32xx_pops = {
+	.tx_empty	= serial_lpc32xx_tx_empty,
+	.set_mctrl	= serial_lpc32xx_set_mctrl,
+	.get_mctrl	= serial_lpc32xx_get_mctrl,
+	.stop_tx	= serial_lpc32xx_stop_tx,
+	.start_tx	= serial_lpc32xx_start_tx,
+	.stop_rx	= serial_lpc32xx_stop_rx,
+	.enable_ms	= serial_lpc32xx_enable_ms,
+	.break_ctl	= serial_lpc32xx_break_ctl,
+	.startup	= serial_lpc32xx_startup,
+	.shutdown	= serial_lpc32xx_shutdown,
+	.set_termios	= serial_lpc32xx_set_termios,
+	.type		= serial_lpc32xx_type,
+	.release_port	= serial_lpc32xx_release_port,
+	.request_port	= serial_lpc32xx_request_port,
+	.config_port	= serial_lpc32xx_config_port,
+	.verify_port	= serial_lpc32xx_verify_port,
+};
+
+/*
+ * Register a set of serial devices attached to a platform device
+ */
+static int __devinit serial_hs_lpc32xx_probe(struct platform_device *pdev)
+{
+	struct lpc32xx_hsuart_port *p = pdev->dev.platform_data;
+	struct lpc32xx_hsuart_port *pdr;
+	int i, ret = 0;
+
+	uarts_registered = 0;
+	for (i = 0; p && (p->port.flags != 0); i++) {
+		pdr = &lpc32xx_hs_ports[i];
+		memset(pdr, 0, sizeof(struct lpc32xx_hsuart_port));
+
+		pdr->port.iotype	= p->port.iotype;
+		pdr->port.membase	= p->port.membase;
+		pdr->port.mapbase	= p->port.mapbase;
+		pdr->port.irq		= p->port.irq;
+		pdr->port.uartclk	= p->port.uartclk;
+		pdr->port.regshift	= p->port.regshift;
+		pdr->port.flags		= p->port.flags | UPF_FIXED_PORT;
+		pdr->port.dev		= &pdev->dev;
+		pdr->port.ops		= &serial_lpc32xx_pops;
+		pdr->port.line		= p->port.line;
+		pdr->fbit_sam		= p->fbit_sam;
+
+		/* If First sample point is beyond limit,
+		 * set it to default value - 20
+		 */
+		if((pdr->fbit_sam < 0) || (pdr->fbit_sam > 31)) {
+			pdr->fbit_sam = 20;
+		}
+
+		spin_lock_init(&pdr->port.lock);
+
+		uart_add_one_port(&lpc32xx_hs_reg, &pdr->port);
+		p++;
+		uarts_registered++;
+	}
+
+	return ret;
+}
+
+/*
+ * Remove serial ports registered against a platform device.
+ */
+static int __devexit serial_hs_lpc32xx_remove(struct platform_device *pdev)
+{
+	struct lpc32xx_hsuart_port *p;
+	int i;
+
+	for (i = 0; i < uarts_registered; i++) {
+		p = &lpc32xx_hs_ports[i];
+
+		if (p->port.dev == &pdev->dev)
+			uart_remove_one_port(&lpc32xx_hs_reg, &p->port);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+
+#if defined (CONFIG_PM)
+static int serial_hs_lpc32xx_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+
+	for (i = 0; i < uarts_registered; i++) {
+		struct lpc32xx_hsuart_port *p = &lpc32xx_hs_ports[i];
+
+		if (p->port.type != PORT_UNKNOWN && p->port.dev == &dev->dev)
+			uart_suspend_port(&lpc32xx_hs_reg, &p->port);
+	}
+
+	return 0;
+}
+
+static int serial_hs_lpc32xx_resume(struct platform_device *dev)
+{
+	int i;
+
+	for (i = 0; i < uarts_registered; i++) {
+		struct lpc32xx_hsuart_port *p = &lpc32xx_hs_ports[i];
+
+		if (p->port.type != PORT_UNKNOWN && p->port.dev == &dev->dev)
+			uart_resume_port(&lpc32xx_hs_reg, &p->port);
+	}
+
+	return 0;
+}
+#else
+#define serial_hs_lpc32xx_suspend	NULL
+#define serial_hs_lpc32xx_resume	NULL
+#endif
+
+static struct platform_driver serial_hs_lpc32xx_driver = {
+	.probe		= serial_hs_lpc32xx_probe,
+	.remove		= __devexit_p(serial_hs_lpc32xx_remove),
+ 	.suspend	= serial_hs_lpc32xx_suspend,
+ 	.resume		= serial_hs_lpc32xx_resume,
+	.driver		= {
+		.name	= MODNAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lpc32xx_hsuart_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&lpc32xx_hs_reg);
+	if (ret == 0) {
+		ret = platform_driver_register(&serial_hs_lpc32xx_driver);
+		if (ret)
+			uart_unregister_driver(&lpc32xx_hs_reg);
+	}
+
+	return ret;
+}
+
+static void __exit lpc32xx_hsuart_exit(void)
+{
+	platform_driver_unregister(&serial_hs_lpc32xx_driver);
+	uart_unregister_driver(&lpc32xx_hs_reg);
+}
+
+module_init(lpc32xx_hsuart_init);
+module_exit(lpc32xx_hsuart_exit);
+
+MODULE_AUTHOR("Kevin Wells (kevin.wells@nxp.com)");
+MODULE_DESCRIPTION("NXP LPC32XX High speed UART driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index bc5123c..758e7f2 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -140,6 +140,16 @@ config USB_AT91
 	depends on USB_GADGET_AT91
 	default USB_GADGET
 
+config USB_GADGET_LPC32XX
+	boolean "LPC32XX USB Device Port"
+	depends on ARCH_LPC32XX
+
+config USB_LPC32XX
+	tristate
+	depends on USB_GADGET_LPC32XX
+	default USB_GADGET
+	select USB_GADGET_SELECTED
+
 config USB_GADGET_ATMEL_USBA
 	boolean "Atmel USBA"
 	select USB_GADGET_DUALSPEED
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 1ea15ee..c6af502 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -23,6 +23,7 @@ obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX_PCI)	+= ci13xxx_pci.o
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
+obj-$(CONFIG_USB_LPC32XX)	+= lpc32xx_udc.o
 obj-$(CONFIG_USB_EG20T)		+= pch_udc.o
 obj-$(CONFIG_USB_PXA_U2O)	+= mv_udc.o
 mv_udc-y			:= mv_udc_core.o mv_udc_phy.o
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index e896f63..b5de8b1 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -136,6 +136,12 @@
 #define gadget_is_s3c_hsotg(g)    0
 #endif
 
+#ifdef CONFIG_USB_GADGET_LPC32XX
+#define	gadget_is_lpc32xx(g)	!strcmp("lpc32xx_udc", (g)->name)
+#else
+#define	gadget_is_lpc32xx(g)	0
+#endif
+
 #ifdef CONFIG_USB_GADGET_EG20T
 #define	gadget_is_pch(g)	(!strcmp("pch_udc", (g)->name))
 #else
diff --git a/drivers/usb/gadget/lpc32xx_udc.c b/drivers/usb/gadget/lpc32xx_udc.c
new file mode 100644
index 0000000..34296d0
--- /dev/null
+++ b/drivers/usb/gadget/lpc32xx_udc.c
@@ -0,0 +1,3194 @@
+/*
+ * drivers/usb/gadget/lpc32xx_udc.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ * Copyright (C) 2006 Mike James , Philips Semiconductors
+ *
+ * Note: This driver is based on original work done by Mike James for
+ *       the LPC3180.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Update Feb 2011
+ * Known driver issues
+ *
+ * Spinlock handling
+ * All spinlock grab/release issues seems to be fixed. It is possible there
+ * may be paths that haven't yet been tested.
+ *
+ * Printer class driver
+ * There seems to be an issue with this specific driver related to spinlocks.
+ * The issue does seem to be class driver related, not chip driver related.
+ * Some functions are called from the printer class driver with class specific
+ * spinlocks enabled. This might be fixed in a later kernel release.
+ *
+ * Isochronous endpoint transfers (audio class driver)
+ * Isochronous transfers do not work reliably. Tested with the audio class
+ * driver and ALSA, USB audio streaming does work, but issues appear with
+ * ISO endpoint transfer and control endpoints related to ALSA set/get
+ * functions. It is possible this may be related to the gadget audio support.
+ *
+ * Host suspend/resume do not fully shut down the USB
+ * The I2C transceiver and device clocks should be shut down when the
+ * hosts is suspended. This will be fixed later. The current drawback
+ * is power usage during suspend is higher than if not fully powered
+ * down
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/i2c.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/workqueue.h>
+
+#include <asm/byteorder.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <mach/platform.h>
+#include <mach/irqs.h>
+#include <mach/usbd.h>
+#include <mach/board.h>
+#include "lpc32xx_udc.h"
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+#include <linux/seq_file.h>
+#endif
+
+#define UDCA_BUFF_SIZE (128)
+
+#define USB_CTRL	IO_ADDRESS(LPC32XX_CLK_PM_BASE + 0x64)
+#define USB_CLOCK_MASK (AHB_M_CLOCK_ON| OTG_CLOCK_ON | DEV_CLOCK_ON | I2C_CLOCK_ON)
+
+/* USB_CTRL bit defines */
+#define USB_SLAVE_HCLK_EN	(1 << 24)
+#define USB_HOST_NEED_CLK_EN	(1 << 21)
+#define USB_DEV_NEED_CLK_EN	(1 << 22)
+
+#define USB_OTG_CLK_CTRL	IO_ADDRESS(LPC32XX_USB_BASE + 0xFF4)
+#define USB_OTG_CLK_STAT	IO_ADDRESS(LPC32XX_USB_BASE + 0xFF8)
+
+/* USB_OTG_CLK_CTRL bit defines */
+#define AHB_M_CLOCK_ON		(1 << 4)
+#define OTG_CLOCK_ON		(1 << 3)
+#define I2C_CLOCK_ON		(1 << 2)
+#define DEV_CLOCK_ON		(1 << 1)
+#define HOST_CLOCK_ON		(1 << 0)
+
+#define USB_OTG_STAT_CONTROL	IO_ADDRESS(LPC32XX_USB_BASE + 0x110)
+
+/* USB_OTG_STAT_CONTROL bit defines */
+#define TRANSPARENT_I2C_EN	(1 << 7)
+#define HOST_EN			(1 << 0)
+
+/* ISP1301 USB transceiver I2C registers */
+#define	ISP1301_MODE_CONTROL_1		0x04	/* u8 read, set, +1 clear */
+
+#define	MC1_SPEED_REG		(1 << 0)
+#define	MC1_SUSPEND_REG		(1 << 1)
+#define	MC1_DAT_SE0		(1 << 2)
+#define	MC1_TRANSPARENT		(1 << 3)
+#define	MC1_BDIS_ACON_EN	(1 << 4)
+#define	MC1_OE_INT_EN		(1 << 5)
+#define	MC1_UART_EN		(1 << 6)
+#define	MC1_MASK		0x7f
+
+#define	ISP1301_MODE_CONTROL_2		0x12	/* u8 read, set, +1 clear */
+
+#define	MC2_GLOBAL_PWR_DN	(1 << 0)
+#define	MC2_SPD_SUSP_CTRL	(1 << 1)
+#define	MC2_BI_DI		(1 << 2)
+#define	MC2_TRANSP_BDIR0	(1 << 3)
+#define	MC2_TRANSP_BDIR1	(1 << 4)
+#define	MC2_AUDIO_EN		(1 << 5)
+#define	MC2_PSW_EN		(1 << 6)
+#define	MC2_EN2V7		(1 << 7)
+
+#define	ISP1301_OTG_CONTROL_1		0x06	/* u8 read, set, +1 clear */
+#define	OTG1_DP_PULLUP		(1 << 0)
+#define	OTG1_DM_PULLUP		(1 << 1)
+#define	OTG1_DP_PULLDOWN	(1 << 2)
+#define	OTG1_DM_PULLDOWN	(1 << 3)
+#define	OTG1_ID_PULLDOWN	(1 << 4)
+#define	OTG1_VBUS_DRV		(1 << 5)
+#define	OTG1_VBUS_DISCHRG	(1 << 6)
+#define	OTG1_VBUS_CHRG		(1 << 7)
+#define	ISP1301_OTG_STATUS		0x10	/* u8 readonly */
+#define	OTG_B_SESS_END		(1 << 6)
+#define	OTG_B_SESS_VLD		(1 << 7)
+
+#define INT_CR_INT		(1 << 7)
+#define INT_BDIS_ACON		(1 << 6)
+#define INT_ID_FLOAT		(1 << 5)
+#define INT_DM_HI		(1 << 4)
+#define INT_ID_GND		(1 << 3)
+#define INT_DP_HI		(1 << 2)
+#define INT_SESS_VLD		(1 << 1)
+#define INT_VBUS_VLD		(1 << 0)
+
+#define ISP1301_I2C_ADDR 0x2C
+
+#define ISP1301_I2C_MODE_CONTROL_1 0x4
+#define ISP1301_I2C_MODE_CONTROL_2 0x12
+#define ISP1301_I2C_OTG_CONTROL_1 0x6
+#define ISP1301_I2C_OTG_CONTROL_2 0x10
+#define ISP1301_I2C_INTERRUPT_SOURCE 0x8
+#define ISP1301_I2C_INTERRUPT_LATCH 0xA
+#define ISP1301_I2C_INTERRUPT_FALLING 0xC
+#define ISP1301_I2C_INTERRUPT_RISING 0xE
+#define ISP1301_I2C_REG_CLEAR_ADDR 1
+
+#define	DRIVER_VERSION	"$Revision: 1.02 $"
+static const char driver_name [] = "lpc32xx_udc";
+
+static void udc_set_address(struct lpc32xx_udc *udc, u32 addr);
+static int udc_ep_in_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep);
+static int udc_ep_out_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep);
+static int udc_ep0_in_req(struct lpc32xx_udc *udc);
+static int udc_ep0_out_req(struct lpc32xx_udc *udc);
+
+/*
+ *
+ * proc interface support
+ *
+ */
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+static char *epnames[] = {"INT", "ISO", "BULK", "CTRL"};
+static const char debug_filename[] = "driver/udc";
+
+static void proc_ep_show(struct seq_file *s, struct lpc32xx_ep *ep)
+{
+	struct lpc32xx_request *req;
+
+	seq_printf(s, "\n");
+	seq_printf(s, "%12s, maxpacket %4d %3s",
+			ep->ep.name, ep->ep.maxpacket,
+			ep->is_in ? "in" : "out");
+	seq_printf(s, " type %4s", epnames[ep->eptype]);
+	seq_printf(s, " ints: %12d", ep->totalints);
+
+	if (list_empty (&ep->queue))
+		seq_printf(s, "\t(queue empty)\n");
+	else {
+		list_for_each_entry (req, &ep->queue, queue) {
+			u32 length = req->req.actual;
+
+			seq_printf(s, "\treq %p len %d/%d buf %p\n",
+					&req->req, length,
+					req->req.length, req->req.buf);
+		}
+	}
+}
+
+static int proc_udc_show(struct seq_file *s, void *unused)
+{
+	struct lpc32xx_udc *udc = s->private;
+	struct lpc32xx_ep *ep;
+	unsigned long flags;
+
+	seq_printf(s, "%s: version %s\n", driver_name, DRIVER_VERSION);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	seq_printf(s, "vbus %s, pullup %s, %s powered%s, gadget %s\n\n",
+			udc->vbus ? "present" : "off",
+			udc->enabled
+			? (udc->vbus ? "active" : "enabled")
+			: "disabled",
+			udc->selfpowered ? "self" : "VBUS",
+			udc->suspended ? ", suspended" : "",
+			udc->driver ? udc->driver->driver.name : "(none)");
+
+	if (udc->enabled && udc->vbus) {
+		proc_ep_show(s, &udc->ep[0]);
+		list_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {
+			if (ep->desc) {
+				proc_ep_show(s, ep);
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static int proc_udc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_udc_show, PDE(inode)->data);
+}
+
+static const struct file_operations proc_ops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_udc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void create_debug_file(struct lpc32xx_udc *udc)
+{
+	udc->pde = proc_create_data(debug_filename, 0, NULL, &proc_ops, udc);
+}
+
+static void remove_debug_file(struct lpc32xx_udc *udc)
+{
+	if (udc->pde)
+		remove_proc_entry(debug_filename, NULL);
+}
+
+#else
+static inline void create_debug_file(struct lpc32xx_udc *udc) {}
+static inline void remove_debug_file(struct lpc32xx_udc *udc) {}
+#endif
+
+/*
+ *
+ * ISP1301 transceiver support functions
+ *
+ */
+struct i2c_driver isp1301_driver;
+struct i2c_client *isp1301_i2c_client;
+static int isp1301_probe(struct i2c_client *client, const struct i2c_device_id *i2c_id);
+static int isp1301_remove(struct i2c_client *client);
+
+static const unsigned short normal_i2c[] =
+{ ISP1301_I2C_ADDR, ISP1301_I2C_ADDR + 1, I2C_CLIENT_END };
+
+static const struct i2c_device_id isp1301_id[] = {
+	{ "isp1301_pnx", 0 },
+	{ }
+};
+
+struct i2c_driver isp1301_driver = {
+	.driver = {
+		.name = "isp1301_pnx",
+	},
+	.probe = isp1301_probe,
+	.remove = isp1301_remove,
+	.id_table = isp1301_id,
+};
+
+static int isp1301_probe(struct i2c_client *client, const struct i2c_device_id *i2c_id)
+{
+	return 0;
+}
+
+static int isp1301_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static void i2c_write(u8 buf, u8 subaddr)
+{
+	char tmpbuf[2];
+
+	tmpbuf[0] = subaddr;	/*register number */
+	tmpbuf[1] = buf;	/*register data */
+	i2c_master_send(isp1301_i2c_client, &tmpbuf[0], 2);
+}
+
+static u16 i2c_read(u8 subaddr)
+{
+	u8 data;
+
+	i2c_master_send(isp1301_i2c_client, &subaddr, 1);
+	i2c_master_recv(isp1301_i2c_client, (u8 *) &data, 1);
+
+	return data;
+}
+
+static u16 i2c_read16(u8 subaddr)
+{
+	u16 data;
+
+	i2c_master_send(isp1301_i2c_client, &subaddr, 1);
+	i2c_master_recv(isp1301_i2c_client, (u8 *) &data, 2);
+
+	return data;
+}
+
+/* Primary initializion sequence for the ISP1301 transceiver */
+static void isp1301_udc_configure(struct lpc32xx_udc *udc)
+{
+	/* LPC32XX only supports DAT_SE0 USB mode */
+	/* This sequence is important */
+
+	/* Disable transparent UART mode first */
+	i2c_write(MC1_UART_EN, (ISP1301_I2C_MODE_CONTROL_1 |
+				ISP1301_I2C_REG_CLEAR_ADDR));
+
+	/* Set full speed and SE0 mode */
+	i2c_write(~0, (ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write((MC1_SPEED_REG | MC1_DAT_SE0), ISP1301_I2C_MODE_CONTROL_1);
+
+	/* The PSW_OE enable bit state is reversed in the ISP1301 User's guide! */
+	i2c_write(~0, (ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write((MC2_BI_DI | MC2_SPD_SUSP_CTRL), ISP1301_I2C_MODE_CONTROL_2);
+
+	/* Driver VBUS_DRV high or low depending on board setup */
+	if (udc->board->vbus_drv_pol != 0) {
+		i2c_write(OTG1_VBUS_DRV, ISP1301_I2C_OTG_CONTROL_1);
+	}
+	else {
+		i2c_write(OTG1_VBUS_DRV, (ISP1301_I2C_OTG_CONTROL_1 |
+					ISP1301_I2C_REG_CLEAR_ADDR));
+	}
+
+	/* Bi-derctional mode with suspend control */
+	/* Enable both pulldowns for now - the pullup will be enable when VBUS is detected */
+	i2c_write(~0, (ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write((0 | OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN),
+			ISP1301_I2C_OTG_CONTROL_1);
+
+	/* Discharge VBUS (just in case) */
+	i2c_write(OTG1_VBUS_DISCHRG, ISP1301_I2C_OTG_CONTROL_1);
+	mdelay(1);
+	i2c_write(OTG1_VBUS_DISCHRG,
+			(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+
+	/* Clear and enable VBUS high edge interrupt */
+	i2c_write(~0, ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(~0, ISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(INT_VBUS_VLD, ISP1301_I2C_INTERRUPT_FALLING);
+	i2c_write(~0, ISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(INT_VBUS_VLD, ISP1301_I2C_INTERRUPT_RISING);
+
+	/* Enable usb_need_clk clock after transceiver is initialized */
+	__raw_writel((__raw_readl(USB_CTRL) | (1 << 22)), USB_CTRL);
+
+	dev_dbg(udc->dev, "USB transceiver Vendor ID  : 0x%04x\n", i2c_read16(0x00));
+	dev_dbg(udc->dev, "USB transceiver Product ID : 0x%04x\n", i2c_read16(0x02));
+	dev_dbg(udc->dev, "USB transceiver Version ID : 0x%04x\n", i2c_read16(0x14));
+}
+
+/* Enables or disables the USB device pullup via the ISP1301 transceiver */
+static void isp1301_pullup_set(int en_pullup)
+{
+	if (en_pullup) {
+		/* Enable pullup for bus signalling */
+		i2c_write(OTG1_DP_PULLUP, ISP1301_I2C_OTG_CONTROL_1);
+	}
+	else {
+		/* Enable pullup for bus signalling */
+		i2c_write(OTG1_DP_PULLUP,
+				(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	}
+}
+
+static void pullup_work(struct work_struct *work)
+{
+	struct lpc32xx_udc *udc = container_of(work, struct lpc32xx_udc, pullup_wq);
+
+	isp1301_pullup_set(udc->pullup);
+}
+
+static void isp1301_pullup_enable(struct lpc32xx_udc *udc, int en_pullup, int block)
+{
+	if (en_pullup == udc->pullup)
+		return;
+
+	udc->pullup = en_pullup;
+	if (block)
+		isp1301_pullup_set(en_pullup);
+	else
+		schedule_work(&udc->pullup_wq);
+}
+
+#ifdef CONFIG_PM
+/* Powers up or down the ISP1301 transceiver */
+static void isp1301_set_powerstate(int enable) {
+	if (enable != 0) {
+		/* Power up ISP1301 - this ISP1301 will automatically wakeup
+		   when VBUS is detected */
+		i2c_write(MC2_GLOBAL_PWR_DN,
+				(ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR));
+	}
+	else {
+		/* Power down ISP1301 */
+		i2c_write(MC2_GLOBAL_PWR_DN, ISP1301_I2C_MODE_CONTROL_2);
+	}
+}
+
+static void power_work(struct work_struct *work)
+{
+	struct lpc32xx_udc *udc = container_of(work, struct lpc32xx_udc, power_wq);
+
+	isp1301_set_powerstate(udc->poweron);
+}
+#endif
+
+/*
+ *
+ * USB protocol engine command/data read/write helper functions
+ *
+ */
+/* Issues a single command to the USB device state machine */
+static void udc_protocol_cmd_w(struct lpc32xx_udc *udc, u32 cmd)
+{
+	volatile u32 tmp;
+	int to = 1000;
+
+	/* EP may lock on CLRI if this read isn't done */
+	tmp = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+
+	/* Clear CCEMPTY flash */
+	__raw_writel(USBD_CCEMPTY, USBD_DEVINTCLR(udc->udp_baseaddr));
+
+	/* Write command code and wait for protocol engine acceptance */
+	__raw_writel(cmd, USBD_CMDCODE(udc->udp_baseaddr));
+
+	/* Wait for CCEMPTY to signal command acceptance */
+	tmp = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+	while ((!(__raw_readl(USBD_DEVINTST(udc->udp_baseaddr)) & USBD_CCEMPTY))
+		&& (to > 0))
+		to--;
+	if (!to)
+		dev_dbg(udc->dev, "Protocol engine didn't accept command (CCEMPTY)\n");
+}
+
+/* Issues 2 commands (or command and data) to the USB device state machine */
+static inline void udc_protocol_cmd_data_w(struct lpc32xx_udc *udc, u32 cmd, u32 data) {
+	udc_protocol_cmd_w(udc, cmd);
+	udc_protocol_cmd_w(udc, data);
+}
+
+/* Issues a single command to the USB device state machine and reads
+   response data */
+static u32 udc_protocol_cmd_r(struct lpc32xx_udc *udc, u32 cmd)
+{
+	volatile u32 tmp;
+	int to = 1000;
+
+	/* Write a command and read data from the protocol engine */
+	__raw_writel((USBD_CDFULL | USBD_CCEMPTY),
+			USBD_DEVINTCLR(udc->udp_baseaddr));
+
+	/* Write command code */
+	udc_protocol_cmd_w(udc, cmd);
+
+	tmp = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+	while ((!(__raw_readl(USBD_DEVINTST(udc->udp_baseaddr)) & USBD_CDFULL))
+		&& (to > 0))
+		to--;
+	if (!to)
+		dev_dbg(udc->dev, "Protocol engine didn't receive response (CDFULL)\n");
+
+	return __raw_readl(USBD_CMDDATA(udc->udp_baseaddr));
+}
+
+/*
+ *
+ * USB device interrupt mask support functions
+ *
+ */
+/* Enable one or more USB device interrupts */
+static inline void uda_enable_devint(struct lpc32xx_udc *udc, u32 devmask) {
+	udc->enabled_devints |= devmask;
+	__raw_writel(udc->enabled_devints, USBD_DEVINTEN(udc->udp_baseaddr));
+}
+
+/* Disable one or more USB device interrupts */
+static inline void uda_disable_devint(struct lpc32xx_udc *udc, u32 mask) {
+	udc->enabled_devints &= ~mask;
+	__raw_writel(udc->enabled_devints, USBD_DEVINTEN(udc->udp_baseaddr));
+}
+
+/* Clear one or more USB device interrupts */
+static inline void uda_clear_devint(struct lpc32xx_udc *udc, u32 mask) {
+	__raw_writel(mask, USBD_DEVINTCLR(udc->udp_baseaddr));
+}
+
+/*
+ *
+ * Endpoint interrupt disable/enable functions
+ *
+ */
+/* Enable one or more USB endpoint interrupts */
+static void uda_enable_hwepint(struct lpc32xx_udc *udc, u32 hwep) {
+	udc->enabled_hwepints |= (1 << hwep);
+	__raw_writel(udc->enabled_hwepints, USBD_EPINTEN(udc->udp_baseaddr));
+}
+
+/* Disable one or more USB endpoint interrupts */
+static void uda_disable_hwepint(struct lpc32xx_udc *udc, u32 hwep) {
+	udc->enabled_hwepints &= ~(1 << hwep);
+	__raw_writel(udc->enabled_hwepints, USBD_EPINTEN(udc->udp_baseaddr));
+}
+
+/* Clear one or more USB endpoint interrupts */
+static inline void uda_clear_hwepint(struct lpc32xx_udc *udc, u32 hwep) {
+	__raw_writel((1 << hwep), USBD_EPINTCLR(udc->udp_baseaddr));
+}
+
+/* Enable DMA for the HW channel */
+static inline void udc_ep_dma_enable(struct lpc32xx_udc *udc, u32 hwep) {
+	__raw_writel((1 << hwep), USBD_EPDMAEN(udc->udp_baseaddr));
+}
+
+/* Disable DMA for the HW channel */
+static inline void udc_ep_dma_disable(struct lpc32xx_udc *udc, u32 hwep) {
+	__raw_writel((1 << hwep), USBD_EPDMADIS(udc->udp_baseaddr));
+}
+
+/*
+ *
+ * Endpoint realize/unrealize functions
+ *
+ */
+/* Before an endpoint can be used, it needs to be realized
+   in the USB protocol engine - this realizes the endpoint.
+   The interrupt (FIFO or DMA) is not enabled with this function */
+static void udc_realize_hwep(struct lpc32xx_udc *udc, u32 hwep,
+		u32 maxpacket) {
+	int to = 1000;
+
+	__raw_writel(USBD_EP_RLZED, USBD_DEVINTCLR(udc->udp_baseaddr));
+	__raw_writel(hwep, USBD_EPIND(udc->udp_baseaddr));
+	udc->realized_eps |= (1 << hwep);
+	__raw_writel(udc->realized_eps, USBD_REEP(udc->udp_baseaddr));
+	__raw_writel(maxpacket, USBD_EPMAXPSIZE(udc->udp_baseaddr));
+
+	/* Wait until endpoint is realized in hardware */
+	while ((!(__raw_readl(USBD_DEVINTST(udc->udp_baseaddr)) & USBD_EP_RLZED))
+		&& (to > 0))
+		to--;
+	if (!to)
+		dev_dbg(udc->dev, "EP not correctly realized in hardware\n");
+
+	__raw_writel(USBD_EP_RLZED, USBD_DEVINTCLR(udc->udp_baseaddr));
+}
+
+/* Unrealize an EP */
+static void udc_unrealize_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc->realized_eps &= ~(1 << hwep);
+	__raw_writel(udc->realized_eps, USBD_REEP(udc->udp_baseaddr));
+}
+
+/*
+ *
+ * Endpoint support functions
+ *
+ */
+/* Select and clear endpoint interrupt */
+static u32 udc_selep_clrint(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_w(udc, CMD_SEL_EP_CLRI(hwep));
+	return udc_protocol_cmd_r(udc, DAT_SEL_EP_CLRI(hwep));
+}
+
+/* Disables the endpoint in the USB protocol engine */
+static void udc_disable_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),
+			DAT_WR_BYTE(EP_STAT_DA));
+}
+
+/* Stalls the endpoint - endpoint will return STALL */
+static void udc_stall_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),
+			DAT_WR_BYTE(EP_STAT_ST));
+}
+
+/* Clear stall or reset endpoint */
+static void udc_clrstall_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),
+			DAT_WR_BYTE(0));
+}
+
+/* Select an endpoint for endpoint status, clear, validate */
+static void udc_select_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_w(udc, CMD_SEL_EP(hwep));
+}
+
+/*
+ *
+ * Endpoint buffer management functions
+ *
+ */
+/* Clear the current endpoint's buffer */
+static void udc_clr_buffer_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_select_hwep(udc, hwep);
+	udc_protocol_cmd_w(udc, CMD_CLR_BUF);
+}
+
+/* Validate the current endpoint's buffer */
+static void udc_val_buffer_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_select_hwep(udc, hwep);
+	udc_protocol_cmd_w(udc, CMD_VALID_BUF);
+}
+
+static inline u32 udc_clearep_getsts(struct lpc32xx_udc *udc, u32 hwep) {
+	/* Clear EP interrupt */
+	uda_clear_hwepint(udc, hwep);
+	return udc_selep_clrint(udc, hwep);
+}
+
+/*
+ *
+ * USB EP DMA support
+ *
+ */
+/* Allocate a DMA Descriptor */
+static struct lpc32xx_usbd_dd_gad *udc_dd_alloc(struct lpc32xx_udc *udc) {
+	dma_addr_t			dma;
+	struct lpc32xx_usbd_dd_gad	*dd;
+
+	dd = (struct lpc32xx_usbd_dd_gad *) dma_pool_alloc(
+			udc->dd_cache, (GFP_KERNEL | GFP_DMA), &dma);
+	if (dd)
+		dd->this_dma = dma;
+
+	return dd;
+}
+
+/* Free a DMA Descriptor */
+static void udc_dd_free(struct lpc32xx_udc *udc, struct lpc32xx_usbd_dd_gad *dd)
+{
+	dma_pool_free(udc->dd_cache, dd, dd->this_dma);
+}
+
+/*
+ *
+ * USB setup and shutdown functions
+ *
+ */
+/* Enables or disables most of the USB system clocks when low power mode is
+   needed. Clocks are typically started on a connection event, and disabled
+   when a cable is disconnected */
+#define OTGOFF_CLK_MASK (AHB_M_CLOCK_ON | I2C_CLOCK_ON)
+static void udc_clk_set(struct lpc32xx_udc *udc, int enable)
+{
+	int to = 1000;
+
+	if (enable != 0) {
+		if (udc->clocked)
+			return;
+
+		udc->clocked = 1;
+
+		/* 48MHz PLL up */
+		clk_enable(udc->usb_pll_clk);
+
+		/* Enable the USb device clock */
+		__raw_writel(__raw_readl(USB_CTRL) | USB_DEV_NEED_CLK_EN, USB_CTRL);
+
+		/* Set to enable all needed USB OTG clocks */
+		__raw_writel(USB_CLOCK_MASK, USB_OTG_CLK_CTRL);
+
+		while (((__raw_readl(USB_OTG_CLK_STAT) & USB_CLOCK_MASK) !=
+				USB_CLOCK_MASK) && (to > 0))
+			to--;
+		if (!to)
+			dev_dbg(udc->dev, "Cannot enable USB OTG clocking\n");
+	}
+	else {
+		if (!udc->clocked)
+			return;
+
+		udc->clocked = 0;
+
+		/* Never disable the USB_HCLK during normal operation */
+
+		/* 48MHz PLL dpwn */
+		clk_disable(udc->usb_pll_clk);
+
+		/* Enable the USb device clock */
+		__raw_writel(__raw_readl(USB_CTRL) & ~USB_DEV_NEED_CLK_EN, USB_CTRL);
+
+		/* Set to enable all needed USB OTG clocks */
+		__raw_writel(OTGOFF_CLK_MASK, USB_OTG_CLK_CTRL);
+
+		while (((__raw_readl(USB_OTG_CLK_STAT) & OTGOFF_CLK_MASK) !=
+				OTGOFF_CLK_MASK) && (to > 0))
+			to--;
+		if (!to)
+			dev_dbg(udc->dev, "Cannot disable USB OTG clocking\n");
+	}
+}
+
+static void udc_disable(struct lpc32xx_udc *udc) {
+	u32 i;
+
+	/* Disable device */
+	udc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(0));
+	udc_protocol_cmd_data_w(udc, CMD_SET_DEV_STAT, DAT_WR_BYTE(0));
+
+	/* Disable all device interrupts (including EP0) */
+	uda_disable_devint(udc, 0x3FF);
+
+	/* Disable and reset all endpoint interrupts */
+	for (i = 0; i < 32; i++) {
+	     	uda_disable_hwepint(udc, i);
+		uda_clear_hwepint(udc, i);
+		udc_disable_hwep(udc, i);
+		udc_unrealize_hwep(udc, i);
+		udc->udca_v_base [i] = 0;
+
+		/* Disable and clear all interrupts and DMA */
+		udc_ep_dma_disable(udc, i);
+		__raw_writel((1 << i), USBD_EOTINTCLR(udc->udp_baseaddr));
+		__raw_writel((1 << i), USBD_NDDRTINTCLR(udc->udp_baseaddr));
+		__raw_writel((1 << i), USBD_SYSERRTINTCLR(udc->udp_baseaddr));
+		__raw_writel((1 << i), USBD_DMARCLR(udc->udp_baseaddr));
+	}
+
+	/* Disable DMA interrupts */
+	__raw_writel(0, USBD_DMAINTEN(udc->udp_baseaddr));
+
+	__raw_writel(0, USBD_UDCAH(udc->udp_baseaddr));
+}
+
+static void udc_enable(struct lpc32xx_udc *udc)
+{
+	u32 i;
+	struct lpc32xx_ep *ep = &udc->ep[0];
+
+	/* Start with known state */
+	udc_disable(udc);
+
+	/* Enable device */
+	udc_protocol_cmd_data_w(udc, CMD_SET_DEV_STAT, DAT_WR_BYTE(DEV_CON));
+
+	/* EP interrupts on high priority, FRAME interrupt on low priority */
+	__raw_writel(USBD_EP_FAST, USBD_DEVINTPRI(udc->udp_baseaddr));
+	__raw_writel(0xFFFF, USBD_EPINTPRI(udc->udp_baseaddr));
+
+	/* Clear any pending device interrupts */
+	__raw_writel(0x3FF, USBD_DEVINTCLR(udc->udp_baseaddr));
+
+	/* Setup UDCA - not yet used (DMA) */
+	__raw_writel((u32) udc->udca_p_base, USBD_UDCAH(udc->udp_baseaddr));
+
+	/* Only enable EP0 in and out for now, EP0 only works in FIFO mode */
+	for (i = 0; i <= 1; i++) {
+		udc_realize_hwep(udc, i, ep->ep.maxpacket);
+		uda_enable_hwepint(udc, i);
+		udc_select_hwep(udc, i);
+		udc_clrstall_hwep(udc, i);
+		udc_clr_buffer_hwep(udc, i);
+	}
+
+	/* Device interrupt setup */
+	uda_clear_devint(udc, (USBD_ERR_INT | USBD_DEV_STAT | USBD_EP_SLOW |
+				USBD_EP_FAST));
+	uda_enable_devint(udc, (USBD_ERR_INT | USBD_DEV_STAT | USBD_EP_SLOW |
+				USBD_EP_FAST));
+
+	/* Set device address to 0 - called twice to force a latch in the USB
+	   engine without the need of a setup packet status closure */
+	udc_set_address(udc, 0);
+	udc_set_address(udc, 0);
+
+	/* Enable master DMA interrupts */
+	__raw_writel((USBD_SYS_ERR_INT | USBD_EOT_INT), USBD_DMAINTEN(udc->udp_baseaddr));
+
+	udc->dev_status = 0;
+}
+
+/*
+ *
+ * USB device board specific events handled via callbacks
+ *
+ */
+/* Connection change event - notify board function of change */
+static void uda_power_event(struct lpc32xx_udc *udc, u32 conn) {
+	/* Just notify of a connection change event (optional) */
+	if (udc->board->conn_chgb != NULL) {
+		udc->board->conn_chgb(conn);
+	}
+}
+
+/* Suspend/resume event - notify board function of change */
+static void uda_resm_susp_event(struct lpc32xx_udc *udc, u32 conn) {
+	/* Just notify of a Suspend/resume change event (optional) */
+	if (udc->board->susp_chgb != NULL) {
+		udc->board->susp_chgb(conn);
+	}
+
+	if (conn)
+		udc->suspended = 0;
+	else
+		udc->suspended = 1;
+}
+
+/* Remote wakeup enable/disable - notify board function of change */
+static void uda_remwkp_cgh(struct lpc32xx_udc *udc) {
+	if (udc->board->rmwk_chgb != NULL) {
+		udc->board->rmwk_chgb(udc->dev_status &
+				(1 << USB_DEVICE_REMOTE_WAKEUP));
+	}
+}
+
+/* Reads data from FIFO, adjusts for alignment and data size */
+static void udc_pop_fifo(struct lpc32xx_udc *udc, u8 *data, u32 bytes) {
+	int n, i, bl;
+	u16 *p16;
+	u32 *p32, tmp, cbytes;
+
+	/* Use optimal data transfer method based on source address and size */
+	switch (((u32) data) & 0x3) {
+		case 0: /* 32-bit aligned */
+			p32 = (u32 *) data;
+			cbytes = (bytes & ~0x3);
+
+			/* Copy 32-bit aligned data first */
+			for (n = 0; n < cbytes; n += 4)
+				*p32++ = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+
+			/* Handle any remaining bytes */
+			bl = bytes - cbytes;
+			if (bl) {
+				tmp = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+				for (n = 0; n < bl; n++)
+					data[cbytes + n] = ((tmp >> (n * 8)) & 0xFF);
+
+			}
+			break;
+
+		case 1: /* 8-bit aligned */
+		case 3:
+			/* Each byte has to be handled independently */
+			for (n = 0; n < bytes; n += 4) {
+				tmp = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+
+				bl = bytes - n;
+				if (bl > 3)
+					bl = 3;
+
+				for (i = 0; i < bl; i++)
+					data[n + i] = (u8) ((tmp >> (n * 8)) & 0xFF);
+			}
+			break;
+
+		case 2: /* 16-bit aligned */
+			p16 = (u16 *) data;
+			cbytes = (bytes & ~0x3);
+
+			/* Copy 32-bit sized objects first with 16-bit alignment */
+			for (n = 0; n < cbytes; n += 4) {
+				tmp = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+				*p16++ = (u16) (tmp & 0xFFFF);
+				*p16++ = (u16) ((tmp >> 16) & 0xFFFF);
+			}
+
+			/* Handle any remaining bytes */
+			bl = bytes - cbytes;
+			if (bl) {
+				tmp = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+				for (n = 0; n < bl; n++)
+					data[cbytes + n] = ((tmp >> (n * 8)) & 0xFF);
+			}
+			break;
+	}
+}
+
+/* Read data from the FIFO for an endpoint. This function is for endpoints (such
+   as EP0) that don't use DMA. This function should only be called if a packet
+   is known to be ready to read for the endpopint. Note that the endpoint must
+   be selected in the protocol engine prior to this call. */
+static u32 udc_read_hwep(struct lpc32xx_udc *udc, u32 hwep, u32 *data,
+		int bytes) {
+	volatile u32 tmpv;
+	int to = 1000;
+	u32 tmp, hwrep = ((hwep & 0x1E) << 1) | CTRL_RD_EN;
+
+	/* Setup read of endpoint */
+	__raw_writel(hwrep, USBD_CTRL(udc->udp_baseaddr));
+
+	/* Wait until packet is ready */
+	while (((__raw_readl(USBD_RXPLEN(udc->udp_baseaddr)) & PKT_RDY) == 0)
+		&& (to > 0))
+		to--;
+	if (!to)
+		dev_dbg(udc->dev, "No packet ready on FIFO EP read\n");
+
+	/* Mask out count */
+	tmp = tmpv & PKT_LNGTH_MASK;
+	if (bytes < tmp) {
+		tmp = (u32) bytes;
+	}
+
+	if ((tmp > 0) && (data != NULL)) {
+		udc_pop_fifo(udc, (u8 *) data, tmp);
+	}
+
+	__raw_writel(((hwep & 0x1E) << 1), USBD_CTRL(udc->udp_baseaddr));
+
+	/* Clear the buffer */
+	udc_clr_buffer_hwep(udc, hwep);
+
+	return tmp;
+}
+
+/* Stuffs data into the FIFO, adjusts for alignment and data size */
+static void udc_stuff_fifo(struct lpc32xx_udc *udc, u8 *data, u32 bytes) {
+	int n, i, bl;
+	u16 *p16;
+	u32 *p32, tmp, cbytes;
+
+	/* Use optimal data transfer method based on source address and size */
+	switch (((u32) data) & 0x3) {
+		case 0: /* 32-bit aligned */
+			p32 = (u32 *) data;
+			cbytes = (bytes & ~0x3);
+
+			/* Copy 32-bit aligned data first */
+			for (n = 0; n < cbytes; n += 4)
+				__raw_writel(*p32++, USBD_TXDATA(udc->udp_baseaddr));
+
+			/* Handle any remaining bytes */
+			bl = bytes - cbytes;
+			if (bl) {
+				tmp = 0;
+				for (n = 0; n < bl; n++)
+					tmp |= (u32) (data[cbytes + n] << (n * 8));
+
+				__raw_writel(tmp, USBD_TXDATA(udc->udp_baseaddr));
+			}
+			break;
+
+		case 1: /* 8-bit aligned */
+		case 3:
+			/* Each byte has to be handled independently */
+			for (n = 0; n < bytes; n += 4) {
+				bl = bytes - n;
+				if (bl > 4)
+					bl = 4;
+
+				tmp = 0;
+				for (i = 0; i < bl; i++)
+					tmp |= (u32) (data[n + i] << (i * 8));
+
+				__raw_writel(tmp, USBD_TXDATA(udc->udp_baseaddr));
+			}
+			break;
+
+		case 2: /* 16-bit aligned */
+			p16 = (u16 *) data;
+			cbytes = (bytes & ~0x3);
+
+			/* Copy 32-bit aligned data first */
+			for (n = 0; n < cbytes; n += 4) {
+				tmp = (u32) (*p16++ & 0xFFFF);
+				tmp |= (u32) ((*p16++ & 0xFFFF) << 16);
+				__raw_writel(tmp, USBD_TXDATA(udc->udp_baseaddr));
+			}
+
+			/* Handle any remaining bytes */
+			bl = bytes - cbytes;
+			if (bl) {
+				tmp = 0;
+				for (n = 0; n < bl; n++)
+					tmp |= (u32) (data[cbytes + n] << (n * 8));
+
+				__raw_writel(tmp, USBD_TXDATA(udc->udp_baseaddr));
+			}
+			break;
+	}
+}
+
+/* Write data to the FIFO for an endpoint. This function is for endpoints (such
+   as EP0) that don't use DMA. Note that the endpoint must be selected in the
+   protocol engine prior to this call. */
+static void udc_write_hwep(struct lpc32xx_udc *udc, u32 hwep,
+		u32 *data, u32 bytes) {
+	u32 hwwep = ((hwep & 0x1E) << 1) | CTRL_WR_EN;
+
+	if ((bytes > 0) && (data == NULL)) {
+		return;
+	}
+
+	/* Setup write of endpoint */
+	__raw_writel(hwwep, USBD_CTRL(udc->udp_baseaddr));
+
+	__raw_writel(bytes, USBD_TXPLEN(udc->udp_baseaddr));
+
+	/* Need at least 1 byte to trigger TX */
+	if (bytes == 0) {
+		__raw_writel(0, USBD_TXDATA(udc->udp_baseaddr));
+	}
+	else {
+		udc_stuff_fifo(udc, (u8 *) data, bytes);
+	}
+
+	__raw_writel(((hwep & 0x1E) << 1), USBD_CTRL(udc->udp_baseaddr));
+
+	udc_val_buffer_hwep(udc, hwep);
+}
+
+/*
+ *
+ * USB protocol high level support functions
+ *
+ */
+/* Set/reset USB device address */
+static void udc_set_address(struct lpc32xx_udc *udc, u32 addr) {
+	/* Address will be latched at the end of the status phase, or
+	   latched immediately if function is called twice */
+	udc_protocol_cmd_data_w(udc, CMD_SET_ADDR,
+			DAT_WR_BYTE(DEV_EN | addr));
+}
+
+/* USB device reset - resets USB to a default state with just EP0
+   enabled */
+static void uda_usb_reset(struct lpc32xx_udc *udc) {
+	u32 i = 0;
+	/* Re-init device controller and EP0 */
+	udc_enable(udc);
+	udc->gadget.speed = USB_SPEED_FULL;
+
+	for (i = 1; i < NUM_ENDPOINTS; i++) {
+		struct lpc32xx_ep *ep = &udc->ep[i];
+		ep->req_pending = 0;
+	}
+}
+
+/* Send a ZLP on EP0 */
+static void udc_ep0_send_zlp(struct lpc32xx_udc *udc) {
+	udc_write_hwep(udc, EP_IN, NULL, 0);
+}
+
+/* Get current frame number */
+static u16 udc_get_current_frame(struct lpc32xx_udc *udc) {
+	u16 flo, fhi;
+
+	udc_protocol_cmd_w(udc, CMD_RD_FRAME);
+	flo = (u16) udc_protocol_cmd_r(udc, DAT_RD_FRAME);
+	fhi = (u16) udc_protocol_cmd_r(udc, DAT_RD_FRAME);
+
+	return (fhi << 8) | flo;
+}
+
+/* Set the device as configured - enables all endpoints */
+static inline void udc_set_device_configured(struct lpc32xx_udc *udc) {
+	udc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(CONF_DVICE));
+}
+
+/* Set the device as unconfigured - disables all endpoints */
+static inline void udc_set_device_unconfigured(struct lpc32xx_udc *udc) {
+	udc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(0));
+}
+
+/* reinit == restore inital software state */
+static void udc_reinit(struct lpc32xx_udc *udc)
+{
+	u32 i;
+
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+	INIT_LIST_HEAD(&udc->gadget.ep0->ep_list);
+
+	for (i = 0; i < NUM_ENDPOINTS; i++) {
+		struct lpc32xx_ep *ep = &udc->ep[i];
+
+		if (i != 0) {
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+		}
+		ep->desc = NULL;
+		ep->ep.maxpacket = ep->maxpacket;
+		INIT_LIST_HEAD(&ep->queue);
+		ep->req_pending = 0;
+	}
+
+	udc->ep0state = WAIT_FOR_SETUP;
+}
+
+/* Must be called with lock */
+static void done(struct lpc32xx_ep *ep, struct lpc32xx_request *req, int status)
+{
+	struct lpc32xx_udc *udc = ep->udc;
+
+	list_del_init(&req->queue);
+	if (req->req.status == -EINPROGRESS) {
+		req->req.status = status;
+	}
+	else {
+		status = req->req.status;
+	}
+
+	if (ep->lep) {
+		enum dma_data_direction direction;
+
+		if (ep->is_in)
+			direction = DMA_TO_DEVICE;
+		else
+			direction = DMA_FROM_DEVICE;
+
+		if (req->mapped) {
+			dma_unmap_single(ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length, direction);
+			req->req.dma = 0;
+			req->mapped = 0;
+		}
+		else {
+			dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length, direction);
+		}
+
+		/* Free DDs */
+		udc_dd_free(udc, req->dd_desc_ptr);
+	}
+
+	if (status && status != -ESHUTDOWN) {
+		ep_dbg(ep, "%s done %p, status %d\n", ep->ep.name, req, status);
+	}
+
+	ep->req_pending = 0;
+	spin_unlock(&udc->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&udc->lock);
+}
+
+/* Must be called with lock */
+static void nuke(struct lpc32xx_ep *ep, int status)
+{
+	struct lpc32xx_request *req;
+
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+		done(ep, req, status);
+	}
+
+	if (ep->desc) {
+		if (status == -ESHUTDOWN) {
+			uda_disable_hwepint(ep->udc, ep->hwep_num);
+			udc_disable_hwep(ep->udc, ep->hwep_num);
+		}
+	}
+}
+
+/* Must be called with lock */
+static void stop_activity(struct lpc32xx_udc *udc)
+{
+	struct usb_gadget_driver *driver = udc->driver;
+	int i;
+
+	if (udc->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = NULL;
+
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+	udc->suspended = 0;
+
+	for (i = 0; i < NUM_ENDPOINTS; i++) {
+		struct lpc32xx_ep *ep = &udc->ep[i];
+		nuke(ep, -ESHUTDOWN);
+	}
+	if (driver) {
+		spin_unlock(&udc->lock);
+		driver->disconnect(&udc->gadget);
+		spin_lock(&udc->lock);
+	}
+
+	isp1301_pullup_enable(udc, 0, 0);
+	udc_disable(udc);
+	udc_reinit(udc);
+}
+
+/*
+ * Activate or kill host pullup
+ * Can be called with or without lock
+ */
+static void pullup(struct lpc32xx_udc *udc, int is_on)
+{
+	if(!udc->clocked)
+		return;
+
+	if (!udc->enabled || !udc->vbus)
+		is_on = 0;
+
+	if (is_on != udc->pullup)
+		isp1301_pullup_enable(udc, is_on, 0);
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_disable (struct usb_ep * _ep)
+{
+	struct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);
+	struct lpc32xx_udc *udc = ep->udc;
+	unsigned long	flags;
+
+	if ((ep->hwep_num_base == 0) || (ep->hwep_num == 0)) {
+		return -EINVAL;
+	}
+	spin_lock_irqsave(&udc->lock, flags);
+
+	nuke(ep, -ESHUTDOWN);
+
+	/* restore the endpoint's pristine config */
+	ep->desc = NULL;
+
+	/* Clear all DMA statuses for this EP */
+	udc_ep_dma_disable(udc, ep->hwep_num);
+	__raw_writel((1 << ep->hwep_num), USBD_EOTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_NDDRTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_SYSERRTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_DMARCLR(udc->udp_baseaddr));
+
+	/* Remove the DD pointer in the UDCA */
+	udc->udca_v_base[ep->hwep_num] = 0;
+
+	/* Disable and reset endpoint and interrupt */
+	uda_clear_hwepint(udc, ep->hwep_num);
+	udc_unrealize_hwep(udc, ep->hwep_num);
+
+	ep->hwep_num = 0;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+        atomic_dec(&udc->enabled_ep_cnt);
+        wake_up(&udc->ep_disable_wait_queue);
+
+	return 0;
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_enable(struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
+{
+	struct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);
+	struct lpc32xx_udc *udc = ep->udc;
+	u16 maxpacket;
+	u32 tmp;
+	unsigned long flags;
+
+	/* Verify EP data */
+	if ((!_ep) || (!ep) || (!desc) || (ep->desc) ||
+			(desc->bDescriptorType != USB_DT_ENDPOINT) ||
+			((maxpacket = le16_to_cpu(desc->wMaxPacketSize)) == 0) ||
+			(maxpacket > ep->maxpacket)) {
+		dev_dbg(udc->dev, "bad ep or descriptor\n");
+		return -EINVAL;
+	}
+
+	/* Don't touch EP0 */
+	if (ep->hwep_num_base == 0) {
+		dev_dbg(udc->dev, "Can't re-enable EP0!!!\n");
+		return -EINVAL;
+	}
+
+	/* Is driver ready? */
+	if ((!udc->driver) || (udc->gadget.speed == USB_SPEED_UNKNOWN)) {
+		dev_dbg(udc->dev, "bogus device state\n");
+		return -ESHUTDOWN;
+	}
+
+	tmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	switch (tmp) {
+		case USB_ENDPOINT_XFER_CONTROL:
+			return -EINVAL;
+
+		case USB_ENDPOINT_XFER_INT:
+			if (maxpacket > ep->maxpacket) {
+				dev_dbg(udc->dev, "Bad INT endpoint maxpacket %d\n", maxpacket);
+				return -EINVAL;
+			}
+			break;
+
+		case USB_ENDPOINT_XFER_BULK:
+			switch (maxpacket) {
+				case 8:
+				case 16:
+				case 32:
+				case 64:
+					break;
+
+				default:
+					dev_dbg(udc->dev, "Bad BULK endpoint maxpacket %d\n", maxpacket);
+					return -EINVAL;
+			}
+			break;
+
+		case USB_ENDPOINT_XFER_ISOC:
+			break;
+	}
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* Initialize endpoint to match the selected descriptor */
+	ep->is_in = (desc->bEndpointAddress & USB_DIR_IN) != 0;
+	ep->desc = desc;
+	ep->ep.maxpacket = maxpacket;
+
+	/* Map hardware endpoint from base and direction */
+	if (ep->is_in) {
+		/* IN endpoints are offset 1 from the OUT endpoint */
+		ep->hwep_num = ep->hwep_num_base + EP_IN;
+	}
+	else {
+		ep->hwep_num = ep->hwep_num_base;
+	}
+
+	ep_dbg(ep, "EP enabled: %s, HW:%d, MP:%d IN:%d\n", ep->ep.name, ep->hwep_num,
+			maxpacket, (ep->is_in == 1));
+
+	/* Realize the endpoint, interrupt is enabled later when
+	   buffers are queued, IN EPs will NAK until buffers are ready */
+	udc_realize_hwep(udc, ep->hwep_num, ep->ep.maxpacket);
+	udc_clr_buffer_hwep(udc, ep->hwep_num);
+	uda_disable_hwepint(udc, ep->hwep_num);
+	udc_clrstall_hwep(udc, ep->hwep_num);
+
+	/* Clear all DMA statuses for this EP */
+	udc_ep_dma_disable(udc, ep->hwep_num);
+	__raw_writel((1 << ep->hwep_num), USBD_EOTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_NDDRTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_SYSERRTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_DMARCLR(udc->udp_baseaddr));
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	atomic_inc(&udc->enabled_ep_cnt);
+	return 0;
+}
+
+/*
+ * Allocate a USB request list
+ * Can be called with or without lock
+ */
+static struct usb_request *lpc32xx_ep_alloc_request(
+		struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct lpc32xx_request *req;
+
+	req = kzalloc(sizeof (struct lpc32xx_request), gfp_flags);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+	return &req->req;
+}
+
+/*
+ * De-allocate a USB request list
+ * Can be called with or without lock
+ */
+static void lpc32xx_ep_free_request(struct usb_ep *_ep,
+		struct usb_request *_req)
+{
+	struct lpc32xx_request *req;
+
+	req = container_of(_req, struct lpc32xx_request, req);
+	BUG_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_queue(struct usb_ep *_ep,
+		struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct lpc32xx_request *req;
+	struct lpc32xx_ep *ep;
+	struct lpc32xx_udc *udc;
+	unsigned long flags;
+	int status = 0;
+
+	req = container_of(_req, struct lpc32xx_request, req);
+	ep = container_of(_ep, struct lpc32xx_ep, ep);
+
+	if (!_req || !_req->complete || !_req->buf || !list_empty(&req->queue)) {
+		return -EINVAL;
+	}
+
+	udc = ep->udc;
+
+	if (!_ep || (!ep->desc && ep->hwep_num_base != 0)) {
+		dev_dbg(udc->dev, "invalid ep\n");
+		return -EINVAL;
+	}
+
+
+	if ((!udc) || (!udc->driver) || (udc->gadget.speed == USB_SPEED_UNKNOWN)) {
+		dev_dbg(udc->dev, "invalid device\n");
+		return -EINVAL;
+	}
+
+	if (ep->lep) {
+		enum dma_data_direction direction;
+		struct lpc32xx_usbd_dd_gad *dd;
+
+		/* Map DMA pointer */
+		if (ep->is_in)
+			direction = DMA_TO_DEVICE;
+		else
+			direction = DMA_FROM_DEVICE;
+
+		if (req->req.dma == 0) {
+			req->req.dma = dma_map_single(
+					ep->udc->gadget.dev.parent,
+					req->req.buf, req->req.length, direction);
+			req->mapped = 1;
+		}
+		else {
+			dma_sync_single_for_device(
+					ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length, direction);
+			req->mapped = 0;
+		}
+
+		/* For the request, build a list of DDs */
+		dd = udc_dd_alloc(udc);
+		if (!dd) {
+			/* Error allocating DD */
+			return -ENOMEM;
+		}
+		req->dd_desc_ptr = dd;
+
+		/* Setup the DMA descriptor */
+		dd->dd_next_phy = dd->dd_next_v = NULL;
+		dd->dd_buffer_addr = (u32) req->req.dma;
+		dd->dd_status = 0;
+
+		/* Special handling for ISO EPs */
+		if (ep->eptype == EP_ISO_TYPE) {
+			dd->dd_setup = DD_SETUP_ISO_EP |
+				DD_SETUP_PACKETLEN(0) |
+				DD_SETUP_DMALENBYTES(1);
+			dd->dd_iso_ps_mem_addr = (u32 *) ((u32) dd->this_dma + 24);
+			if (ep->is_in)
+				dd->iso_status[0] = req->req.length;
+			else
+				dd->iso_status[0] = 0;
+		}
+		else
+			dd->dd_setup = DD_SETUP_PACKETLEN(ep->ep.maxpacket) |
+				DD_SETUP_DMALENBYTES(req->req.length);
+	}
+
+	ep_dbg(ep, "%s queue req %p len %d buf %p (in=%d) z=%d\n", _ep->name, _req, _req->length,
+			_req->buf, ep->is_in, _req->zero);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+	req->send_zlp = _req->zero;
+
+	/* Kickstart empty queues */
+	if (list_empty(&ep->queue)) {
+		list_add_tail(&req->queue, &ep->queue);
+
+		if (ep->hwep_num_base == 0) {
+			/* Handle expected data direction */
+			if (ep->is_in) {
+				/* IN packet to host */
+				udc->ep0state = DATA_IN;
+				status = udc_ep0_in_req(udc);
+			}
+			else {
+				/* OUT packet from host */
+				udc->ep0state = DATA_OUT;
+				status = udc_ep0_out_req(udc);
+			}
+		}
+		else if (ep->is_in) {
+			/* IN packet to host and kick off transfer */
+			if (!ep->req_pending)
+				udc_ep_in_req_dma(udc, ep);
+		}
+		else {
+			/* OUT packet from host and kick off list */
+			if (!ep->req_pending)
+				udc_ep_out_req_dma(udc, ep);
+		}
+	}
+	else {
+		list_add_tail(&req->queue, &ep->queue);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return (status < 0) ? status : 0;
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct lpc32xx_ep	*ep;
+	struct lpc32xx_request	*req;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct lpc32xx_ep, ep);
+	if (!_ep || ep->hwep_num_base == 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry (req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		return -EINVAL;
+	}
+
+	done(ep, req, -ECONNRESET);
+
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	return 0;
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);
+	struct lpc32xx_udc *udc = ep->udc;
+	unsigned long flags;
+
+	if ((!ep) || (ep->desc == NULL) || (ep->hwep_num <= 1))
+		return -EINVAL;
+
+	/* Don't halt an IN EP */
+	if (ep->is_in)
+		return -EAGAIN;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (value == 1) {
+		/* stall */
+		udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(ep->hwep_num),
+				DAT_WR_BYTE(EP_STAT_ST));
+	}
+	else {
+		/* End stall */
+		udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(ep->hwep_num),
+				DAT_WR_BYTE(0));
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static const struct usb_ep_ops lpc32xx_ep_ops = {
+	.enable		= lpc32xx_ep_enable,
+	.disable	= lpc32xx_ep_disable,
+	.alloc_request	= lpc32xx_ep_alloc_request,
+	.free_request	= lpc32xx_ep_free_request,
+	.queue		= lpc32xx_ep_queue,
+	.dequeue	= lpc32xx_ep_dequeue,
+	.set_halt	= lpc32xx_ep_set_halt,
+};
+
+/* Setup up a IN request for DMA transfer - this consists of determining the
+   list of DMA addresses for the transfer, allocating DMA Descriptors,
+   installing the DD into the UDCA, and then enabling the DMA for that EP */
+static int udc_ep_in_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)
+{
+	struct lpc32xx_request *req;
+	u32 hwep = ep->hwep_num;
+
+	ep->req_pending = 1;
+
+	/* There will always be a request waiting here */
+	req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+
+	/* Place the DD Descriptor into the UDCA */
+	udc->udca_v_base[hwep] = (u32) req->dd_desc_ptr->this_dma;
+
+	/* Enable DMA and interrupt for the HW EP */
+	udc_ep_dma_enable(udc, hwep);
+
+	/* Clear ZLP if last packet is not of MAXP size */
+	if (req->req.length % ep->ep.maxpacket)
+		req->send_zlp = 0;
+
+	return 0;
+}
+
+/* Setup up a OUT request for DMA transfer - this consists of determining the
+   list of DMA addresses for the transfer, allocating DMA Descriptors,
+   installing the DD into the UDCA, and then enabling the DMA for that EP */
+static int udc_ep_out_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)
+{
+	struct lpc32xx_request *req;
+	u32 hwep = ep->hwep_num;
+
+	ep->req_pending = 1;
+
+	/* There will always be a request waiting here */
+	req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+
+	/* Place the DD Descriptor into the UDCA */
+	udc->udca_v_base[hwep] = (u32) req->dd_desc_ptr->this_dma;
+
+	/* Enable DMA and interrupt for the HW EP */
+	udc_ep_dma_enable(udc, hwep);
+	return 0;
+}
+/* Send a ZLP on a non-0 IN EP */
+void udc_send_in_zlp(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep) {
+	/* Clear EP status */
+	udc_clearep_getsts(udc, ep->hwep_num);
+
+	/* Send ZLP via FIFO mechanism */
+	udc_write_hwep(udc, ep->hwep_num, NULL, 0);
+}
+
+/*
+ * Handle EP completion for ZLP
+ * This function will only be called when a delayed ZLP needs to be sent out
+ * after a DMA transfer has filled both buffers.
+ */
+void udc_handle_eps(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep) {
+	u32 epstatus;
+	struct lpc32xx_request *req;
+
+	if (ep->hwep_num <= 0)
+		return;
+
+	uda_clear_hwepint(udc,ep->hwep_num);
+
+	/* If this interrupt isn't enabled, return now */
+	if (!(udc->enabled_hwepints & (1 << ep->hwep_num)))
+		return;
+
+	/* Get endpoint status */
+	epstatus = udc_clearep_getsts(udc, ep->hwep_num);
+
+	/*
+	 * This should never happen, but protect against writing to the
+	 * buffer when full.
+	 */
+	if (epstatus & EP_SEL_F)
+		return;
+
+	if (ep->is_in) {
+		udc_send_in_zlp(udc,ep);
+		uda_disable_hwepint(udc, ep->hwep_num);
+	}
+	else
+		return;
+
+	/* If there isn't a request waiting, something went wrong */
+	req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+	if (req) {
+		done(ep, req, 0);
+
+		/* Start another request if ready */
+		if(!list_empty(&ep->queue)) {
+			if (ep->is_in)
+				udc_ep_in_req_dma(udc, ep);
+			else
+				udc_ep_out_req_dma(udc, ep);
+		}
+		else
+			ep->req_pending = 0;
+	}
+}
+
+
+/* DMA end of transfer completion */
+static void udc_handle_dma_ep(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep) {
+	u32 status, epstatus;
+	struct lpc32xx_request *req;
+	struct lpc32xx_usbd_dd_gad *dd;
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+	ep->totalints++;
+#endif
+
+	req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+	if (!req) {
+		ep_err(ep, "DMA interrupt on no req!\n");
+		return;
+	}
+	dd = req->dd_desc_ptr;
+
+	/* DMA descriptor should always be retired for this call */
+	if (!(dd->dd_status & DD_STATUS_DD_RETIRED))
+		ep_warn(ep, "DMA descriptor did not retire\n");
+
+	/* Disable DMA */
+	udc_ep_dma_disable(udc, ep->hwep_num);
+	__raw_writel((1 << ep->hwep_num), USBD_EOTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_NDDRTINTCLR(udc->udp_baseaddr));
+
+	/* System error? */
+	if (__raw_readl(USBD_SYSERRTINTST(udc->udp_baseaddr)) & (1 << ep->hwep_num)) {
+		__raw_writel((1 << ep->hwep_num), USBD_SYSERRTINTCLR(udc->udp_baseaddr));
+		ep_err(ep, "AHB critical error!\n");
+		ep->req_pending = 0;
+
+		/* The error could of occurred on a packet of a multipacket transfer,
+		   so recovering the transfer is not possible. Close the request with
+		   an error */
+		done(ep, req, -ECONNABORTED);
+		return;
+	}
+
+	/* Handle the current DD's status */
+	status = dd->dd_status;
+	switch (status & DD_STATUS_STS_MASK) {
+		case DD_STATUS_STS_NS:
+			/* DD not serviced? This shouldn't happen! */
+			ep->req_pending = 0;
+			ep_err(ep, "DMA critical EP error: DD not serviced (0x%x)!\n", status);
+
+			done(ep, req, -ECONNABORTED);
+			return;
+
+		case DD_STATUS_STS_BS:
+			/* Interrupt only fires on EOT - This shouldn't happen! */
+			ep->req_pending = 0;
+			ep_err(ep, "DMA critical EP error: EOT prior to service completion (0x%x)!\n", status);
+			done(ep, req, -ECONNABORTED);
+			return;
+
+		case DD_STATUS_STS_NC:
+		case DD_STATUS_STS_DUR: /* Really just a short packet, not an underrun */
+			/* This is a good status and what we expect */
+			break;
+
+		default:
+			/* Data overrun, system error, or unknown */
+			ep->req_pending = 0;
+			ep_err(ep, "DMA critical EP error: System error (0x%x)!\n", status);
+			done(ep, req, -ECONNABORTED);
+			return;
+	}
+
+	/* ISO endpoints are handled differently */
+	if (ep->eptype == EP_ISO_TYPE) {
+		if (ep->is_in)
+			req->req.actual = req->req.length;
+		else
+			req->req.actual = dd->iso_status[0] & 0xFFFF;
+	} else
+		req->req.actual += DD_STATUS_CURDMACNT(status);
+
+	/* Send a ZLP if necessary. This will be done for non-int
+	   packets which have a size that is a divisor of MAXP */
+	if (req->send_zlp) {
+		/*
+		 * If at least 1 buffer is available, send the ZLP now.
+		 * Otherwise, the ZLP send needs to be deferred until a
+		 * buffer is available.
+		 */
+		if (udc_clearep_getsts(udc, ep->hwep_num) & EP_SEL_F) {
+			udc_clearep_getsts(udc, ep->hwep_num);
+			uda_enable_hwepint(udc, ep->hwep_num);
+			epstatus = udc_clearep_getsts(udc, ep->hwep_num);
+
+			/* Let the EP interrupt handle the ZLP */
+			return;
+		}
+		else
+			udc_send_in_zlp(udc, ep);
+	}
+
+	/* Transfer request is complete */
+	done(ep, req, 0);
+
+	/* Start another request if ready */
+	udc_clearep_getsts(udc, ep->hwep_num);
+	if(!list_empty((&ep->queue))) {
+		if (ep->is_in) {
+			udc_ep_in_req_dma(udc, ep);
+		}
+		else {
+			udc_ep_out_req_dma(udc, ep);
+		}
+	}
+	else
+		ep->req_pending = 0;
+
+}
+
+/*
+ *
+ * Endpoint 0 functions
+ * + *
+ * + */
+static void udc_handle_dev(struct lpc32xx_udc *udc) {
+	u32 tmp;
+
+	udc_protocol_cmd_w(udc, CMD_GET_DEV_STAT);
+	tmp = udc_protocol_cmd_r(udc, DAT_GET_DEV_STAT);
+
+	if (tmp & DEV_RST) {
+		uda_usb_reset(udc);
+	}
+	else if (tmp & DEV_CON_CH) {
+		uda_power_event(udc, (tmp & DEV_CON));
+	}
+	else if (tmp & DEV_SUS_CH) {
+		if (tmp & DEV_SUS) {
+			if (udc->vbus == 0)
+				stop_activity(udc);
+			else if ((udc->gadget.speed !=
+				USB_SPEED_UNKNOWN) && udc->driver) {
+				/* Power down transceiver */
+				udc->poweron = 0;
+				schedule_work(&udc->pullup_wq);
+				uda_resm_susp_event(udc, 1);
+			}
+		}
+		else {
+			if ((udc->gadget.speed != USB_SPEED_UNKNOWN) &&
+				udc->driver && udc->vbus) {
+				uda_resm_susp_event(udc, 0);
+				/* Power up transceiver */
+				udc->poweron = 1;
+				schedule_work(&udc->pullup_wq);
+			}
+		}
+	}
+}
+
+/* IN endpoint 0 transfer */
+static int udc_ep0_in_req(struct lpc32xx_udc *udc) {
+	struct lpc32xx_request *req;
+	struct lpc32xx_ep *ep0 = &udc->ep [0];
+	u32 tsend, ts = 0;
+
+	if (list_empty(&ep0->queue))
+	{
+		/* Nothing to send */
+		return 0;
+	}
+	else {
+		req = list_entry(ep0->queue.next,
+				struct lpc32xx_request, queue);
+	}
+
+	tsend = ts = req->req.length - req->req.actual;
+	if (ts == 0) {
+		/* Send a ZLP */
+		udc_ep0_send_zlp(udc);
+		done(ep0, req, 0);
+		return 1;
+	}
+	else if (ts > ep0->ep.maxpacket) {
+		/* Just send what we can */
+		ts = ep0->ep.maxpacket;
+	}
+
+	/* Write data to the EP0 FIFO and start transfer */
+	udc_write_hwep(udc, EP_IN, (req->req.buf + req->req.actual), ts);
+
+	/* Increment data pointer */
+	req->req.actual += ts;
+
+	if (tsend >= ep0->ep.maxpacket) {
+		/* Stay in data transfer state */
+		return 0;
+	}
+
+	/* Transfer request is complete */
+	udc->ep0state = WAIT_FOR_SETUP;
+	done(ep0, req, 0);
+	return 1;
+}
+
+/* OUT endpoint 0 transfer */
+static int udc_ep0_out_req(struct lpc32xx_udc *udc) {
+	struct lpc32xx_request *req;
+	struct lpc32xx_ep *ep0 = &udc->ep[0];
+	u32 tr, bufferspace;
+
+	if (list_empty(&ep0->queue)) {
+		return 0;
+	}
+	else {
+		req = list_entry(ep0->queue.next, struct lpc32xx_request, queue);
+	}
+
+	if (req) {
+		if (req->req.length == 0) {
+			/* Just dequeue request */
+			done(ep0, req, 0);
+			udc->ep0state = WAIT_FOR_SETUP;
+			return 1;
+		}
+
+		/* Get data from FIFO */
+		bufferspace = req->req.length - req->req.actual;
+		if (bufferspace > ep0->ep.maxpacket) {
+			bufferspace = ep0->ep.maxpacket;
+		}
+
+		/* Copy data to buffer */
+		prefetchw(req->req.buf + req->req.actual);
+		tr = udc_read_hwep(udc, EP_OUT,
+				(req->req.buf + req->req.actual), bufferspace);
+		req->req.actual += bufferspace;
+
+		if (tr < ep0->ep.maxpacket) {
+			/* This is the last packet */
+			done(ep0, req, 0);
+			udc->ep0state = WAIT_FOR_SETUP;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int udc_get_status(struct lpc32xx_udc *udc, u16 reqtype, u16 wIndex) {
+	struct lpc32xx_ep *ep;
+	u32 ep0buff = 0, tmp;
+
+	switch (reqtype & USB_RECIP_MASK) {
+		case USB_RECIP_INTERFACE:
+			/* Not supported */
+			break;
+
+		case USB_RECIP_DEVICE:
+			ep0buff = (udc->selfpowered << USB_DEVICE_SELF_POWERED);
+			if (udc->dev_status & (1 << USB_DEVICE_REMOTE_WAKEUP)) {
+				ep0buff |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+			}
+			break;
+
+		case USB_RECIP_ENDPOINT:
+			tmp = wIndex & USB_ENDPOINT_NUMBER_MASK;
+			ep = &udc->ep[tmp];
+			if ((tmp == 0) || (tmp >= NUM_ENDPOINTS) || (tmp && !ep->desc)) {
+				return -EOPNOTSUPP;
+			}
+
+			if (wIndex & USB_DIR_IN) {
+				if (!ep->is_in) {
+					/* Somethings wrong */
+					return -EOPNOTSUPP;
+				}
+			} else if (ep->is_in)
+				/* Not an IN endpoint */
+				return -EOPNOTSUPP;
+
+			/* Get status of the endpoint */
+			udc_protocol_cmd_w(udc, CMD_SEL_EP(ep->hwep_num));
+			tmp = udc_protocol_cmd_r(udc, DAT_SEL_EP(ep->hwep_num));
+
+			if (tmp & EP_SEL_ST) {
+				ep0buff = (1 << USB_ENDPOINT_HALT);
+			}
+			else {
+				ep0buff = 0;
+			}
+			break;
+
+		default:
+			break;
+	}
+
+	/* Return data */
+	udc_write_hwep(udc, EP_IN, &ep0buff, 2);
+
+	return 0;
+}
+
+static void udc_handle_ep0_setup(struct lpc32xx_udc *udc) {
+	struct lpc32xx_ep *ep, *ep0 = &udc->ep[0];
+	struct usb_ctrlrequest ctrlpkt;
+	int i, bytes;
+	u16 wIndex, wValue, wLength, reqtype, req, tmp;
+
+	/* Nuke previous transfers */
+	nuke(ep0, -EPROTO);
+
+	/* Get setup packet */
+	bytes = udc_read_hwep(udc, EP_OUT, (u32 *) &ctrlpkt, 8);
+	if (bytes != 8) {
+		ep_warn(ep0, "Incorrectly sized setup packet (s/b 8, is %d!\n", bytes);
+		return;
+	}
+
+	/* Native endianness */
+	wIndex = le16_to_cpu(ctrlpkt.wIndex);
+	wValue = le16_to_cpu(ctrlpkt.wValue);
+	wLength = le16_to_cpu(ctrlpkt.wLength);
+	reqtype = le16_to_cpu(ctrlpkt.bRequestType);
+
+	/* Set direction of EP0 */
+	if (likely(reqtype & USB_DIR_IN)) {
+		ep0->is_in = 1;
+	} else {
+		ep0->is_in = 0;
+	}
+
+	/* Handle SETUP packet */
+	req = le16_to_cpu(ctrlpkt.bRequest);
+	switch (req) {
+		case USB_REQ_CLEAR_FEATURE:
+		case USB_REQ_SET_FEATURE:
+			switch (reqtype) {
+				case (USB_TYPE_STANDARD | USB_RECIP_DEVICE):
+					if (wValue != USB_DEVICE_REMOTE_WAKEUP) {
+						/* Nothing else handled */
+						goto stall;
+					}
+
+					/* Tell board about event */
+					if (req == USB_REQ_CLEAR_FEATURE)
+						udc->dev_status &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+					else
+						udc->dev_status |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+					uda_remwkp_cgh(udc);
+					goto zlp_send;
+
+				case (USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):
+					tmp = wIndex & USB_ENDPOINT_NUMBER_MASK;
+					if ((wValue != USB_ENDPOINT_HALT) || (tmp >= NUM_ENDPOINTS))
+						break;
+
+					/* Find hardware endpoint from logical endpoint */
+					ep = &udc->ep[tmp];
+					tmp = ep->hwep_num;
+					if (tmp == 0)
+						break;
+
+					if (req == USB_REQ_SET_FEATURE)
+						udc_stall_hwep(udc, tmp);
+					else
+						udc_clrstall_hwep(udc, tmp);
+
+					goto zlp_send;
+
+				default:
+					break;
+			}
+
+
+		case USB_REQ_SET_ADDRESS:
+			if (reqtype == (USB_TYPE_STANDARD | USB_RECIP_DEVICE)) {
+				udc_set_address(udc, wValue);
+				goto zlp_send;
+			}
+			break;
+
+		case USB_REQ_GET_STATUS:
+			udc_get_status(udc, reqtype, wIndex);
+			return;
+
+		default:
+			/* Let GadgetFs handle the descriptor instead */
+			break;
+	}
+
+	if (likely(udc->driver)) {
+		/* device-2-host (IN) or no data setup command, process immediately */
+		spin_unlock(&udc->lock);
+		i = udc->driver->setup(&udc->gadget, &ctrlpkt);
+
+		spin_lock(&udc->lock);
+		if (req == USB_REQ_SET_CONFIGURATION) {
+			/* Configuration is set after endpoints are realized */
+			if (wValue) {
+				/* Set configuration */
+				udc_set_device_configured(udc);
+
+				/* NAK EP interrupts do not need to be enabled for this
+				   driver, but if you really want them for statistic
+				   purposes, uncomment the following lines */
+				udc_protocol_cmd_data_w(udc, CMD_SET_MODE, DAT_WR_BYTE(AP_CLK |
+							INAK_BI | INAK_II));
+			}
+			else {
+				/* Clear configuration */
+				udc_set_device_unconfigured(udc);
+
+				/* Disable NAK interrupts */
+				udc_protocol_cmd_data_w(udc, CMD_SET_MODE, DAT_WR_BYTE(AP_CLK));
+			}
+		}
+
+		if (i < 0) {
+			/* setup processing failed, force stall */
+			dev_err(udc->dev, "req %02x.%02x protocol STALL; stat %d\n",
+					reqtype, req, i);
+			udc->ep0state = WAIT_FOR_SETUP;
+			goto stall;
+		}
+	}
+
+	if (!ep0->is_in) {
+		/* ZLP IN packet on on data phase */
+		udc_ep0_send_zlp(udc);
+	}
+
+	return;
+
+stall:
+	udc_stall_hwep(udc, EP_IN);
+	return;
+
+zlp_send:
+	udc_ep0_send_zlp(udc);
+	return;
+}
+
+/* IN endpoint 0 transfer */
+static void udc_handle_ep0_in(struct lpc32xx_udc *udc) {
+	struct lpc32xx_ep *ep0 = &udc->ep [0];
+	u32 epstatus;
+
+	/* Clear EP interrupt */
+	epstatus = udc_clearep_getsts(udc, EP_IN);
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+	ep0->totalints++;
+#endif
+
+	/* Stalled? Clear stall and reset buffers */
+	if (epstatus & EP_SEL_ST) {
+		udc_clrstall_hwep(udc, EP_IN);
+		nuke(ep0, -ECONNABORTED);
+		udc->ep0state = WAIT_FOR_SETUP;
+		return;
+	}
+
+	/* Is a buffer available? */
+	if (!(epstatus & EP_SEL_F)) {
+		/* Handle based on current state */
+		if (udc->ep0state == DATA_IN) {
+			udc_ep0_in_req(udc);
+		}
+		else {
+			/* Unknown state for EP0 oe end of DATA IN phase */
+			nuke(ep0, -ECONNABORTED);
+			udc->ep0state = WAIT_FOR_SETUP;
+		}
+	}
+}
+
+/* OUT endpoint 0 transfer */
+static void udc_handle_ep0_out(struct lpc32xx_udc *udc) {
+	struct lpc32xx_ep *ep0 = &udc->ep[0];
+	u32 epstatus;
+
+	/* Clear EP interrupt */
+	epstatus = udc_clearep_getsts(udc, EP_OUT);
+
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+	ep0->totalints++;
+#endif
+
+	/* Stalled? */
+	if (epstatus & EP_SEL_ST) {
+		udc_clrstall_hwep(udc, EP_OUT);
+		nuke(ep0, -ECONNABORTED);
+		udc->ep0state = WAIT_FOR_SETUP;
+		return;
+	}
+
+	/* A NAK may occur if a packet coudn't be received yet */
+	if (epstatus & EP_SEL_EPN) {
+		return;
+	}
+	/* Setup packet incoming? */
+	if (epstatus & EP_SEL_STP) {
+		nuke(ep0, 0);
+		udc->ep0state = WAIT_FOR_SETUP;
+	}
+
+	/* Data available? */
+	if (epstatus & EP_SEL_F) {
+		/* Handle based on current state */
+		switch (udc->ep0state) {
+			case WAIT_FOR_SETUP:
+				udc_handle_ep0_setup(udc);
+				break;
+
+			case DATA_OUT:
+				udc_ep0_out_req(udc);
+				break;
+
+			default:
+				/* Unknown state for EP0 */
+				nuke(ep0, -ECONNABORTED);
+				udc->ep0state = WAIT_FOR_SETUP;
+		}
+	}
+}
+
+/* Must be called without lock */
+static int lpc32xx_get_frame(struct usb_gadget *gadget)
+{
+	int frame;
+	unsigned long flags;
+	struct lpc32xx_udc *udc = to_udc(gadget);
+
+	if (!udc->clocked)
+		return -EINVAL;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	frame = (int) udc_get_current_frame(udc);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return frame;
+}
+
+static int lpc32xx_wakeup(struct usb_gadget *gadget)
+{
+	return -ENOTSUPP;
+}
+
+static int lpc32xx_set_selfpowered(struct usb_gadget *gadget, int is_on)
+{
+	struct lpc32xx_udc *udc = to_udc(gadget);
+
+	/* Always self-powered */
+	udc->selfpowered = (is_on != 0);
+
+	return 0;
+	return -ENOTSUPP;
+}
+
+/*
+ * vbus is here!  turn everything on that's ready
+ * Must be called without lock
+ */
+static int lpc32xx_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	unsigned long flags;
+	struct lpc32xx_udc *udc = to_udc(gadget);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* Doesn't need lock */
+	if (udc->driver) {
+		udc_clk_set(udc, 1);
+		udc_enable(udc);
+		pullup(udc, is_active);
+	}
+	else {
+		stop_activity(udc);
+		pullup(udc, 0);
+
+		spin_unlock_irqrestore(&udc->lock, flags);
+                /*
+		 *  Wait for all the endpoints to disable,
+		 *  before disabling clocks. Don't wait if
+		 *  endpoints are not enabled.
+		 */
+		if(atomic_read(&udc->enabled_ep_cnt))
+			wait_event_interruptible(udc->ep_disable_wait_queue,
+					(atomic_read(&udc->enabled_ep_cnt) == 0));
+
+		spin_lock_irqsave(&udc->lock, flags);
+
+		udc_clk_set(udc, 0);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+/* Can be called with or without lock */
+static int lpc32xx_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct lpc32xx_udc *udc = to_udc(gadget);
+
+	/* Doesn't need lock */
+	pullup(udc, is_on);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops lpc32xx_udc_ops = {
+	.get_frame		= lpc32xx_get_frame,
+	.wakeup			= lpc32xx_wakeup,
+	.set_selfpowered	= lpc32xx_set_selfpowered,
+	.vbus_session		= lpc32xx_vbus_session,
+	.pullup			= lpc32xx_pullup,
+};
+
+static void nop_release(struct device *dev)
+{
+	/* nothing to free */
+}
+
+static struct lpc32xx_udc controller = {
+	.gadget = {
+		.ops	= &lpc32xx_udc_ops,
+		.ep0	= &controller.ep[0].ep,
+		.name	= driver_name,
+		.dev	= {
+			.init_name = "gadget",
+			.release = nop_release,
+		}
+	},
+	.ep[0] = {
+		.ep = {
+			.name	= "ep0",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 0,
+		.hwep_num	= 0, /* Can be 0 or 1, has special handling */
+		.lep		= 0,
+		.eptype		= EP_CTL_TYPE,
+	},
+	.ep[1] = {
+		.ep = {
+			.name	= "ep1-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 2,
+		.hwep_num	= 0, /* 2 or 3, will be set later */
+		.lep		= 1,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[2] = {
+		.ep = {
+			.name	= "ep2-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 4,
+		.hwep_num	= 0, /* 4 or 5, will be set later */
+		.lep		= 2,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[3] = {
+		.ep = {
+			.name	= "ep3-iso",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 6,
+		.hwep_num	= 0, /* 6 or 7, will be set later */
+		.lep		= 3,
+		.eptype		= EP_ISO_TYPE,
+	},
+	.ep[4] = {
+		.ep = {
+			.name	= "ep4-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 8,
+		.hwep_num	= 0, /* 8 or 9, will be set later */
+		.lep		= 4,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[5] = {
+		.ep = {
+			.name	= "ep5-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 10,
+		.hwep_num	= 0, /* 10 or 11, will be set later */
+		.lep		= 5,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[6] = {
+		.ep = {
+			.name	= "ep6-iso",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 12,
+		.hwep_num	= 0, /* 12 or 13, will be set later */
+		.lep		= 6,
+		.eptype		= EP_ISO_TYPE,
+	},
+	.ep[7] = {
+		.ep = {
+			.name	= "ep7-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 14,
+		.hwep_num	= 0,
+		.lep		= 7,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[8] = {
+		.ep = {
+			.name	= "ep8-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 16,
+		.hwep_num	= 0,
+		.lep		= 8,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[9] = {
+		.ep = {
+			.name	= "ep9-iso",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 18,
+		.hwep_num	= 0,
+		.lep		= 9,
+		.eptype		= EP_ISO_TYPE,
+	},
+	.ep[10] = {
+		.ep = {
+			.name	= "ep10-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 20,
+		.hwep_num	= 0,
+		.lep		= 10,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[11] = {
+		.ep = {
+			.name	= "ep11-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 22,
+		.hwep_num	= 0,
+		.lep		= 11,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[12] = {
+		.ep = {
+			.name	= "ep12-iso",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 24,
+		.hwep_num	= 0,
+		.lep		= 12,
+		.eptype		= EP_ISO_TYPE,
+	},
+	.ep[13] = {
+		.ep = {
+			.name	= "ep13-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 26,
+		.hwep_num	= 0,
+		.lep		= 13,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[14] = {
+		.ep = {
+			.name	= "ep14-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 28,
+		.hwep_num	= 0,
+		.lep		= 14,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[15] = {
+		.ep = {
+			.name	= "ep15-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 30,
+		.hwep_num	= 0,
+		.lep		= 15,
+		.eptype		= EP_BLK_TYPE,
+	},
+};
+
+/* ISO and status interrupts */
+static irqreturn_t lpc32xx_usb_lp_irq(int irq, void *_udc) {
+	u32 tmp, devstat;
+	struct lpc32xx_udc *udc = _udc;
+
+	spin_lock(&udc->lock);
+
+	/* Read the device status register */
+	devstat = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+
+	devstat &= ~USBD_EP_FAST;
+	__raw_writel(devstat, USBD_DEVINTCLR(udc->udp_baseaddr));
+	devstat = devstat & udc->enabled_devints;
+
+	/* Device specific handling needed? */
+	if (devstat & USBD_DEV_STAT) {
+		udc_handle_dev(udc);
+	}
+
+	/* Start of frame? */
+	if (devstat & FRAME_INT) {
+		/* The frame interrupt isn't really needed for ISO support,
+		   as the driver will queue the necessary packets */
+	}
+
+	/* Error? */
+	if (devstat & ERR_INT) {
+		/* All types of errors, from cable removal during transfer to
+		   misc protocol and bit errors. These are mostly for just info,
+		   as the USB hardware will work around these. If these errors
+		   happen alot, something is wrong. */
+		udc_protocol_cmd_w(udc, CMD_RD_ERR_STAT);
+		tmp = udc_protocol_cmd_r(udc, DAT_RD_ERR_STAT);
+		dev_dbg(udc->dev, "Device error (0x%x)!\n", tmp);
+	}
+
+	spin_unlock(&udc->lock);
+
+	return IRQ_HANDLED;
+}
+
+/* EP interrupts */
+static irqreturn_t lpc32xx_usb_hp_irq(int irq, void *_udc)
+{
+	u32 tmp;
+	struct lpc32xx_udc *udc = _udc;
+
+	spin_lock(&udc->lock);
+
+	/* Read the device status register */
+	__raw_writel(USBD_EP_FAST, USBD_DEVINTCLR(udc->udp_baseaddr));
+
+	/* Endpoints */
+	tmp = __raw_readl(USBD_EPINTST(udc->udp_baseaddr));
+
+	/* Special handling for EP0 */
+	if (tmp & (EP_MASK_SEL(0, EP_OUT) | EP_MASK_SEL(0, EP_IN))) {
+		/* Handle EP0 IN */
+		if (tmp & (EP_MASK_SEL(0, EP_IN)))
+			udc_handle_ep0_in(udc);
+
+		/* Handle EP0 OUT */
+		if (tmp & (EP_MASK_SEL(0, EP_OUT)))
+			udc_handle_ep0_out(udc);
+	}
+
+	/* All other EPs */
+	if (tmp & ~(EP_MASK_SEL(0, EP_OUT) | EP_MASK_SEL(0, EP_IN))) {
+		int i;
+
+		/* Handle other EP interrupts */
+		for (i = 1; i < NUM_ENDPOINTS; i++) {
+			if (tmp & (1 << udc->ep [i].hwep_num))
+				udc_handle_eps(udc, &udc->ep[i]);
+		}
+	}
+
+	spin_unlock(&udc->lock);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lpc32xx_usb_devdma_irq(int irq, void *_udc)
+{
+	struct lpc32xx_udc *udc = _udc;
+
+	int i;
+	u32 tmp;
+
+	spin_lock(&udc->lock);
+
+	/* Handle EP DMA EOT interrupts */
+	tmp = __raw_readl(USBD_EOTINTST(udc->udp_baseaddr)) |
+		(__raw_readl(USBD_EPDMAST(udc->udp_baseaddr)) &
+		__raw_readl(USBD_NDDRTINTST(udc->udp_baseaddr))) |
+		__raw_readl(USBD_SYSERRTINTST(udc->udp_baseaddr));
+	for (i = 1; i < NUM_ENDPOINTS; i++) {
+		if (tmp & (1 << udc->ep [i].hwep_num))
+			udc_handle_dma_ep(udc, &udc->ep[i]);
+	}
+
+	spin_unlock(&udc->lock);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *
+ * VBUS detection, pullup handler, and Gadget cable state notification
+ *
+ */
+static void vbus_work(struct work_struct *work)
+{
+	u8 value;
+	struct lpc32xx_udc *udc = container_of(work, struct lpc32xx_udc, vbus_wq);
+
+	if (udc->enabled != 0) {
+		/* Discharge VBUS real quick */
+		i2c_write(OTG1_VBUS_DISCHRG, ISP1301_I2C_OTG_CONTROL_1);
+
+		/* Give VBUS some time (100mS) to discharge */
+		msleep(100);
+
+		/* Disable VBUS discharge resistor */
+		i2c_write(OTG1_VBUS_DISCHRG,
+			(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+
+		/* Clear interrupt */
+		i2c_write(~0, ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR);
+
+		/* Get the VBUS status from the transceiver */
+		value = i2c_read(ISP1301_I2C_OTG_CONTROL_2);
+
+		/* VBUS on or off? */
+		if (value & OTG_B_SESS_VLD)
+			udc->vbus = 1;
+		else
+			udc->vbus = 0;
+
+		/* VBUS changed? */
+		if (udc->last_vbus != udc->vbus) {
+			udc->last_vbus = udc->vbus;
+			lpc32xx_vbus_session(&udc->gadget, udc->vbus);
+		}
+	}
+
+	/* Re-enable after completion */
+	enable_irq(udc->udp_irq[IRQ_USB_ATX]);
+}
+
+static irqreturn_t lpc32xx_usb_vbus_irq(int irq, void *_udc)
+{
+	struct lpc32xx_udc *udc = _udc;
+
+	/* Defer handling of VBUS IRQ to work queue */
+	disable_irq_nosync(udc->udp_irq[IRQ_USB_ATX]);
+	schedule_work(&udc->vbus_wq);
+
+	return IRQ_HANDLED;
+}
+
+int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
+		int (*bind)(struct usb_gadget *))
+{
+	struct lpc32xx_udc *udc = &controller;
+	int retval, i;
+
+	if (!driver || driver->speed < USB_SPEED_FULL ||
+			!bind || !driver->setup) {
+		dev_err(udc->dev, "bad parameter.\n");
+		return -EINVAL;
+	}
+
+	if (udc->driver) {
+		dev_err(udc->dev, "UDC already has a gadget driver\n");
+		return -EBUSY;
+	}
+
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+	udc->enabled = 1;
+	udc->selfpowered = 1;
+	udc->vbus = 0;
+
+	retval = bind(&udc->gadget);
+	if (retval) {
+		dev_err(udc->dev, "bind() returned %d\n", retval);
+		udc->enabled = 0;
+		udc->selfpowered = 0;
+		udc->driver = NULL;
+		udc->gadget.dev.driver = NULL;
+		return retval;
+	}
+
+	dev_dbg(udc->dev, "bound to %s\n", driver->driver.name);
+
+	/* Force VBUS process once to check for cable insertion */
+	udc->last_vbus = udc->vbus = 0;
+	schedule_work(&udc->vbus_wq);
+
+	/* Do not re-enable ATX IRQ (3) */
+	for (i = IRQ_USB_LP; i < IRQ_USB_ATX; i++)
+		enable_irq(udc->udp_irq[i]);
+
+	return 0;
+}
+EXPORT_SYMBOL (usb_gadget_probe_driver);
+
+int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
+{
+	int i;
+	struct lpc32xx_udc *udc = &controller;
+
+	if (!driver || driver != udc->driver || !driver->unbind)
+		return -EINVAL;
+
+	/* Disable USB pullup */
+	isp1301_pullup_enable(udc, 0, 1);
+
+	for (i = IRQ_USB_LP; i <= IRQ_USB_ATX; i++)
+		disable_irq(udc->udp_irq[i]);
+
+	if (udc->clocked) {
+
+		spin_lock(&udc->lock);
+		stop_activity(udc);
+		spin_unlock(&udc->lock);
+
+                /*
+		 *  Wait for all the endpoints to disable,
+		 *  before disabling clocks. Don't wait if
+		 *  endpoints are not enabled.
+		 */
+		if(atomic_read(&udc->enabled_ep_cnt))
+			wait_event_interruptible(udc->ep_disable_wait_queue,
+					(atomic_read(&udc->enabled_ep_cnt) == 0));
+
+		spin_lock(&udc->lock);
+		udc_clk_set(udc, 0);
+		spin_unlock(&udc->lock);
+	}
+
+	udc->enabled = 0;
+	pullup(udc, 0);
+
+	driver->unbind(&udc->gadget);
+	udc->gadget.dev.driver = NULL;
+	udc->driver = NULL;
+
+	dev_dbg(udc->dev, "unbound from %s\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL (usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------*/
+
+static void lpc32xx_udc_shutdown(struct platform_device *dev)
+{
+	/* Force disconnect on reboot */
+	struct lpc32xx_udc *udc = &controller;
+
+	pullup(udc, 0);
+}
+
+static int __init lpc32xx_udc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct lpc32xx_udc *udc = &controller;
+	int retval, i;
+	struct resource *res;
+	dma_addr_t dma_handle;
+	struct i2c_adapter *i2c_adap;
+	struct i2c_board_info i2c_info;
+
+	/* init software state */
+	udc->gadget.dev.parent = dev;
+	udc->pdev = pdev;
+	udc->dev = &pdev->dev;
+	udc->enabled = 0;
+
+	if (!dev->platform_data) {
+		dev_err(udc->dev, "missing platform_data\n");
+		return -ENODEV;
+	}
+
+	udc->board = (struct lpc32xx_usbd_cfg *) dev->platform_data;
+
+	/*
+	 * Resources are mapped as follows:
+	 *  [0] = IORESOURCE_MEM, base address and size of USB space
+	 *  [1] = IORESOURCE_IRQ, USB device low priority interrupt number
+	 *  [2] = IORESOURCE_IRQ, USB device high priority interrupt number
+	 *  [3] = IORESOURCE_IRQ, USB device interrupt number
+	 *  [4] = IORESOURCE_IRQ, USB transciever interrupt number
+	 */
+	if (pdev->num_resources != 5) {
+		dev_err(udc->dev, "invalid num_resources\n");
+		return -ENODEV;
+	}
+
+	if (pdev->resource[0].flags != IORESOURCE_MEM) {
+		dev_err(udc->dev, "invalid resource type\n");
+		return -ENODEV;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	spin_lock_init(&udc->lock);
+
+	/* Get IRQs */
+	for (i = 0; i < 4; i++) {
+		if (pdev->resource[i + 1].flags != IORESOURCE_IRQ) {
+			dev_err(udc->dev, "invalid resource type\n");
+			return -ENODEV;
+		}
+		udc->udp_irq[i] = platform_get_irq(pdev, i);
+	}
+
+	udc->io_p_start = res->start;
+	udc->io_p_size = res->end - res->start + 1;
+	if (!request_mem_region(udc->io_p_start, udc->io_p_size, driver_name)) {
+		dev_err(udc->dev, "someone's using UDC memory\n");
+		return -EBUSY;
+	}
+
+	/* Enable AHB slave USB clock, needed for further USB clock control */
+	__raw_writel(USB_SLAVE_HCLK_EN | (1 << 19), USB_CTRL);
+
+	/* Get required clocks */
+	udc->usb_pll_clk = clk_get(&pdev->dev, "ck_pll5");
+	if (IS_ERR(udc->usb_pll_clk)) {
+		dev_err(udc->dev, "failed to acquire USB PLL");
+		retval = PTR_ERR(udc->usb_pll_clk);
+		goto pll_get_fail;
+	}
+	udc->usb_slv_clk = clk_get(&pdev->dev, "ck_usbd");
+	if (IS_ERR(udc->usb_slv_clk)) {
+		dev_err(udc->dev, "failed to acquire USB device clock");
+		retval = PTR_ERR(udc->usb_slv_clk);
+		goto usb_clk_get_fail;
+	}
+
+	/* Setup PLL clock to 48MHz */
+	retval = clk_enable(udc->usb_pll_clk);
+	if (retval < 0) {
+		dev_err(udc->dev, "failed to start USB PLL");
+		goto pll_enable_fail;
+	}
+
+	retval = clk_set_rate(udc->usb_pll_clk, 48000);
+	if (retval < 0) {
+		dev_err(udc->dev, "failed to set USB clock rate");
+		goto pll_set_fail;
+	}
+
+	__raw_writel(__raw_readl(USB_CTRL) | USB_DEV_NEED_CLK_EN, USB_CTRL);
+
+	/* Enable USB device clock */
+	retval = clk_enable(udc->usb_slv_clk);
+	if (retval < 0) {
+		dev_err(udc->dev, "failed to start USB device clock");
+		goto usb_clk_enable_fail;
+	}
+
+	/* Set to enable all needed USB OTG clocks */
+	__raw_writel(USB_CLOCK_MASK, USB_OTG_CLK_CTRL);
+
+	i = 1000;
+	while (((__raw_readl(USB_OTG_CLK_STAT) & USB_CLOCK_MASK) !=
+			USB_CLOCK_MASK) && (i > 0))
+		i--;
+	if (!i)
+		dev_dbg(udc->dev, "USB OTG clocks not correctly enabled\n");
+
+	/* Setup deferred workqueue data */
+	udc->poweron = udc->pullup = 0;
+	INIT_WORK(&udc->pullup_wq, pullup_work);
+	INIT_WORK(&udc->vbus_wq, vbus_work);
+#ifdef CONFIG_PM
+	INIT_WORK(&udc->power_wq, power_work);
+#endif
+
+	/* All clocks are now on */
+	udc->clocked = 1;
+
+	retval = i2c_add_driver(&isp1301_driver);
+	if (retval < 0) {
+		dev_err(udc->dev, "Failed to add ISP1301 driver \n");
+		goto i2c_add_fail;
+	}
+	i2c_adap = i2c_get_adapter(2);
+	memset(&i2c_info, 0, sizeof(struct i2c_board_info));
+	isp1301_i2c_client = i2c_new_probed_device(i2c_adap, &i2c_info,
+			normal_i2c, NULL);
+	i2c_put_adapter(i2c_adap);
+	if (!isp1301_i2c_client) {
+		dev_err(udc->dev,"failed to connect I2C to ISP1301 USB Transceiver");
+		goto i2c_probe_fail;
+	}
+
+	dev_info(udc->dev, "I2C device at address 0x%x", isp1301_i2c_client->addr);
+
+	isp1301_udc_configure(udc);
+	/* Map register space */
+	udc->udp_baseaddr = ioremap(udc->io_p_start, udc->io_p_size);
+	if (!udc->udp_baseaddr) {
+		retval = -ENOMEM;
+		dev_err(udc->dev, "IO map failure");
+		goto io_map_fail;
+	}
+
+	/* Allocate memory for the UDCA */
+	udc->udca_v_base = dma_alloc_coherent(&pdev->dev, UDCA_BUFF_SIZE,
+			&dma_handle, (GFP_KERNEL | GFP_DMA));
+	if (!udc->udca_v_base)
+	{
+		dev_err(udc->dev, "error getting UDCA region");
+		retval = -ENOMEM;
+		goto dma_alloc_fail;
+	}
+	udc->udca_p_base = (void *) dma_handle;
+	dev_dbg(udc->dev, "DMA buffer(0x%x bytes), P:0x%08x, V:0x%08x",
+			UDCA_BUFF_SIZE, (u32) udc->udca_p_base, (u32) udc->udca_v_base);
+
+	/* Setup the DD DMA memory pool */
+	udc->dd_cache = dma_pool_create ("udc_dd", udc->dev,
+			sizeof (struct lpc32xx_usbd_dd_gad), sizeof (u32), 0);
+	if (!udc->dd_cache) {
+		dev_err(udc->dev, "error getting DD DMA region");
+		retval = -ENOMEM;
+		goto dma2_alloc_fail;
+	}
+
+	/* Clear USB peripheral and initialize gadget endpoints */
+	udc_disable(udc);
+	udc_reinit(udc);
+
+	retval = device_register(&udc->gadget.dev);
+	if (retval < 0) {
+		dev_err(udc->dev, "Device registration failure");
+		goto dev_register_fail;
+	}
+
+	/* Request IRQs - low and high priority USB device IRQs are routed to the
+	   same handler, while the DMA interrupt is routed elsewhere */
+	retval = request_irq(udc->udp_irq[IRQ_USB_LP], lpc32xx_usb_lp_irq,
+			0, "udc_lp", udc);
+	if (retval < 0) {
+		dev_err(udc->dev, "LP request irq %d failed", udc->udp_irq[IRQ_USB_LP]);
+		goto irq_lp_fail;
+	}
+	retval = request_irq(udc->udp_irq[IRQ_USB_HP], lpc32xx_usb_hp_irq,
+			0, "udc_hp", udc);
+	if (retval < 0) {
+		dev_err(udc->dev, "HP request irq %d failed", udc->udp_irq[IRQ_USB_HP]);
+		goto irq_hp_fail;
+	}
+
+	retval = request_irq(udc->udp_irq[IRQ_USB_DEVDMA], lpc32xx_usb_devdma_irq,
+			0, "udc_dma", udc);
+	if (retval < 0) {
+		dev_err(udc->dev, "DEV request irq %d failed", udc->udp_irq[IRQ_USB_DEVDMA]);
+		goto irq_dev_fail;
+	}
+
+	/* The transceiver interrupt is used for VBUS detection and will
+	   kick off the VBUS handler function */
+	retval = request_irq(udc->udp_irq[IRQ_USB_ATX], lpc32xx_usb_vbus_irq,
+				 0, "udc_otg", udc);
+	if (retval < 0) {
+		dev_err(udc->dev, "VBUS request irq %d failed\n", udc->udp_irq[IRQ_USB_ATX]);
+		goto irq_xcvr_fail;
+	}
+
+        /* Initialize wait queue */
+        init_waitqueue_head(&udc->ep_disable_wait_queue);
+        atomic_set(&udc->enabled_ep_cnt,0);
+
+	/* Keep all IRQs disabled until GadgetFS starts up */
+	for (i = IRQ_USB_LP; i <= IRQ_USB_ATX; i++)
+		disable_irq(udc->udp_irq[i]);
+
+	dev_set_drvdata(dev, udc);
+	device_init_wakeup(dev, 1);
+	create_debug_file(udc);
+
+	/* Disable clocks for now */
+	udc_clk_set(udc, 0);
+
+	dev_info(udc->dev, "%s version %s\n", driver_name, DRIVER_VERSION);
+	return 0;
+
+irq_xcvr_fail:
+	free_irq(udc->udp_irq[IRQ_USB_DEVDMA], udc);
+irq_dev_fail:
+	free_irq(udc->udp_irq[IRQ_USB_HP], udc);
+irq_hp_fail:
+	free_irq(udc->udp_irq[IRQ_USB_LP], udc);
+irq_lp_fail:
+	device_unregister(&udc->gadget.dev);
+dev_register_fail:
+	dma_pool_destroy(udc->dd_cache);
+dma2_alloc_fail:
+	dma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,
+			udc->udca_v_base, (dma_addr_t) udc->udca_p_base);
+dma_alloc_fail:
+	iounmap(udc->udp_baseaddr);
+io_map_fail:
+        i2c_unregister_device(isp1301_i2c_client);
+        isp1301_i2c_client = NULL;
+i2c_probe_fail:
+	i2c_del_driver(&isp1301_driver);
+i2c_add_fail:
+	clk_disable(udc->usb_slv_clk);
+usb_clk_enable_fail:
+pll_set_fail:
+	clk_disable(udc->usb_pll_clk);
+pll_enable_fail:
+	clk_put(udc->usb_slv_clk);
+usb_clk_get_fail:
+	clk_put(udc->usb_pll_clk);
+pll_get_fail:
+	release_mem_region(udc->io_p_start, udc->io_p_size);
+	dev_err(udc->dev, "%s probe failed, %d\n", driver_name, retval);
+
+	return retval;
+}
+
+static int __exit lpc32xx_udc_remove(struct platform_device *pdev)
+{
+	struct lpc32xx_udc *udc = platform_get_drvdata(pdev);
+
+	if (udc->driver)
+		return -EBUSY;
+
+	udc_clk_set(udc, 1);
+	udc_disable(udc);
+	pullup(udc, 0);
+
+	free_irq(udc->udp_irq[IRQ_USB_ATX], udc);
+
+	device_init_wakeup(&pdev->dev, 0);
+	remove_debug_file(udc);
+
+	dma_pool_destroy(udc->dd_cache);
+	dma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,
+			udc->udca_v_base, (dma_addr_t) udc->udca_p_base);
+	free_irq(udc->udp_irq[IRQ_USB_DEVDMA], udc);
+	free_irq(udc->udp_irq[IRQ_USB_HP], udc);
+	free_irq(udc->udp_irq[IRQ_USB_LP], udc);
+
+	device_unregister(&udc->gadget.dev);
+
+	clk_disable(udc->usb_slv_clk);
+	clk_put(udc->usb_slv_clk);
+	clk_disable(udc->usb_pll_clk);
+	clk_put(udc->usb_pll_clk);
+	iounmap(udc->udp_baseaddr);
+	i2c_unregister_device(isp1301_i2c_client);
+	isp1301_i2c_client = NULL;
+	i2c_del_driver(&isp1301_driver);
+	release_mem_region(udc->io_p_start, udc->io_p_size);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lpc32xx_udc_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	int to = 1000;
+	struct lpc32xx_udc *udc = platform_get_drvdata(pdev);
+
+	if (udc->clocked) {
+		/* Power down ISP */
+		udc->poweron = 0;
+		isp1301_set_powerstate(0);
+
+		/* Disable clocking */
+		udc_clk_set(udc, 0);
+
+		/* Keep clock flag on, so we know to re-enable clocks
+		   on resume */
+		udc->clocked = 1;
+
+		/* Kill OTG and I2C clocks */
+		__raw_writel(0, USB_OTG_CLK_CTRL);
+		while (((__raw_readl(USB_OTG_CLK_STAT) & OTGOFF_CLK_MASK) !=
+				OTGOFF_CLK_MASK) && (to > 0))
+			to--;
+		if (!to)
+			dev_dbg(udc->dev, "USB OTG clocks not correctly enabled\n");
+
+		/* Kill global USB clock */
+		clk_disable(udc->usb_slv_clk);
+	}
+
+	return 0;
+}
+
+static int lpc32xx_udc_resume(struct platform_device *pdev)
+{
+	struct lpc32xx_udc *udc = platform_get_drvdata(pdev);
+
+	if (udc->clocked) {
+		/* Enable global USB clock */
+		clk_enable(udc->usb_slv_clk);
+
+		/* Enable clocking */
+		udc_clk_set(udc, 1);
+
+		/* ISP back to normal power mode */
+		udc->poweron = 1;
+		isp1301_set_powerstate(1);
+	}
+
+	return 0;
+}
+#else
+#define	lpc32xx_udc_suspend	NULL
+#define	lpc32xx_udc_resume	NULL
+#endif
+
+static struct platform_driver lpc32xx_udc_driver = {
+	.probe          = lpc32xx_udc_probe,
+	.remove		= __exit_p(lpc32xx_udc_remove),
+	.shutdown	= lpc32xx_udc_shutdown,
+	.suspend	= lpc32xx_udc_suspend,
+	.resume		= lpc32xx_udc_resume,
+	.driver		= {
+		.name	= (char *) driver_name,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init udc_init_module(void)
+{
+	return platform_driver_register(&lpc32xx_udc_driver);
+}
+module_init(udc_init_module);
+
+static void __exit udc_exit_module(void)
+{
+	platform_driver_unregister(&lpc32xx_udc_driver);
+}
+module_exit(udc_exit_module);
+
+MODULE_DESCRIPTION("LPC32XX udc driver");
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lpc32xx_udc");
+
diff --git a/drivers/usb/gadget/lpc32xx_udc.h b/drivers/usb/gadget/lpc32xx_udc.h
new file mode 100644
index 0000000..0eeb307
--- /dev/null
+++ b/drivers/usb/gadget/lpc32xx_udc.h
@@ -0,0 +1,174 @@
+/*
+ * drivers/usb/gadget/lpc32xx_udc.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef LPC32XX_UDC_H
+#define LPC32XX_UDC_H
+
+/*
+ * controller driver data structures
+ */
+
+/* 16 endpoints (not to be confused with 32 hardware endpoints) */
+#define	NUM_ENDPOINTS	16
+
+/*
+ * IRQ indices make reading the code a little easier
+ */
+#define IRQ_USB_LP	0
+#define IRQ_USB_HP	1
+#define IRQ_USB_DEVDMA	2
+#define IRQ_USB_ATX	3
+
+#define EP_OUT 0 /* RX (from host) */
+#define EP_IN 1 /* TX (to host) */
+
+/* Returns the interrupt mask for the selected hardware endpoint */
+#define EP_MASK_SEL(ep, dir) (1 << (((ep) * 2) + dir))
+
+#define EP_INT_TYPE 0
+#define EP_ISO_TYPE 1
+#define EP_BLK_TYPE 2
+#define EP_CTL_TYPE 3
+
+/* EP0 states */
+#define WAIT_FOR_SETUP 0 /* Wait for setup packet */
+#define DATA_IN        1 /* Expect dev->host transfer */
+#define DATA_OUT       2 /* Expect host->dev transfer */
+
+/* DD (DMA Descriptor) structure, requires word alignment, this is already defined
+   in the LPC32XX USB device header file, but this version si slightly modified to
+   tag some work data with each DMA descriptor. */
+struct lpc32xx_usbd_dd_gad;
+struct lpc32xx_usbd_dd_gad
+{
+	struct lpc32xx_usbd_dd_gad *dd_next_phy;
+	u32 dd_setup;
+	u32 dd_buffer_addr;
+	u32 dd_status;
+	u32 *dd_iso_ps_mem_addr;
+	dma_addr_t this_dma;
+	u32 iso_status[6]; /* 5 spare */
+	struct lpc32xx_usbd_dd_gad *dd_next_v;
+};
+
+/*
+ * Logical endpoint structure
+ */
+struct lpc32xx_ep {
+	struct usb_ep		ep;
+	struct list_head	queue;
+	struct lpc32xx_udc	*udc;
+
+	u32			hwep_num_base; /* Physical hardware EP */
+	u32			hwep_num; /* Maps to hardware endpoint */
+	u32			maxpacket;
+	u32			lep;
+
+	u32			is_in:1;
+	volatile u32		req_pending:1;
+	u32			eptype;
+
+	u32                     totalints;
+
+	const struct usb_endpoint_descriptor *desc;
+};
+
+/*
+ * Common UDC structure
+ */
+struct lpc32xx_udc {
+	struct usb_gadget	gadget;
+	struct usb_gadget_driver *driver;
+	struct platform_device	*pdev;
+	struct device		*dev;
+	struct proc_dir_entry	*pde;
+	spinlock_t		lock;
+
+	/* Board and device specific */
+	struct lpc32xx_usbd_cfg	*board;
+	u32			io_p_start;
+	u32			io_p_size;
+	void __iomem		*udp_baseaddr;
+	int			udp_irq[4];
+	struct clk		*usb_pll_clk;
+	struct clk		*usb_slv_clk;
+
+	/* DMA support */
+	u32			*udca_v_base;
+	u32			*udca_p_base;
+	struct dma_pool		*dd_cache;
+
+	/* Common EP and control data */
+	u32			enabled_devints;
+	u32			enabled_hwepints;
+	u32			dev_status;
+	u32			realized_eps;
+
+	/* VBUS detection, pullup, and power flags */
+	u8			vbus;
+	u8			last_vbus;
+	int			pullup;
+	int			poweron;
+
+	/* Work queues related to I2C support */
+	struct work_struct	pullup_wq;
+	struct work_struct	vbus_wq;
+	struct work_struct	power_wq;
+
+	/* USB device peripheral - various */
+	struct lpc32xx_ep	ep[NUM_ENDPOINTS];
+	u32			enabled:1;
+	u32			clocked:1;
+	u32			suspended:1;
+	u32			selfpowered:1;
+	int                     ep0state;
+        atomic_t                enabled_ep_cnt;
+        wait_queue_head_t       ep_disable_wait_queue;
+};
+
+/*
+ * Endpoint request
+ */
+struct lpc32xx_request {
+	struct usb_request	req;
+	struct list_head	queue;
+	struct lpc32xx_usbd_dd_gad *dd_desc_ptr;
+	u32			mapped:1;
+	u32			send_zlp:1;
+};
+
+static inline struct lpc32xx_udc *to_udc(struct usb_gadget *g)
+{
+	return container_of(g, struct lpc32xx_udc, gadget);
+}
+
+#define ep_dbg(epp, fmt, arg...) \
+	dev_dbg(epp->udc->dev, "%s:%s: " fmt, epp->ep.name, __func__, ## arg)
+#define ep_err(epp, fmt, arg...) \
+	dev_err(epp->udc->dev, "%s:%s: " fmt, epp->ep.name, __func__, ## arg)
+#define ep_info(epp, fmt, arg...) \
+	dev_info(epp->udc->dev, "%s:%s: " fmt, epp->ep.name, __func__, ## arg)
+#define ep_warn(epp, fmt, arg...) \
+	dev_warn(epp->udc->dev, "%s:%s:" fmt, epp->ep.name, __func__, ## arg)
+
+#endif
+
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index c001fff..106ff36 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1051,6 +1051,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
 #endif
 
+#ifdef CONFIG_ARCH_LPC32XX
+#include "ohci-pnx4008.c"
+#define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
+#endif
+
 #ifdef CONFIG_ARCH_DAVINCI_DA8XX
 #include "ohci-da8xx.c"
 #define PLATFORM_DRIVER		ohci_hcd_da8xx_driver
diff --git a/drivers/usb/host/ohci-pnx4008.c b/drivers/usb/host/ohci-pnx4008.c
index 653d6a6..89463ab 100644
--- a/drivers/usb/host/ohci-pnx4008.c
+++ b/drivers/usb/host/ohci-pnx4008.c
@@ -24,9 +24,16 @@
 #include <mach/hardware.h>
 #include <asm/io.h>
 
+#if defined(CONFIG_ARCH_LPC32XX)
+#include <mach/platform.h>
+#include <mach/irqs.h>
+#define PNX4008_PWRMAN_BASE LPC32XX_CLK_PM_BASE
+#define PNX4008_USB_CONFIG_BASE LPC32XX_USB_BASE
+#else
 #include <mach/platform.h>
 #include <mach/irqs.h>
 #include <mach/gpio.h>
+#endif
 
 #define USB_CTRL	IO_ADDRESS(PNX4008_PWRMAN_BASE + 0x64)
 
@@ -143,8 +150,18 @@ static void i2c_write(u8 buf, u8 subaddr)
 	i2c_master_send(isp1301_i2c_client, &tmpbuf[0], 2);
 }
 
+static u16 i2c_read16(u8 subaddr)
+{
+	u16 data;
+
+	i2c_master_send(isp1301_i2c_client, &subaddr, 1);
+	i2c_master_recv(isp1301_i2c_client, (u8 *) &data, 2);
+	return data;
+}
+
 static void isp1301_configure(void)
 {
+#if !defined(CONFIG_ARCH_LPC32XX)
 	/* PNX4008 only supports DAT_SE0 USB mode */
 	/* PNX4008 R2A requires setting the MAX603 to output 3.6V */
 	/* Power up externel charge-pump */
@@ -166,6 +183,40 @@ static void isp1301_configure(void)
 		  ISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR);
 	i2c_write(0xFF,
 		  ISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR);
+#else
+	/* LPC32XX only supports DAT_SE0 USB mode */
+	/* This sequence is important */
+
+	/* Disable transparent UART mode first */
+	i2c_write(MC1_UART_EN, (ISP1301_I2C_MODE_CONTROL_1 |
+				ISP1301_I2C_REG_CLEAR_ADDR));
+
+	i2c_write(~MC1_SPEED_REG, (ISP1301_I2C_MODE_CONTROL_1 |
+				ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write(MC1_SPEED_REG, ISP1301_I2C_MODE_CONTROL_1);
+	i2c_write(~0, (ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write((MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL),
+			ISP1301_I2C_MODE_CONTROL_2);
+	i2c_write(~0, (ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write(MC1_DAT_SE0, ISP1301_I2C_MODE_CONTROL_1);
+	i2c_write((OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN),
+			ISP1301_I2C_OTG_CONTROL_1);
+	i2c_write((OTG1_DM_PULLUP | OTG1_DP_PULLUP),
+			(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write(~0,
+			ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(~0,
+			ISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(~0,
+			ISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR);
+
+	/* Enable usb_need_clk clock after transceiver is initialized */
+	__raw_writel((__raw_readl(USB_CTRL) | (1 << 22)), USB_CTRL);
+
+	printk(KERN_INFO "ISP1301 Vendor ID  : 0x%04x\n", i2c_read16(0x00));
+	printk(KERN_INFO "ISP1301 Product ID : 0x%04x\n", i2c_read16(0x02));
+	printk(KERN_INFO "ISP1301 Version ID : 0x%04x\n", i2c_read16(0x14));
+#endif
 
 }
 
@@ -257,6 +308,7 @@ static const struct hc_driver ohci_pnx4008_hc_driver = {
 
 static void pnx4008_set_usb_bits(void)
 {
+#if !defined(CONFIG_ARCH_LPC32XX)
 	start_int_set_falling_edge(SE_USB_OTG_ATX_INT_N);
 	start_int_ack(SE_USB_OTG_ATX_INT_N);
 	start_int_umask(SE_USB_OTG_ATX_INT_N);
@@ -280,16 +332,19 @@ static void pnx4008_set_usb_bits(void)
 	start_int_set_rising_edge(SE_USB_AHB_NEED_CLK_INT);
 	start_int_ack(SE_USB_AHB_NEED_CLK_INT);
 	start_int_umask(SE_USB_AHB_NEED_CLK_INT);
+#endif
 }
 
 static void pnx4008_unset_usb_bits(void)
 {
+#if !defined(CONFIG_ARCH_LPC32XX)
 	start_int_mask(SE_USB_OTG_ATX_INT_N);
 	start_int_mask(SE_USB_OTG_TIMER_INT);
 	start_int_mask(SE_USB_I2C_INT);
 	start_int_mask(SE_USB_INT);
 	start_int_mask(SE_USB_NEED_CLK_INT);
 	start_int_mask(SE_USB_AHB_NEED_CLK_INT);
+#endif
 }
 
 static int __devinit usb_hcd_pnx4008_probe(struct platform_device *pdev)
@@ -320,6 +375,16 @@ static int __devinit usb_hcd_pnx4008_probe(struct platform_device *pdev)
 	/* Enable AHB slave USB clock, needed for further USB clock control */
 	__raw_writel(USB_SLAVE_HCLK_EN | (1 << 19), USB_CTRL);
 
+#if defined(CONFIG_ARCH_LPC32XX)
+	if ((__raw_readl(USB_OTG_CLK_STAT) & I2C_CLOCK_ON) != I2C_CLOCK_ON) {
+		/* Enable I2C clock in the OTG block if it isn't on */
+		__raw_writel(I2C_CLOCK_ON, USB_OTG_CLK_CTRL);
+
+		/* Ideally, a timeout based on jiffies would be nice here */
+		while (__raw_readl(USB_OTG_CLK_STAT) != I2C_CLOCK_ON);
+	}
+#endif
+
 	ret = i2c_add_driver(&isp1301_driver);
 	if (ret < 0) {
 		err("failed to add ISP1301 driver");
diff --git a/drivers/video/amba-clcd.c b/drivers/video/amba-clcd.c
index 5fc983c..ab25c8d 100644
--- a/drivers/video/amba-clcd.c
+++ b/drivers/video/amba-clcd.c
@@ -25,6 +25,7 @@
 #include <linux/amba/clcd.h>
 #include <linux/clk.h>
 #include <linux/hardirq.h>
+#include <linux/console.h>
 
 #include <asm/sizes.h>
 
@@ -77,6 +78,8 @@ static void clcdfb_disable(struct clcd_fb *fb)
 		writel(val, fb->regs + fb->off_cntl);
 	}
 
+	clcdfb_sleep(20);
+
 	/*
 	 * Disable CLCD clock source.
 	 */
@@ -96,6 +99,8 @@ static void clcdfb_enable(struct clcd_fb *fb, u32 cntl)
 		clk_enable(fb->clk);
 	}
 
+	clcdfb_sleep(20);
+
 	/*
 	 * Bring up by first enabling..
 	 */
@@ -567,7 +572,7 @@ static int clcdfb_probe(struct amba_device *dev, const struct amba_id *id)
 	if (ret)
 		goto free_fb;
 
-	ret = clcdfb_register(fb); 
+	ret = clcdfb_register(fb);
 	if (ret == 0) {
 		amba_set_drvdata(dev, fb);
 		goto out;
@@ -604,6 +609,34 @@ static int clcdfb_remove(struct amba_device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int clcdfb_suspend(struct amba_device *dev, pm_message_t msg)
+{
+	struct clcd_fb *fb = amba_get_drvdata(dev);
+	console_lock();
+	fb_set_suspend(&fb->fb,1);
+	clcdfb_disable(fb);
+  console_unlock();
+
+	return 0;
+}
+
+static int clcdfb_resume(struct amba_device *dev)
+{
+	struct clcd_fb *fb = amba_get_drvdata(dev);
+
+	console_lock();
+	clcdfb_enable(fb, fb->clcd_cntl);
+	fb_set_suspend(&fb->fb,0);
+  console_unlock();
+
+	return 0;
+}
+#else
+#define clcdfb_suspend	NULL
+#define clcdfb_resume	NULL
+#endif
+
 static struct amba_id clcdfb_id_table[] = {
 	{
 		.id	= 0x00041110,
@@ -618,6 +651,8 @@ static struct amba_driver clcd_driver = {
 	},
 	.probe		= clcdfb_probe,
 	.remove		= clcdfb_remove,
+	.suspend	= clcdfb_suspend,
+	.resume		= clcdfb_resume,
 	.id_table	= clcdfb_id_table,
 };
 
diff --git a/include/linux/amba/clcd.h b/include/linux/amba/clcd.h
index e82e3ee..de490f8 100644
--- a/include/linux/amba/clcd.h
+++ b/include/linux/amba/clcd.h
@@ -281,17 +281,32 @@ static inline void clcdfb_decode(struct clcd_fb *fb, struct clcd_regs *regs)
 
 static inline int clcdfb_check(struct clcd_fb *fb, struct fb_var_screeninfo *var)
 {
+	u32 hbp, hfp, hsw;
+
+	/*
+	 * These clock constraints are for the pl11x DMA latency. TFT mode
+	 * is slightly faster than STN
+	 */
+	if (fb->panel->cntl & CNTL_LCDTFT) {
+		/* No TFT constraint given for min TFT HFP clocks in TRM */
+		hbp = hfp = (2 + 1);
+		hsw = (2 + 1);
+	} else {
+		hbp = hfp = (5 + 1);
+		hsw = (3 + 1);
+	}
+
 	var->xres_virtual = var->xres = (var->xres + 15) & ~15;
 	var->yres_virtual = var->yres = (var->yres + 1) & ~1;
 
 #define CHECK(e,l,h) (var->e < l || var->e > h)
-	if (CHECK(right_margin, (5+1), 256) ||	/* back porch */
-	    CHECK(left_margin, (5+1), 256) ||	/* front porch */
-	    CHECK(hsync_len, (5+1), 256) ||
-	    var->xres > 4096 ||
+	if (CHECK(right_margin, hbp, 256) ||	/* back porch */
+	    CHECK(left_margin, hfp, 256) ||	/* front porch */
+	    CHECK(hsync_len, hsw, 256) ||
+	    var->xres > 1024 ||
 	    var->lower_margin > 255 ||		/* back porch */
 	    var->upper_margin > 255 ||		/* front porch */
-	    var->vsync_len > 32 ||
+	    var->vsync_len > 64 ||
 	    var->yres > 1024)
 		return -EINVAL;
 #undef CHECK
diff --git a/include/linux/i2c-pnx.h b/include/linux/i2c-pnx.h
index a87124d..6732200 100644
--- a/include/linux/i2c-pnx.h
+++ b/include/linux/i2c-pnx.h
@@ -12,6 +12,8 @@
 #ifndef __I2C_PNX_H__
 #define __I2C_PNX_H__
 
+#include <linux/i2c.h>
+
 struct platform_device;
 struct clk;
 
@@ -24,9 +26,27 @@ struct i2c_pnx_mif {
 	int			len;		/* Length of data buffer */
 };
 
+struct i2c_pnx_smbus {
+	int ret; /* Return value from ISR */
+	int index; /* ISR use it for tx */
+	int rx_cnt; /* Number of data received */
+	u16 tx_buf[I2C_SMBUS_BLOCK_MAX+8]; /* Tx buffer */
+	u8 *rx_buf; /* Rx buffer */
+	int max_rx_len; /* Max. len. of expected Rx data */
+	struct completion complete;
+	int len; /* Length of data to be transmitted */
+#define I2C_PNX_SMBUS_NEED_RESET  1 /* Bus needs reset */
+#define I2C_PNX_SMBUS_ACTIVE      2 /* SMBus active */
+#define I2C_PNX_SMBUS_BLOCK_RX    4 /* Block transfer */
+#define I2C_PNX_SMBUS_WORD_RX     8 /* Word transfer */
+	u32 flags; /* Updated by ISR */
+	int slave_addr;
+};
+
 struct i2c_pnx_algo_data {
 	void __iomem		*ioaddr;
 	struct i2c_pnx_mif	mif;
+	struct i2c_pnx_smbus smb;
 	int			last;
 	struct clk		*clk;
 	struct i2c_pnx_data	*i2c_pnx;
diff --git a/init/main.c b/init/main.c
index 48df882..afa5476 100644
--- a/init/main.c
+++ b/init/main.c
@@ -6,7 +6,7 @@
  *  GK 2/5/95  -  Changed to support mounting root fs via NFS
  *  Added initrd & change_root: Werner Almesberger & Hans Lermen, Feb '96
  *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May '96
- *  Simplified starting of init:  Michael A. Griffith <grif@acm.org> 
+ *  Simplified starting of init:  Michael A. Griffith <grif@acm.org>
  */
 
 #include <linux/types.h>
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 8224db5..c45908b 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -57,6 +57,7 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
+source "sound/soc/lpc3xxx/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 1ed61c5..00ea282 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -20,3 +20,4 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
+obj-$(CONFIG_SND_SOC)	+= lpc3xxx/
diff --git a/sound/soc/codecs/uda1380.c b/sound/soc/codecs/uda1380.c
index c5ca8cf..60233e3 100644
--- a/sound/soc/codecs/uda1380.c
+++ b/sound/soc/codecs/uda1380.c
@@ -151,7 +151,11 @@ static int uda1380_reset(struct snd_soc_codec *codec)
 
 	if (gpio_is_valid(pdata->gpio_reset)) {
 		gpio_set_value(pdata->gpio_reset, 1);
+#ifdef CONFIG_MACH_PHY3250
+		udelay(5);
+#else
 		mdelay(1);
+#endif
 		gpio_set_value(pdata->gpio_reset, 0);
 	} else {
 		u8 data[3];
@@ -535,6 +539,43 @@ static int uda1380_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
+static int uda1380_pcm_prepare(struct snd_pcm_substream *substream,
+                struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	int reg, reg_start, reg_end, clk;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		reg_start = UDA1380_MVOL;
+		reg_end = UDA1380_MIXER;
+	} else {
+		reg_start = UDA1380_DEC;
+		reg_end = UDA1380_AGC;
+	}
+
+	clk = uda1380_read_reg_cache(codec, UDA1380_CLK);
+	uda1380_write(codec, UDA1380_CLK, clk & ~R00_DAC_CLK);
+
+	for (reg = reg_start; reg <= reg_end; reg++) {
+		pr_debug("uda1380: flush reg %x val %x:", reg,
+				uda1380_read_reg_cache(codec, reg));
+		if(reg == UDA1380_MIXER)
+			uda1380_write(codec, reg,
+							uda1380_read_reg_cache(codec, reg) | R14_SILENCE);
+		/* Disable DAC mute */
+		else if(reg == UDA1380_PGA)
+			uda1380_write(codec, reg,
+					uda1380_read_reg_cache(codec, reg) & ~R21_MT_ADC);
+		else
+			uda1380_write(codec, reg, uda1380_read_reg_cache(codec, reg));
+	}
+
+	uda1380_write(codec, UDA1380_CLK, clk | R00_DAC_CLK);
+
+	return 0;
+}
+
 static int uda1380_pcm_hw_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
 				 struct snd_soc_dai *dai)
@@ -615,7 +656,9 @@ static int uda1380_set_bias_level(struct snd_soc_codec *codec,
 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
 			if (gpio_is_valid(pdata->gpio_power)) {
 				gpio_set_value(pdata->gpio_power, 1);
+#ifndef CONFIG_MACH_PHY3250
 				mdelay(1);
+#endif
 				uda1380_reset(codec);
 			}
 
@@ -646,6 +689,7 @@ static int uda1380_set_bias_level(struct snd_soc_codec *codec,
 static struct snd_soc_dai_ops uda1380_dai_ops = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
+	.prepare	= uda1380_pcm_prepare,
 	.trigger	= uda1380_trigger,
 	.set_fmt	= uda1380_set_dai_fmt_both,
 };
@@ -653,6 +697,7 @@ static struct snd_soc_dai_ops uda1380_dai_ops = {
 static struct snd_soc_dai_ops uda1380_dai_ops_playback = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
+	.prepare	= uda1380_pcm_prepare,
 	.trigger	= uda1380_trigger,
 	.set_fmt	= uda1380_set_dai_fmt_playback,
 };
@@ -660,6 +705,7 @@ static struct snd_soc_dai_ops uda1380_dai_ops_playback = {
 static struct snd_soc_dai_ops uda1380_dai_ops_capture = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
+	.prepare	= uda1380_pcm_prepare,
 	.trigger	= uda1380_trigger,
 	.set_fmt	= uda1380_set_dai_fmt_capture,
 };
@@ -713,7 +759,16 @@ static int uda1380_suspend(struct snd_soc_codec *codec, pm_message_t state)
 
 static int uda1380_resume(struct snd_soc_codec *codec)
 {
+	u16 clk = uda1380_read_reg_cache(codec, UDA1380_CLK);
+	u16 pm = uda1380_read_reg_cache(codec, UDA1380_PM);
+
 	uda1380_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	/* Set WSPLL power if running from this clock */
+	if (clk & R00_DAC_CLK) {
+		uda1380_write(codec, UDA1380_PM, R02_PON_PLL | pm);
+	}
+
 	return 0;
 }
 
diff --git a/sound/soc/lpc3xxx/Kconfig b/sound/soc/lpc3xxx/Kconfig
new file mode 100644
index 0000000..194f030
--- /dev/null
+++ b/sound/soc/lpc3xxx/Kconfig
@@ -0,0 +1,55 @@
+config SND_LPC3XXX_SOC
+        tristate "SoC Audio for the NXP LPC32XX System-on-a-Chip"
+        depends on ARCH_LPC32XX && SND_SOC
+        help
+          Say Y or M if you want to add support for codecs attached to 
+          the LPC3XXX I2S interface.  You will also need to to select
+          the audio interfaces to support below.
+
+config SND_LPC3XXX_SOC_I2S_UDA1380
+        tristate "SoC Audio support for Phytec 3250 board with the UDA1380"
+        depends on SND_LPC3XXX_SOC
+        select I2C
+        select SND_SOC_UDA1380
+        select SND_LPC32XX_USEI2S1
+        select SND_LPC32XX_SLAVE_TX_CLK_TO_RX
+        help
+          Say Y or M here if you want to add support for SoC audio
+          on the Phytec 3250 board. This requires an I2C channel connected
+          to the I2C interface of the UDA1380 codec.
+
+config SND_LPC32XX_USEI2S1
+        bool "Use I2S1 channel instead of I2S0"
+        depends on SND_LPC3XXX_SOC
+        help
+	  The LPC32XX has 2 I2S channels (0 and 1). Normally, I2S0 is
+	  used for communications with an I2S codec. If I2S1 should be
+	  used instead, select this option. For LPC32XX systems that
+	  used the LCD interface, I2S1 must be used.
+
+config SND_LPC32XX_USEI2S_SLAVE_MODETX
+        bool "Use slave mode on the TX channel instead of master mode"
+        depends on SND_LPC3XXX_SOC
+	default n
+        help
+	  In this mode, the TX WS and bit clocks are driven from the audio
+	  CODEC instead of from the LPC32x0. For most CODECs, this won't
+	  be the case, but CODECs that have their own clocking may be able
+	  to provide TX clocking.
+
+config SND_LPC32XX_USEI2S_SLAVE_MODERX
+        bool "Use slave mode on the RX channel instead of master mode"
+        depends on SND_LPC3XXX_SOC
+	default n
+        help
+	  In this mode, the RX WS and bit clocks are driven from the audio
+	  CODEC instead of from the LPC32x0.
+
+config SND_LPC32XX_SLAVE_TX_CLK_TO_RX
+        bool "Enable TX WS clock during RX"
+        depends on SND_LPC3XXX_SOC
+	default n
+        help
+	  This enables the TX WS clock during RX transfers. Some CODECS use
+	  the TX clock for internal clock or for RX clocking.
+
diff --git a/sound/soc/lpc3xxx/Makefile b/sound/soc/lpc3xxx/Makefile
new file mode 100644
index 0000000..6447b89
--- /dev/null
+++ b/sound/soc/lpc3xxx/Makefile
@@ -0,0 +1,10 @@
+# LPC3XXX Platform Support
+snd-soc-lpc3xxx-objs := lpc3xxx-pcm.o
+snd-soc-lpc3xxx-i2s-objs := lpc3xxx-i2s.o
+
+obj-$(CONFIG_SND_LPC3XXX_SOC) += snd-soc-lpc3xxx.o snd-soc-lpc3xxx-i2s.o
+
+# LPC3XXX Machine Support
+snd-soc-lpc3xxx-uda1380-objs := lpc3xxx-uda1380.o
+
+obj-$(CONFIG_SND_LPC3XXX_SOC_I2S_UDA1380) += snd-soc-lpc3xxx-uda1380.o
diff --git a/sound/soc/lpc3xxx/lpc3xxx-i2s.c b/sound/soc/lpc3xxx/lpc3xxx-i2s.c
new file mode 100644
index 0000000..e4f40a5
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-i2s.c
@@ -0,0 +1,639 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-i2s.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/platform.h>
+#include <mach/hardware.h>
+#include "lpc3xxx-pcm.h"
+#include "lpc3xxx-i2s.h"
+
+#include <mach/clkdev.h>
+
+#define I2S_NAME "lpc3xxx-i2s"
+
+#define CLK_NAME (8)
+
+#define LPC3XXX_I2S_RATES \
+    (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+     SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+     SNDRV_PCM_RATE_48000)
+
+#define LPC3XXX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S8 | SND_SOC_DAIFMT_I2S | \
+    SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_S32)
+
+#define CLKPWR_IOBASE io_p2v(CLK_PM_BASE)
+
+static struct lpc3xxx_i2s_info *i2s_info = NULL;
+
+#if 0
+static struct lpc3xxx_i2s_info i2s_info[NUM_I2S_DEVICES] = {
+	{
+	 .name = "i2s0",
+	 .lock = __SPIN_LOCK_UNLOCKED(i2s_info[0].lock),
+	 .initialized = 0,
+	 .clkname = "i2s0_ck",
+	 .baseio = LPC32XX_I2S0_BASE,
+	 },
+	{
+	 .name = "i2s1",
+	 .lock = __SPIN_LOCK_UNLOCKED(i2s_info[1].lock),
+	 .initialized = 0,
+	 .clkname = "i2s1_ck",
+	 .baseio = LPC32XX_I2S1_BASE,
+	 },
+};
+#endif
+
+static u32 absd32(u32 v1, u32 v2) {
+	if (v1 > v2) {
+		return v1 - v2;
+	}
+
+	return v2 - v1;
+}
+
+static void __lpc3xxx_find_clkdiv(u32 *clkx, u32 *clky, int freq,
+				  int xbytes, u32 clkrate) {
+	u32 i2srate;
+	u32 idxx, idyy;
+	u32 savedbitclkrate, diff, trate, baseclk;
+
+	/* Adjust rate for sample size (bits) and 2 channels and offset for
+	   divider in clock output */
+	i2srate = (freq / 100) * 2 * (8 * xbytes);
+	i2srate = i2srate << 1;
+	clkrate = clkrate / 100;
+	baseclk = clkrate;
+	*clkx = 1;
+	*clky = 1;
+
+	/* Find the best divider */
+	*clkx = *clky = 0;
+	savedbitclkrate = 0;
+	diff = ~0;
+	for (idxx = 1; idxx < 0xFF; idxx++) {
+		for (idyy = 1; idyy < 0xFF; idyy++) {
+			trate = (baseclk * idxx) / idyy;
+			if (absd32(trate, i2srate) < diff) {
+				diff = absd32(trate, i2srate);
+				savedbitclkrate = trate;
+				*clkx = idxx;
+				*clky = idyy;
+			}
+		}
+	}
+}
+
+static int lpc3xxx_i2s_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	u32 clkx, clky;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[rtd->cpu_dai->id];
+	u32 dmamask;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dmamask = I2S_DMA_XMIT;
+	}
+	else {
+		dmamask = I2S_DMA_RECV;
+	}
+
+	if (dmamask & i2s_info_p->dma_flags) {
+		/* This channel already enabled! */
+		pr_warning("%s: I2S DMA channel is busy!\n",
+			I2S_NAME);
+		return -EBUSY;
+	}
+
+	/* Enable I2S clock */
+	clk_enable(i2s_info_p->clk);
+
+	/* I2S is setup here with a dummy configuration to allow the
+	bit clock to toggle. The CODEC attached to the I2S may not
+	work without this clock. The actual values here do not yet
+	matter and will be reconfigured when needed by the I2S hw
+	setup function. To match the default selected PLL setting,
+	this clock should be between 6.25 and 12.5KHz */
+	__raw_writel(I2S_DMA0_TX_DEPTH(4), I2S_DMA1(i2s_info_p->iomem));
+	__lpc3xxx_find_clkdiv(&clkx, &clky, 9000, 2, i2s_info_p->clkrate);
+	__raw_writel(((clkx << 8) | clky), I2S_TX_RATE(i2s_info_p->iomem));
+	__raw_writel(0x83C1, I2S_DAO(i2s_info_p->iomem));
+
+	i2s_info_p->dma_flags |= dmamask;
+
+	return 0;
+}
+
+static void lpc3xxx_i2s_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[rtd->cpu_dai->id];
+	u32 dmamask, tmp;
+
+	/* Disable I2S based on stream */
+	spin_lock_irq(&i2s_info_p->lock);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dmamask = I2S_DMA_XMIT;
+		tmp = __raw_readl(I2S_DAO(i2s_info_p->iomem));
+		tmp |= I2S_STOP;
+		__raw_writel(tmp, I2S_DAO(i2s_info_p->iomem));
+		__raw_writel(0, I2S_TX_RATE(i2s_info_p->iomem));
+	}
+	else {
+		dmamask = I2S_DMA_RECV;
+		tmp = __raw_readl(I2S_DAI(i2s_info_p->iomem));
+		tmp |= I2S_STOP;
+		__raw_writel(tmp, I2S_DAI(i2s_info_p->iomem));
+		__raw_writel(0, I2S_RX_RATE(i2s_info_p->iomem));
+	}
+
+#if defined(CONFIG_SND_LPC32XX_SLAVE_TX_CLK_TO_RX)
+	/* Slave the RX WSI signal to the TX WSI signal */
+	tmp = __raw_readl(LPC32XX_CLKPWR_I2S_CLK_CTRL);
+	tmp &= ~(1 << 6);
+	__raw_writel(tmp, LPC32XX_CLKPWR_I2S_CLK_CTRL);
+#endif
+
+	spin_unlock_irq(&i2s_info_p->lock);
+
+	/* If both streams are shut down, then disable I2S to save power */
+	i2s_info_p->dma_flags &= ~dmamask;
+	if(i2s_info_p->dma_flags == 0) {
+		clk_disable(i2s_info_p->clk);
+	}
+}
+
+static int lpc3xxx_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				      int clk_id, unsigned int freq, int dir)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	/* Will use in HW params later */
+	i2s_info_p->freq = freq;
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+				   unsigned int fmt)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	/* Will use in HW params later */
+	i2s_info_p->daifmt = fmt;
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+				      int div_id, int div)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	/* This function doesn't help, but save the value anyways.
+	   HW params will determine the correct clock divider based
+	   on the frequency */
+	i2s_info_p->clkdiv = div;
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_hw_params(struct snd_pcm_substream *substream,
+			         struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int id = rtd->cpu_dai->id;
+	struct lpc3xxx_i2s_info *i2s_info_p;
+	int xfersize;
+	u32 tmp, tmp2, clkx, clky;
+
+	(void) tmp2;
+	i2s_info_p = &i2s_info[id];
+
+	/* Build the I2S setup word */
+	tmp = 0;
+
+	if ((i2s_info_p->daifmt & SND_SOC_DAIFMT_MASTER_MASK) ==
+		SND_SOC_DAIFMT_CBM_CFM) {
+		tmp |= I2S_WS_SEL;
+	}
+
+	switch (i2s_info_p->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SNDRV_PCM_FMTBIT_S8:
+			tmp |= I2S_WW8 | I2S_WS_HP(I2S_WW8_HP);
+			xfersize = 1;
+			break;
+
+		case SNDRV_PCM_FMTBIT_S16:
+		case SND_SOC_DAIFMT_I2S:
+			tmp |= I2S_WW16 | I2S_WS_HP(I2S_WW16_HP);
+			xfersize = 2;
+			break;
+
+		case SNDRV_PCM_FMTBIT_S32:
+			tmp |= I2S_WW32 | I2S_WS_HP(I2S_WW32_HP);
+			xfersize = 4;
+			break;
+
+		default:
+			pr_warning("%s: Unsupported audio data format\n",
+				I2S_NAME);
+			return -EINVAL;
+	}
+
+	/* Mono or stereo? */
+	if (params_channels(params) == 1) {
+		tmp |= I2S_MONO;
+	}
+
+	/* Find the best clock dividers to generate the requested
+	   frequency */
+	__lpc3xxx_find_clkdiv(&clkx, &clky, i2s_info_p->freq, xfersize, i2s_info_p->clkrate);
+
+	pr_debug("Desired clock rate    : %d\n", i2s_info_p->freq);
+	pr_debug("Base clock rate       : %d\n", i2s_info_p->clkrate);
+	pr_debug("Transfer size (bytes) : %d\n", xfersize);
+	pr_debug("Clock divider (x)     : %d\n", clkx);
+	pr_debug("Clock divider (y)     : %d\n", clky);
+	pr_debug("Channels              : %d\n", params_channels(params));
+	pr_debug("Data format           : %d\n", i2s_info_p->daifmt);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* Enable DAO support, correct clock rate, and DMA */
+		__raw_writel(I2S_DMA1_TX_EN | I2S_DMA0_TX_DEPTH(4),
+			I2S_DMA1(i2s_info_p->iomem));
+		__raw_writel(((clkx << 8) | clky),
+			I2S_TX_RATE(i2s_info_p->iomem));
+		__raw_writel(tmp, I2S_DAO(i2s_info_p->iomem));
+
+		pr_debug("TX DMA1               : 0x%x\n",
+			__raw_readl(I2S_DMA1(i2s_info_p->iomem)));
+		pr_debug("TX dividers           : 0x%x\n",
+			__raw_readl(I2S_TX_RATE(i2s_info_p->iomem)));
+		pr_debug("TX DAO                : 0x%x\n",
+			__raw_readl(I2S_DAO(i2s_info_p->iomem)));
+	}
+	else {
+		/* Enable DAI support, correct clock rate, and DMA */
+		__raw_writel(I2S_DMA0_RX_EN | I2S_DMA1_RX_DEPTH(4),
+			I2S_DMA0(i2s_info_p->iomem));
+		__raw_writel(((clkx << 8) | clky), I2S_RX_RATE(i2s_info_p->iomem));
+
+#if defined(CONFIG_SND_LPC32XX_SLAVE_TX_CLK_TO_RX)
+		/* Slave the RX WS signal to the TX WS signal */
+		tmp2 = __raw_readl(LPC32XX_CLKPWR_I2S_CLK_CTRL);
+		tmp2 |= (1 << 6);
+		__raw_writel(tmp2, LPC32XX_CLKPWR_I2S_CLK_CTRL);
+
+		/* The DAO interface needs to be enabled to route the clock from
+		   RX to TX */
+		__raw_writel((tmp & ~I2S_WS_SEL), I2S_DAO(i2s_info_p->iomem));
+#endif
+
+		__raw_writel(tmp, I2S_DAI(i2s_info_p->iomem));
+
+		pr_debug("RX DMA0               : 0x%x\n",
+			__raw_readl(I2S_DMA0(i2s_info_p->iomem)));
+		pr_debug("RX dividers           : 0x%x\n",
+			__raw_readl(I2S_RX_RATE(i2s_info_p->iomem)));
+		pr_debug("RX DAI                : 0x%x\n",
+			__raw_readl(I2S_DAI(i2s_info_p->iomem)));
+	}
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	/* Nothing to do here */
+	return 0;
+}
+
+static int lpc3xxx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int id = rtd->cpu_dai->id;
+	struct lpc3xxx_i2s_info *i2s_info_p;
+	u32 tmp;
+	int ret = 0;
+
+	i2s_info_p = &i2s_info[id];
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			tmp = __raw_readl(I2S_DAO(i2s_info_p->iomem));
+			tmp |= I2S_STOP;
+			__raw_writel(tmp, I2S_DAO(i2s_info_p->iomem));
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			tmp = __raw_readl(I2S_DAO(i2s_info_p->iomem));
+			tmp &= ~I2S_STOP;
+			__raw_writel(tmp, I2S_DAO(i2s_info_p->iomem));
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int lpc3xxx_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	if (!cpu_dai->active)
+		return 0;
+
+	/* Save DA0, DAI, and IRQ register states */
+	i2s_info_p->dao_save = __raw_readl(I2S_DAO(i2s_info_p->iomem));
+	i2s_info_p->dai_save = __raw_readl(I2S_DAI(i2s_info_p->iomem));
+	i2s_info_p->irq_save = __raw_readl(I2S_IRQ(i2s_info_p->iomem));
+
+	/* Disable system clock */
+	clk_disable(i2s_info_p->clk);
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_resume(struct snd_soc_dai *cpu_dai)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	if (!cpu_dai->active)
+		return 0;
+
+	/* Restore system clock */
+	clk_enable(i2s_info_p->clk);
+
+	/* Restore saved DA0, DAI, and IRQ register states */
+	__raw_writel(i2s_info_p->dao_save, I2S_DAO(i2s_info_p->iomem));
+	__raw_writel(i2s_info_p->dai_save, I2S_DAI(i2s_info_p->iomem));
+	__raw_writel(i2s_info_p->irq_save, I2S_IRQ(i2s_info_p->iomem));
+
+	return 0;
+}
+
+#else
+#  define lpc3xxx_i2s_suspend	NULL
+#  define lpc3xxx_i2s_resume	NULL
+#endif
+
+static struct snd_soc_dai_ops lpc3xxx_i2s_dai_ops = {
+	.startup = lpc3xxx_i2s_startup,
+	.shutdown = lpc3xxx_i2s_shutdown,
+	.prepare = lpc3xxx_i2s_prepare,
+	.trigger = lpc3xxx_i2s_trigger,
+	.hw_params = lpc3xxx_i2s_hw_params,
+	.set_sysclk = lpc3xxx_i2s_set_dai_sysclk,
+	.set_fmt = lpc3xxx_i2s_set_dai_fmt,
+	.set_clkdiv = lpc3xxx_i2s_set_dai_clkdiv,
+};
+
+struct snd_soc_dai_driver lpc3xxx_i2s_dai[NUM_I2S_DEVICES] = {
+{
+	.name = "lpc3xxx-i2s0",
+	.id = 0,
+	.suspend = lpc3xxx_i2s_suspend,
+	.resume = lpc3xxx_i2s_resume,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC3XXX_I2S_RATES,
+		.formats = LPC3XXX_I2S_FORMATS,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC3XXX_I2S_RATES,
+		.formats = LPC3XXX_I2S_FORMATS,
+	},
+	.ops = &lpc3xxx_i2s_dai_ops,
+},
+{
+	.name = "lpc3xxx-i2s1",
+	.id = 1,
+	.suspend = lpc3xxx_i2s_suspend,
+	.resume = lpc3xxx_i2s_resume,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC3XXX_I2S_RATES,
+		.formats = LPC3XXX_I2S_FORMATS,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC3XXX_I2S_RATES,
+		.formats = LPC3XXX_I2S_FORMATS,
+	},
+	.ops = &lpc3xxx_i2s_dai_ops,
+},
+};
+
+/*
+ * Platform probe function
+ */
+static __devinit int lpc3xxx_i2s_plat_probe(struct platform_device *pdev)
+{
+	char clk_name[2 * CLK_NAME];
+	int ret, i, j;
+	struct resource *res;
+	resource_size_t size;
+	u32 clkx, clky;
+	struct lpc3xxx_i2s_info *i2s;
+
+	/* Allocate mem for i2s_info structure */
+	i2s_info = devm_kzalloc(&pdev->dev,
+			(sizeof(struct lpc3xxx_i2s_info) * pdev->num_resources), GFP_KERNEL);
+	if (unlikely(!i2s_info)) {
+		dev_err(&pdev->dev, "Can't allocate i2s_info \n");
+		return -ENOMEM;
+	}
+	dev_set_drvdata(&pdev->dev, i2s_info);
+
+	for(i = 0; i < pdev->num_resources; i++) {
+		i2s = &i2s_info[i];
+
+		/* Enable I2S clock */
+		snprintf(&clk_name[i * CLK_NAME], CLK_NAME, "i2s%d_ck", i);
+		i2s->clkname = &clk_name[i * CLK_NAME];
+		i2s->clk = clk_get(NULL, i2s->clkname);
+		if (IS_ERR(i2s->clk)) {
+			i2s->clk = NULL;
+			pr_warning("%s: Failed enabling the I2S clock: %s\n",
+				I2S_NAME, i2s->clkname);
+			return -ENODEV;
+		}
+
+		clk_enable(i2s->clk);
+		i2s->clkrate = clk_get_rate(i2s->clk);
+		if (i2s->clkrate == 0) {
+			pr_warning("%s: Invalid returned clock rate\n",
+				I2S_NAME);
+			clk_disable(i2s->clk);
+			clk_put(i2s->clk);
+			i2s->clk = NULL;
+			return -ENODEV;
+		}
+
+		/* Get Virtual CPU address for I2S */
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res) {
+			dev_err(&pdev->dev, "No memory resource\n");
+			clk_disable(i2s->clk);
+			clk_put(i2s->clk);
+			i2s->clk = NULL;
+			ret = -ENODEV;
+			goto err_res;
+		}
+
+		size = resource_size(res);
+		if (!devm_request_mem_region(&pdev->dev, res->start, size,
+				     pdev->name)) {
+			dev_err(&pdev->dev, "I2S registers are not free\n");
+			clk_disable(i2s->clk);
+			clk_put(i2s->clk);
+			i2s->clk = NULL;
+			ret = -EBUSY;
+			goto err_res;
+		}
+		i2s->iomem = devm_ioremap(&pdev->dev, res->start, size);
+		if (!i2s->iomem) {
+			dev_err(&pdev->dev, "Can't map memory\n");
+			clk_disable(i2s->clk);
+			clk_put(i2s->clk);
+			i2s->clk = NULL;
+			ret = -ENOMEM;
+			goto err_res;
+		}
+
+		spin_lock_init(&i2s->lock);
+
+		/* I2S is setup here with a dummy configuration to allow the
+		   bit clock to toggle. The CODEC attached to the I2S may not
+		   work without this clock. The actual values here do not yet
+		   matter and will be reconfigured when needed by the I2S hw
+		   setup function. To match the default selected PLL setting,
+                   this clock should be between 6.25 and 12.5KHz */
+		__raw_writel(I2S_DMA0_TX_DEPTH(4), I2S_DMA1(i2s->iomem));
+		__lpc3xxx_find_clkdiv(&clkx, &clky, 9000, 2, i2s->clkrate);
+		__raw_writel(((clkx << 8) | clky), I2S_TX_RATE(i2s->iomem));
+		__raw_writel(0x83C1, I2S_DAO(i2s->iomem));
+
+		i2s->initialized = 1;
+	}
+
+	/* Regsiter SND SOC driver */
+	ret = snd_soc_register_dais(&pdev->dev, &lpc3xxx_i2s_dai[0], 2);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_res;
+	}
+
+	return 0;
+
+err_res:
+	for(j =0 ; j < i; j++) {
+		clk_disable(i2s_info[j].clk);
+		clk_put(i2s_info[j].clk);
+		i2s_info[j].clk = NULL;
+	}
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return ret;
+}
+
+static int __devexit lpc3xxx_i2s_plat_remove(struct platform_device *pdev)
+{
+	int j;
+	struct lpc3xxx_i2s_info *i2s = dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_dais(&pdev->dev, 2);
+
+	for(j =0 ; j < pdev->num_resources; j++) {
+		clk_disable(i2s[j].clk);
+		clk_put(i2s[j].clk);
+		i2s[j].clk = NULL;
+	}
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver lpc3xxx_i2s_driver = {
+	.driver = {
+		.name = I2S_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = lpc3xxx_i2s_plat_probe,
+	.remove = __devexit_p(lpc3xxx_i2s_plat_remove),
+};
+
+static int __init lpc3xxx_i2s_dai_init(void)
+{
+	return platform_driver_register(&lpc3xxx_i2s_driver);
+}
+module_init(lpc3xxx_i2s_dai_init);
+
+static void __exit lpc3xxx_i2s_dai_exit(void)
+{
+	return platform_driver_unregister(&lpc3xxx_i2s_driver);
+}
+module_exit(lpc3xxx_i2s_dai_exit)
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC LPC3XXX I2S interface");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/lpc3xxx/lpc3xxx-i2s.h b/sound/soc/lpc3xxx/lpc3xxx-i2s.h
new file mode 100644
index 0000000..3fa03de
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-i2s.h
@@ -0,0 +1,53 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-i2s.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __SOUND_SOC_LPC3XXX_I2S_H
+#define __SOUND_SOC_LPC3XXX_I2S_H
+
+#include <linux/types.h>
+#include <mach/clkdev.h>
+#include <mach/i2s.h>
+
+#define NUM_I2S_DEVICES		2
+
+#define I2S_DMA_XMIT		0x1
+#define I2S_DMA_RECV		0x2
+
+struct lpc3xxx_i2s_info {
+	char *name;
+	spinlock_t lock;
+	void *iomem;
+	unsigned short initialized;
+	u32 dma_flags;
+	char *clkname;
+	struct clk *clk;
+	u32 clkrate;
+	u32 baseio;
+	int freq;
+	unsigned short daifmt;
+	int clkdiv;
+	u32 dao_save, dai_save, irq_save;
+};
+
+//extern struct snd_soc_dai lpc3xxx_i2s_dai[];
+
+#endif
diff --git a/sound/soc/lpc3xxx/lpc3xxx-pcm.c b/sound/soc/lpc3xxx/lpc3xxx-pcm.c
new file mode 100644
index 0000000..1d60900
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-pcm.c
@@ -0,0 +1,534 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-pcm.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <mach/dma.h>
+#include <mach/dmac.h>
+#include <mach/i2s.h>
+#include "lpc3xxx-pcm.h"
+
+#define SND_NAME "lpc3xxx-audio"
+
+static u64 lpc3xxx_pcm_dmamask = 0xffffffff;
+
+#define NUMLINKS (3) /* 3 DMA buffers */
+
+static const struct snd_pcm_hardware lpc3xxx_pcm_hardware = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_PAUSE |
+		 SNDRV_PCM_INFO_RESUME),
+	.formats = (SND_SOC_DAIFMT_I2S),
+	.period_bytes_min = 128,
+	.period_bytes_max = 2048,
+	.periods_min = 2,
+	.periods_max = 1024,
+	.buffer_bytes_max = 128 * 1024
+};
+
+struct lpc3xxx_dma_data {
+	dma_addr_t dma_buffer;	/* physical address of DMA buffer */
+	dma_addr_t dma_buffer_end; /* first address beyond DMA buffer */
+	size_t period_size;
+
+	/* DMA configuration and support */
+	int dmach;
+	struct dma_config dmacfg;
+	volatile dma_addr_t period_ptr;	/* physical address of next period */
+	volatile dma_addr_t dma_cur;
+	u32 llptr;		/* Saved for debug only, not used */
+};
+
+static int lpc3xxx_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *dmabuf = &substream->dma_buffer;
+	size_t size = lpc3xxx_pcm_hardware.buffer_bytes_max;
+
+	dmabuf->dev.type = SNDRV_DMA_TYPE_DEV;
+	dmabuf->dev.dev = pcm->card->dev;
+	dmabuf->private_data = NULL;
+	dmabuf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &dmabuf->addr, GFP_KERNEL);
+
+	if (!dmabuf->area)
+		return -ENOMEM;
+
+	dmabuf->bytes = size;
+	return 0;
+}
+
+/*
+ * DMA ISR - occurs when a new DMA buffer is needed
+ */
+static void lpc3xxx_pcm_dma_irq(int channel, int cause,
+				struct snd_pcm_substream *substream) {
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc3xxx_dma_data *prtd = rtd->private_data;
+	static int count = 0;
+
+	count++;
+
+	/* A DMA interrupt occurred - for most cases, this will be the end
+	   of a transmitted buffer in the DMA link list, but errors are also
+	   handled. */
+	if (cause & DMA_ERR_INT) {
+		/* DMA error - this should never happen, but you just never
+		   know. If it does happen, the driver will continue without
+		   any problems except for maybe an audio glitch or pop. */
+		pr_debug("%s: DMA error %s (count=%d)\n", SND_NAME,
+			   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+			   "underrun" : "overrun", count);
+	}
+	/* Dequeue buffer from linked list */
+	lpc32xx_get_free_llist_entry(channel);
+	prtd->dma_cur += prtd->period_size;
+	if (prtd->dma_cur >= prtd->dma_buffer_end) {
+		prtd->dma_cur = prtd->dma_buffer;
+	}
+
+	/* Re-queue buffer another buffer */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		lpc32xx_dma_queue_llist_entry(prtd->dmach, (void *) prtd->period_ptr,
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+			(void *) I2S_TX_FIFO(LPC32XX_I2S1_BASE),
+#else
+			(void *) I2S_TX_FIFO(LPC32XX_I2S0_BASE),
+#endif
+			prtd->period_size);
+	}
+	else {
+		lpc32xx_dma_queue_llist_entry(prtd->dmach,
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+			(void *) I2S_RX_FIFO(LPC32XX_I2S1_BASE),
+#else
+			(void *) I2S_RX_FIFO(LPC32XX_I2S0_BASE),
+#endif
+			(void *) prtd->period_ptr, prtd->period_size);
+	}
+	prtd->period_ptr += prtd->period_size;
+	if (prtd->period_ptr >= prtd->dma_buffer_end)
+		prtd->period_ptr = prtd->dma_buffer;
+
+	/* This only needs to be called once, even if more than 1 period has passed */
+	snd_pcm_period_elapsed(substream);
+}
+
+/*
+ * PCM operations
+ */
+static int lpc3xxx_pcm_hw_params(struct snd_pcm_substream *substream,
+			         struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc3xxx_dma_data *prtd = runtime->private_data;
+
+	/* this may get called several times by oss emulation
+	 * with different params
+	 */
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+
+	prtd->dma_buffer = runtime->dma_addr;
+	prtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;
+	prtd->period_size = params_period_bytes(params);
+
+	return 0;
+}
+
+static int lpc3xxx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct lpc3xxx_dma_data *prtd = substream->runtime->private_data;
+
+	/* Return the DMA channel */
+	if (prtd->dmach != -1) {
+		lpc32xx_dma_ch_disable(prtd->dmach);
+		lpc32xx_dma_dealloc_llist(prtd->dmach);
+		lpc32xx_dma_ch_put(prtd->dmach);
+		prtd->dmach = -1;
+	}
+
+	return 0;
+}
+
+static int lpc3xxx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct lpc3xxx_dma_data *prtd = substream->runtime->private_data;
+
+	/* Setup DMA channel */
+	if (prtd->dmach == -1) {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			prtd->dmach = DMA_CH_I2S_TX;
+			prtd->dmacfg.ch = DMA_CH_I2S_TX;
+			prtd->dmacfg.tc_inten = 1;
+			prtd->dmacfg.err_inten = 1;
+			prtd->dmacfg.src_size = 4;
+			prtd->dmacfg.src_inc = 1;
+			prtd->dmacfg.src_ahb1 = 1;
+			prtd->dmacfg.src_bsize = DMAC_CHAN_SRC_BURST_4;
+			prtd->dmacfg.src_prph = 0;
+			prtd->dmacfg.dst_size = 4;
+			prtd->dmacfg.dst_inc = 0;
+			prtd->dmacfg.dst_bsize = DMAC_CHAN_DEST_BURST_4;
+			prtd->dmacfg.dst_ahb1 = 0;
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+			prtd->dmacfg.dst_prph = DMAC_DEST_PERIP(DMA_PERID_I2S1_DMA1);
+#else
+			prtd->dmacfg.dst_prph = DMAC_DEST_PERIP(DMA_PERID_I2S0_DMA1);
+#endif
+			prtd->dmacfg.flowctrl = DMAC_CHAN_FLOW_D_M2P;
+			if (lpc32xx_dma_ch_get(&prtd->dmacfg, "dma_i2s_tx",
+				&lpc3xxx_pcm_dma_irq, substream) < 0) {
+				pr_debug(KERN_ERR "Error setting up I2S TX DMA channel\n");
+				return -ENODEV;
+			}
+
+			/* Allocate a linked list for audio buffers */
+			prtd->llptr = lpc32xx_dma_alloc_llist(prtd->dmach, NUMLINKS);
+			if (prtd->llptr == 0) {
+				lpc32xx_dma_ch_put(prtd->dmach);
+				prtd->dmach = -1;
+				pr_debug(KERN_ERR "Error allocating list buffer (I2S TX)\n");
+				return -ENOMEM;
+			}
+		}
+		else {
+			prtd->dmach = DMA_CH_I2S_RX;
+			prtd->dmacfg.ch = DMA_CH_I2S_RX;
+			prtd->dmacfg.tc_inten = 1;
+			prtd->dmacfg.err_inten = 1;
+			prtd->dmacfg.src_size = 4;
+			prtd->dmacfg.src_inc = 0;
+			prtd->dmacfg.src_ahb1 = 1;
+			prtd->dmacfg.src_bsize = DMAC_CHAN_SRC_BURST_4;
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+			prtd->dmacfg.src_prph = DMAC_SRC_PERIP(DMA_PERID_I2S1_DMA0);
+#else
+			prtd->dmacfg.src_prph = DMAC_SRC_PERIP(DMA_PERID_I2S0_DMA0);
+#endif
+			prtd->dmacfg.dst_size = 4;
+			prtd->dmacfg.dst_inc = 1;
+			prtd->dmacfg.dst_ahb1 = 0;
+			prtd->dmacfg.dst_bsize = DMAC_CHAN_DEST_BURST_4;
+			prtd->dmacfg.dst_prph = 0;
+			prtd->dmacfg.flowctrl = DMAC_CHAN_FLOW_D_P2M;
+			if (lpc32xx_dma_ch_get(&prtd->dmacfg, "dma_i2s_rx",
+				&lpc3xxx_pcm_dma_irq, substream) < 0) {
+				pr_debug(KERN_ERR "Error setting up I2S RX DMA channel\n");
+				return -ENODEV;
+			}
+
+			/* Allocate a linked list for audio buffers */
+			prtd->llptr = lpc32xx_dma_alloc_llist(prtd->dmach, NUMLINKS);
+			if (prtd->llptr == 0) {
+				lpc32xx_dma_ch_put(prtd->dmach);
+				prtd->dmach = -1;
+				pr_debug(KERN_ERR "Error allocating list buffer (I2S RX)\n");
+				return -ENOMEM;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int lpc3xxx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc3xxx_dma_data *prtd = rtd->private_data;
+	int i, ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->period_ptr = prtd->dma_cur = prtd->dma_buffer;
+		lpc32xx_dma_flush_llist(prtd->dmach);
+
+		/* Queue a few buffers to start DMA */
+		for (i = 0; i < NUMLINKS; i++) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				lpc32xx_dma_queue_llist_entry(prtd->dmach, (void *) prtd->period_ptr,
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+					(void *) I2S_TX_FIFO(LPC32XX_I2S1_BASE),
+#else
+					(void *) I2S_TX_FIFO(LPC32XX_I2S0_BASE),
+#endif
+					prtd->period_size);
+			}
+			else {
+				lpc32xx_dma_queue_llist_entry(prtd->dmach,
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+				(void *) I2S_RX_FIFO(LPC32XX_I2S1_BASE),
+#else
+				(void *) I2S_RX_FIFO(LPC32XX_I2S0_BASE),
+#endif
+				(void *) prtd->period_ptr, prtd->period_size);
+
+			}
+
+			prtd->period_ptr += prtd->period_size;
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		lpc32xx_dma_flush_llist(prtd->dmach);
+		lpc32xx_dma_ch_disable(prtd->dmach);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		lpc32xx_dma_ch_pause_unpause(prtd->dmach, 1);
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		lpc32xx_dma_ch_pause_unpause(prtd->dmach, 0);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t lpc3xxx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc3xxx_dma_data *prtd = runtime->private_data;
+	snd_pcm_uframes_t x;
+
+	/* Return an offset into the DMA buffer for the next data */
+	x = bytes_to_frames(runtime, (prtd->dma_cur - runtime->dma_addr));
+	if (x >= runtime->buffer_size)
+		x = 0;
+
+	return x;
+}
+
+static int lpc3xxx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc3xxx_dma_data *prtd;
+	int ret = 0;
+
+	snd_soc_set_runtime_hwparams(substream, &lpc3xxx_pcm_hardware);
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	runtime->private_data = prtd;
+	prtd->dmach = -1;
+
+out:
+	return ret;
+}
+
+static int lpc3xxx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct lpc3xxx_dma_data *prtd = substream->runtime->private_data;
+
+	kfree(prtd);
+	return 0;
+}
+
+static int lpc3xxx_pcm_mmap(struct snd_pcm_substream *substream,
+			    struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops lpc3xxx_pcm_ops = {
+	.open = lpc3xxx_pcm_open,
+	.close = lpc3xxx_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = lpc3xxx_pcm_hw_params,
+	.hw_free = lpc3xxx_pcm_hw_free,
+	.prepare = lpc3xxx_pcm_prepare,
+	.trigger = lpc3xxx_pcm_trigger,
+	.pointer = lpc3xxx_pcm_pointer,
+	.mmap = lpc3xxx_pcm_mmap,
+};
+
+/*
+ * ASoC platform driver
+ */
+static int lpc3xxx_pcm_new(struct snd_card *card,
+			   struct snd_soc_dai *dai,
+			   struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &lpc3xxx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->driver->playback.channels_min) {
+		ret = lpc3xxx_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->driver->capture.channels_min) {
+		pr_debug("%s: Allocating PCM capture DMA buffer\n", SND_NAME);
+		ret = lpc3xxx_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void lpc3xxx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (substream == NULL)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+
+		buf->area = NULL;
+	}
+}
+
+#if defined(CONFIG_PM)
+static int lpc3xxx_pcm_suspend(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct lpc3xxx_dma_data *prtd;
+
+	if (runtime == NULL)
+		return 0;
+
+	prtd = runtime->private_data;
+
+	/* Disable the DMA channel */
+	lpc32xx_dma_ch_disable(prtd->dmach);
+
+	return 0;
+}
+
+static int lpc3xxx_pcm_resume(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct lpc3xxx_dma_data *prtd;
+
+	if (runtime == NULL)
+		return 0;
+
+	prtd = runtime->private_data;
+
+	/* Enable the DMA channel */
+	lpc32xx_dma_ch_enable(prtd->dmach);
+
+	return 0;
+}
+
+#else
+#define lpc3xxx_pcm_suspend	NULL
+#define lpc3xxx_pcm_resume	NULL
+#endif
+
+static struct snd_soc_platform_driver lpc3xxx_soc_platform = {
+	.ops = &lpc3xxx_pcm_ops,
+	.pcm_new = lpc3xxx_pcm_new,
+	.pcm_free = lpc3xxx_pcm_free_dma_buffers,
+	.suspend = lpc3xxx_pcm_suspend,
+	.resume = lpc3xxx_pcm_resume,
+};
+
+static int __devinit lpc3xxx_pcm_plat_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &lpc3xxx_soc_platform);
+}
+
+static int __devexit lpc3xxx_pcm_plat_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver lpc3xxx_pcm_driver = {
+	.driver = {
+		.name = SND_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = lpc3xxx_pcm_plat_probe,
+	.remove = __devexit_p(lpc3xxx_pcm_plat_remove),
+};
+
+static int __init lpc3xxx_soc_platform_init(void)
+{
+	return platform_driver_register(&lpc3xxx_pcm_driver);
+}
+module_init(lpc3xxx_soc_platform_init);
+
+static void __exit lpc3xxx_soc_platform_exit(void)
+{
+	return platform_driver_unregister(&lpc3xxx_pcm_driver);
+}
+module_exit(lpc3xxx_soc_platform_exit)
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("NXP LPC3XXX PCM module");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/lpc3xxx/lpc3xxx-pcm.h b/sound/soc/lpc3xxx/lpc3xxx-pcm.h
new file mode 100644
index 0000000..66f8eab
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-pcm.h
@@ -0,0 +1,29 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-pcm.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __SOUND_SOC_LPC3XXX_PCM_H
+#define __SOUND_SOC_LPC3XXX_PCM_H
+
+//extern struct snd_soc_platform lpc3xxx_soc_platform;
+
+#endif
+
diff --git a/sound/soc/lpc3xxx/lpc3xxx-uda1380.c b/sound/soc/lpc3xxx/lpc3xxx-uda1380.c
new file mode 100644
index 0000000..760503e
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-uda1380.c
@@ -0,0 +1,227 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-uda1380.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/uda1380.h>
+
+#include <mach/gpio.h>
+
+#include "../codecs/uda1380.h"
+#include "lpc3xxx-pcm.h"
+#include "lpc3xxx-i2s.h"
+
+#define SND_MODNAME "lpc3xxx_uda1380"
+
+static int phy3250_uda1380_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	unsigned int fmt = SND_SOC_DAIFMT_I2S;
+	int ret;
+
+	/* The perspective is from the CODEC side, so slave mode means that
+	    the i2s interface is the master. For the UDA1380 and playback,
+	    the CODEC is always a slave and i2s is always a master. */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		fmt |= SND_SOC_DAIFMT_CBS_CFS;
+	}
+	else {
+
+#if defined(CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODERX)
+		fmt |= SND_SOC_DAIFMT_CBM_CFM;
+#else
+		fmt |= SND_SOC_DAIFMT_CBS_CFS;
+#endif
+	}
+
+	/* Set the CPU I2S rate clock (first) */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params),
+					    SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set I2S clock (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	/* Set CPU and CODEC DAI format */
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CPU DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CODEC DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops phy3250_uda1380_ops = {
+	.hw_params = phy3250_uda1380_hw_params,
+};
+
+static const struct snd_soc_dapm_widget phy3250_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_LINE("Line Out", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* Headphone connected to VOUTRHP, VOUTLHP */
+	{"Headphone Jack", NULL, "VOUTRHP"},
+	{"Headphone Jack", NULL, "VOUTLHP"},
+
+	/* Line Out connected to VOUTR, VOUTL */
+	{"Line Out", NULL, "VOUTR"},
+	{"Line Out", NULL, "VOUTL"},
+
+	/* Mic connected to VINM */
+	{"VINM", NULL, "Mic Jack"},
+
+	/* Line In connected to VINR, VINL */
+	{"VINL", NULL, "Line In"},
+	{"VINR", NULL, "Line In"},
+};
+
+static int phy3250_uda1380_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int err;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	/* Add widgets */
+	err = snd_soc_dapm_new_controls(dapm, phy3250_dapm_widgets,
+				  ARRAY_SIZE(phy3250_dapm_widgets));
+	if (err)
+		return err;
+
+	/* Set up audio_map */
+	err = snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
+	if (err)
+		return err;
+
+	/* Always connected pins */
+	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
+	snd_soc_dapm_enable_pin(dapm, "Line Out");
+	snd_soc_dapm_enable_pin(dapm, "Mic Jack");
+	snd_soc_dapm_enable_pin(dapm, "Line In");
+
+	snd_soc_dapm_sync(dapm);
+
+	return 0;
+}
+
+/* s3c24xx digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link phy3250_uda1380_dai[] = {
+	{
+		.name		= "uda1380",
+		.stream_name	= "UDA1380 Duplex",
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+		.cpu_dai_name	= "lpc3xxx-i2s1",
+#else
+		.cpu_dai_name	= "lpc3xxx-i2s0",
+#endif
+		.codec_dai_name	= "uda1380-hifi",
+		.init		= phy3250_uda1380_init,
+		.platform_name	= "lpc3xxx-audio.0",
+		.codec_name	= "uda1380-codec.0-0018",
+		.ops		= &phy3250_uda1380_ops,
+	},
+};
+
+static struct snd_soc_card phy3250_snd_asoc = {
+	.name = "LPC32XX",
+	.dai_link = &phy3250_uda1380_dai[0],
+	.num_links = ARRAY_SIZE(phy3250_uda1380_dai),
+};
+
+static struct platform_device *phy3250_snd_device;
+
+static int __init phy3250_asoc_init(void)
+{
+	int ret = 0;
+
+	/*
+	 * Create and register platform device
+	 */
+	phy3250_snd_device = platform_device_alloc("soc-audio", 0);
+	if (phy3250_snd_device == NULL) {
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(phy3250_snd_device, &phy3250_snd_asoc);
+
+	ret = platform_device_add(phy3250_snd_device);
+	if (ret) {
+		pr_warning("%s: platform_device_add failed (%d)\n",
+			   SND_MODNAME, ret);
+		goto err_device_add;
+	}
+
+	return 0;
+
+err_device_add:
+	if (phy3250_snd_device != NULL) {
+		platform_device_put(phy3250_snd_device);
+		phy3250_snd_device = NULL;
+	}
+
+	return ret;
+}
+
+static void __exit phy3250_asoc_exit(void)
+{
+	platform_device_unregister(phy3250_snd_device);
+	phy3250_snd_device = NULL;
+}
+
+module_init(phy3250_asoc_init);
+module_exit(phy3250_asoc_exit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC machine driver for LPC3XXX/UDA1380");
+MODULE_LICENSE("GPL");
-- 
1.7.0.4


From 9797149a4008920792688f2e4bb2cfdc14b7cd5e Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Fri, 26 Aug 2011 15:04:50 -0700
Subject: [PATCH 02/10] Update kernel build configs to 2.6.39.2 kernel

---
 arch/arm/configs/ea3250_defconfig  |  295 +++++++++++++++++++++++++++---------
 arch/arm/configs/fdi3250_defconfig |  263 +++++++++++++++++++++++---------
 arch/arm/configs/phy3250_defconfig |  277 +++++++++++++++++++++++++---------
 3 files changed, 621 insertions(+), 214 deletions(-)

diff --git a/arch/arm/configs/ea3250_defconfig b/arch/arm/configs/ea3250_defconfig
index 3c37e03..5a0cc53 100644
--- a/arch/arm/configs/ea3250_defconfig
+++ b/arch/arm/configs/ea3250_defconfig
@@ -1,15 +1,14 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.34
-# Thu Apr  7 11:26:32 2011
+# Linux/arm 2.6.39.2 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
 CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
 CONFIG_HAVE_PROC_CPU=y
-CONFIG_GENERIC_HARDIRQS=y
 CONFIG_STACKTRACE_SUPPORT=y
 CONFIG_HAVE_LATENCYTOP_SUPPORT=y
 CONFIG_LOCKDEP_SUPPORT=y
@@ -17,27 +16,29 @@ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
 CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 CONFIG_CONSTRUCTORS=y
+CONFIG_HAVE_IRQ_WORK=y
 
 #
 # General setup
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
 CONFIG_LOCALVERSION=""
 CONFIG_LOCALVERSION_AUTO=y
 CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
 CONFIG_HAVE_KERNEL_LZO=y
 CONFIG_KERNEL_GZIP=y
-# CONFIG_KERNEL_BZIP2 is not set
 # CONFIG_KERNEL_LZMA is not set
 # CONFIG_KERNEL_LZO is not set
 CONFIG_SWAP=y
@@ -45,15 +46,26 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
 # CONFIG_TASKSTATS is not set
 # CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
 
 #
 # RCU Subsystem
 #
-CONFIG_TREE_RCU=y
-# CONFIG_TREE_PREEMPT_RCU is not set
+CONFIG_TREE_PREEMPT_RCU=y
 # CONFIG_TINY_RCU is not set
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
 # CONFIG_RCU_TRACE is not set
 CONFIG_RCU_FANOUT=32
 # CONFIG_RCU_FANOUT_EXACT is not set
@@ -62,20 +74,22 @@ CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
 CONFIG_SYSFS_DEPRECATED=y
 CONFIG_SYSFS_DEPRECATED_V2=y
 # CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_RD_GZIP=y
 # CONFIG_RD_BZIP2 is not set
 # CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
 # CONFIG_RD_LZO is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
 CONFIG_ANON_INODES=y
-CONFIG_EMBEDDED=y
+CONFIG_EXPERT=y
 CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
@@ -93,6 +107,7 @@ CONFIG_TIMERFD=y
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
 CONFIG_AIO=y
+CONFIG_EMBEDDED=y
 CONFIG_HAVE_PERF_EVENTS=y
 CONFIG_PERF_USE_VMALLOC=y
 
@@ -111,11 +126,13 @@ CONFIG_HAVE_OPROFILE=y
 # CONFIG_KPROBES is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
 
 #
 # GCOV-based kernel profiling
 #
-# CONFIG_SLOW_WORK is not set
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
@@ -176,18 +193,20 @@ CONFIG_FREEZER=y
 # System Type
 #
 CONFIG_MMU=y
-# CONFIG_ARCH_AAEC2000 is not set
 # CONFIG_ARCH_INTEGRATOR is not set
 # CONFIG_ARCH_REALVIEW is not set
 # CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
 # CONFIG_ARCH_AT91 is not set
 # CONFIG_ARCH_BCMRING is not set
 # CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
 # CONFIG_ARCH_GEMINI is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
 # CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
 # CONFIG_ARCH_STMP3XXX is not set
 # CONFIG_ARCH_NETX is not set
 # CONFIG_ARCH_H720X is not set
@@ -197,7 +216,6 @@ CONFIG_MMU=y
 # CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
 # CONFIG_ARCH_DOVE is not set
 # CONFIG_ARCH_KIRKWOOD is not set
 # CONFIG_ARCH_LOKI is not set
@@ -209,6 +227,7 @@ CONFIG_ARCH_LPC32XX=y
 # CONFIG_ARCH_NS9XXX is not set
 # CONFIG_ARCH_W90X900 is not set
 # CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_MSM is not set
@@ -217,17 +236,22 @@ CONFIG_ARCH_LPC32XX=y
 # CONFIG_ARCH_SA1100 is not set
 # CONFIG_ARCH_S3C2410 is not set
 # CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P64X0 is not set
 # CONFIG_ARCH_S5P6442 is not set
-# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_S5PC100 is not set
 # CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
 # CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_TCC_926 is not set
 # CONFIG_ARCH_U300 is not set
 # CONFIG_ARCH_U8500 is not set
 # CONFIG_ARCH_NOMADIK is not set
 # CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
 # CONFIG_MACH_PHY3250 is not set
 CONFIG_MACH_EA3250=y
 # CONFIG_MACH_FDI3250 is not set
@@ -260,6 +284,10 @@ CONFIG_ARCH_LPC32XX_UART5_SELECT=y
 # CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
 
 #
+# System MMU
+#
+
+#
 # Processor Type
 #
 CONFIG_CPU_ARM926T=y
@@ -271,6 +299,7 @@ CONFIG_CPU_COPY_V4WB=y
 CONFIG_CPU_TLB_V4WBI=y
 CONFIG_CPU_CP15=y
 CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
 
 #
 # Processor Features
@@ -281,7 +310,6 @@ CONFIG_ARM_THUMB=y
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
 CONFIG_ARM_L1_CACHE_SHIFT=5
-CONFIG_COMMON_CLKDEV=y
 
 #
 # Bus support
@@ -313,19 +341,24 @@ CONFIG_OABI_COMPAT=y
 # CONFIG_HIGHMEM is not set
 CONFIG_SELECT_MEMORY_MODEL=y
 CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
 CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
 # CONFIG_PHYS_ADDR_T_64BIT is not set
 CONFIG_ZONE_DMA_FLAG=0
 CONFIG_VIRT_TO_BUS=y
 # CONFIG_KSM is not set
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_FORCE_MAX_ZONEORDER=11
 CONFIG_ALIGNMENT_TRAP=y
 # CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
 
 #
 # Boot options
@@ -333,8 +366,11 @@ CONFIG_ALIGNMENT_TRAP=y
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="console=ttyS0,115200n81 root=/dev/ram0"
+# CONFIG_CMDLINE_FORCE is not set
 # CONFIG_XIP_KERNEL is not set
 # CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
 
 #
 # CPU Power Management
@@ -367,14 +403,13 @@ CONFIG_BINFMT_AOUT=y
 #
 # Power management options
 #
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
 CONFIG_SUSPEND=y
 CONFIG_SUSPEND_FREEZER=y
-# CONFIG_APM_EMULATION is not set
+CONFIG_PM_SLEEP=y
 # CONFIG_PM_RUNTIME is not set
-CONFIG_PM_OPS=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_NET=y
 
@@ -387,13 +422,12 @@ CONFIG_UNIX=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
 # CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
 # CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
@@ -413,12 +447,14 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
 # CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
 # CONFIG_NETFILTER is not set
 # CONFIG_IP_DCCP is not set
 # CONFIG_IP_SCTP is not set
 # CONFIG_RDS is not set
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
+# CONFIG_L2TP is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_NET_DSA is not set
 # CONFIG_VLAN_8021Q is not set
@@ -434,6 +470,7 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_IEEE802154 is not set
 # CONFIG_NET_SCHED is not set
 # CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
 
 #
 # Network testing
@@ -448,6 +485,8 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
 
 #
 # Device Drivers
@@ -468,7 +507,6 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
 # CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_CONCAT is not set
 CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 CONFIG_MTD_CMDLINE_PARTS=y
@@ -486,7 +524,9 @@ CONFIG_MTD_BLOCK=y
 # CONFIG_INFTL is not set
 # CONFIG_RFD_FTL is not set
 # CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
 # CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -530,9 +570,12 @@ CONFIG_MTD_CFI_I2=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
 CONFIG_MTD_NAND=y
 # CONFIG_MTD_NAND_VERIFY_WRITE is not set
-# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
 CONFIG_MTD_NAND_MUSEUM_IDS=y
 # CONFIG_MTD_NAND_GPIO is not set
 CONFIG_MTD_NAND_IDS=y
@@ -547,10 +590,6 @@ CONFIG_MTD_NAND_SLC_LPC32XX=y
 # LPDDR flash memory drivers
 #
 # CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
 # CONFIG_MTD_UBI is not set
 # CONFIG_PARPORT is not set
 CONFIG_BLK_DEV=y
@@ -570,14 +609,23 @@ CONFIG_BLK_DEV_RAM_SIZE=16384
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
 # CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
 CONFIG_MISC_DEVICES=y
 # CONFIG_AD525X_DPOT is not set
 # CONFIG_ICS932S401 is not set
 # CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
 # CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
 # CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
 # CONFIG_DS1682 is not set
 # CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
 # CONFIG_C2PORT is not set
 
 #
@@ -589,6 +637,12 @@ CONFIG_EEPROM_AT25=y
 # CONFIG_EEPROM_MAX6875 is not set
 # CONFIG_EEPROM_93CX6 is not set
 # CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
 CONFIG_HAVE_IDE=y
 # CONFIG_IDE is not set
 
@@ -624,10 +678,12 @@ CONFIG_SCSI_WAIT_SCAN=m
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
 # CONFIG_SCSI_SAS_LIBSAS is not set
 # CONFIG_SCSI_SRP_ATTRS is not set
 CONFIG_SCSI_LOWLEVEL=y
 # CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
 # CONFIG_LIBFC is not set
 # CONFIG_LIBFCOE is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -635,6 +691,7 @@ CONFIG_SCSI_LOWLEVEL=y
 # CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
 # CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -642,6 +699,7 @@ CONFIG_NETDEVICES=y
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
 # CONFIG_VETH is not set
+CONFIG_MII=y
 CONFIG_PHYLIB=y
 
 #
@@ -655,6 +713,7 @@ CONFIG_PHYLIB=y
 # CONFIG_VITESSE_PHY is not set
 # CONFIG_SMSC_PHY is not set
 # CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM63XX_PHY is not set
 # CONFIG_ICPLUS_PHY is not set
 # CONFIG_REALTEK_PHY is not set
 CONFIG_NATIONAL_PHY=y
@@ -664,7 +723,6 @@ CONFIG_NATIONAL_PHY=y
 # CONFIG_FIXED_PHY is not set
 # CONFIG_MDIO_BITBANG is not set
 CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
 # CONFIG_AX88796 is not set
 # CONFIG_SMC91X is not set
 # CONFIG_DM9000 is not set
@@ -681,10 +739,10 @@ CONFIG_MII=y
 # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
 # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
 # CONFIG_B44 is not set
-# CONFIG_KS8842 is not set
 # CONFIG_KS8851 is not set
 # CONFIG_KS8851_MLL is not set
 CONFIG_LPC_ENET=y
+# CONFIG_FTMAC100 is not set
 # CONFIG_NETDEV_1000 is not set
 # CONFIG_NETDEV_10000 is not set
 # CONFIG_WLAN is not set
@@ -703,6 +761,10 @@ CONFIG_LPC_ENET=y
 # CONFIG_USB_USBNET is not set
 # CONFIG_USB_IPHETH is not set
 # CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
 # CONFIG_NETCONSOLE is not set
@@ -736,13 +798,16 @@ CONFIG_INPUT_EVDEV=y
 CONFIG_INPUT_KEYBOARD=y
 # CONFIG_KEYBOARD_ADP5588 is not set
 CONFIG_KEYBOARD_ATKBD=y
-# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
 # CONFIG_KEYBOARD_LKKBD is not set
 # CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
 # CONFIG_KEYBOARD_MATRIX is not set
 # CONFIG_KEYBOARD_LM8323 is not set
 # CONFIG_KEYBOARD_LPC32XX is not set
 # CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
 # CONFIG_KEYBOARD_NEWTON is not set
 # CONFIG_KEYBOARD_OPENCORES is not set
 # CONFIG_KEYBOARD_STOWAWAY is not set
@@ -754,10 +819,12 @@ CONFIG_KEYBOARD_ATKBD=y
 CONFIG_INPUT_TOUCHSCREEN=y
 CONFIG_TOUCHSCREEN_ADS7846=y
 # CONFIG_TOUCHSCREEN_AD7877 is not set
-# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
-# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
 # CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
 # CONFIG_TOUCHSCREEN_EETI is not set
 # CONFIG_TOUCHSCREEN_FUJITSU is not set
 # CONFIG_TOUCHSCREEN_GUNZE is not set
@@ -773,7 +840,11 @@ CONFIG_TOUCHSCREEN_ADS7846=y
 # CONFIG_TOUCHSCREEN_TOUCHWIN is not set
 # CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
 # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
 # CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
 # CONFIG_INPUT_MISC is not set
 
 #
@@ -785,6 +856,7 @@ CONFIG_SERIO_SERPORT=y
 CONFIG_SERIO_LIBPS2=y
 # CONFIG_SERIO_RAW is not set
 # CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
 # CONFIG_GAMEPORT is not set
 
 #
@@ -795,8 +867,12 @@ CONFIG_CONSOLE_TRANSLATIONS=y
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
 # CONFIG_VT_HW_CONSOLE_BINDING is not set
-CONFIG_DEVKMEM=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+CONFIG_DEVKMEM=y
 
 #
 # Serial drivers
@@ -813,22 +889,27 @@ CONFIG_SERIAL_8250_RUNTIME_UARTS=4
 # CONFIG_SERIAL_AMBA_PL010 is not set
 # CONFIG_SERIAL_AMBA_PL011 is not set
 # CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
 # CONFIG_SERIAL_HS_LPC32XX is not set
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_SERIAL_TIMBERDALE is not set
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
 # CONFIG_IPMI_HANDLER is not set
 # CONFIG_HW_RANDOM is not set
 # CONFIG_R3964 is not set
 # CONFIG_RAW_DRIVER is not set
 # CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_COMPAT=y
 CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
 CONFIG_I2C_HELPER_AUTO=y
 
 #
@@ -838,15 +919,19 @@ CONFIG_I2C_HELPER_AUTO=y
 #
 # I2C system bus drivers (mostly embedded / system-on-chip)
 #
+# CONFIG_I2C_DESIGNWARE is not set
 # CONFIG_I2C_GPIO is not set
 # CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
 CONFIG_I2C_PNX=y
+# CONFIG_I2C_PXA_PCI is not set
 # CONFIG_I2C_SIMTEC is not set
 # CONFIG_I2C_XILINX is not set
 
 #
 # External I2C/SMBus adapter drivers
 #
+# CONFIG_I2C_DIOLAN_U2C is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_TAOS_EVM is not set
 # CONFIG_I2C_TINY_USB is not set
@@ -854,7 +939,6 @@ CONFIG_I2C_PNX=y
 #
 # Other I2C/SMBus bus drivers
 #
-# CONFIG_I2C_PCA_PLATFORM is not set
 # CONFIG_I2C_STUB is not set
 # CONFIG_I2C_DEBUG_CORE is not set
 # CONFIG_I2C_DEBUG_ALGO is not set
@@ -866,9 +950,12 @@ CONFIG_SPI_MASTER=y
 #
 # SPI Master Controller Drivers
 #
+# CONFIG_SPI_ALTERA is not set
 # CONFIG_SPI_BITBANG is not set
 # CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
 CONFIG_SPI_PL022=y
+# CONFIG_SPI_PXA2XX_PCI is not set
 # CONFIG_SPI_XILINX is not set
 # CONFIG_SPI_DESIGNWARE is not set
 
@@ -882,6 +969,10 @@ CONFIG_SPI_PL022=y
 # PPS support
 #
 # CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
 CONFIG_ARCH_REQUIRE_GPIOLIB=y
 CONFIG_GPIOLIB=y
 # CONFIG_DEBUG_GPIO is not set
@@ -890,6 +981,7 @@ CONFIG_GPIO_SYSFS=y
 #
 # Memory mapped GPIO expanders:
 #
+# CONFIG_GPIO_BASIC_MMIO is not set
 # CONFIG_GPIO_IT8761E is not set
 # CONFIG_GPIO_PL061 is not set
 
@@ -898,8 +990,8 @@ CONFIG_GPIO_SYSFS=y
 #
 # CONFIG_GPIO_MAX7300 is not set
 # CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
 # CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
 # CONFIG_GPIO_ADP5588 is not set
 
 #
@@ -912,10 +1004,15 @@ CONFIG_GPIO_SYSFS=y
 # CONFIG_GPIO_MAX7301 is not set
 # CONFIG_GPIO_MCP23S08 is not set
 # CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
 
 #
 # AC97 GPIO expanders:
 #
+
+#
+# MODULbus GPIO expanders:
+#
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -927,6 +1024,7 @@ CONFIG_WATCHDOG=y
 # Watchdog Device Drivers
 #
 # CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
 CONFIG_PNX4008_WATCHDOG=y
 # CONFIG_MAX63XX_WATCHDOG is not set
 
@@ -940,10 +1038,7 @@ CONFIG_SSB_POSSIBLE=y
 # Sonics Silicon Backplane
 #
 # CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
+CONFIG_MFD_SUPPORT=y
 # CONFIG_MFD_CORE is not set
 # CONFIG_MFD_88PM860X is not set
 # CONFIG_MFD_SM501 is not set
@@ -951,28 +1046,39 @@ CONFIG_SSB_POSSIBLE=y
 # CONFIG_HTC_EGPIO is not set
 # CONFIG_HTC_PASIC3 is not set
 # CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
 # CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
 # CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
 # CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
 # CONFIG_MFD_TC6393XB is not set
 # CONFIG_PMIC_DA903X is not set
 # CONFIG_PMIC_ADP5520 is not set
 # CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
 # CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
 # CONFIG_MFD_WM8350_I2C is not set
 # CONFIG_MFD_WM8994 is not set
 # CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_MC13783 is not set
-# CONFIG_AB3100_CORE is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
 # CONFIG_EZX_PCAP is not set
-# CONFIG_AB4500_CORE is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_WL1273_CORE is not set
 # CONFIG_REGULATOR is not set
 # CONFIG_MEDIA_SUPPORT is not set
 
 #
 # Graphics support
 #
+# CONFIG_DRM is not set
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
@@ -988,6 +1094,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 # CONFIG_FB_SYS_IMAGEBLIT is not set
 # CONFIG_FB_FOREIGN_ENDIAN is not set
 # CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
 # CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
 # CONFIG_FB_BACKLIGHT is not set
@@ -999,6 +1106,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 #
 CONFIG_FB_ARMCLCD=y
 # CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_UDL is not set
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
 # CONFIG_FB_MB862XX is not set
@@ -1013,7 +1121,6 @@ CONFIG_FB_ARMCLCD=y
 #
 # Console display driver support
 #
-# CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
@@ -1057,7 +1164,9 @@ CONFIG_SND_USB=y
 # CONFIG_SND_USB_AUDIO is not set
 # CONFIG_SND_USB_UA101 is not set
 # CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
 CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
 CONFIG_SND_LPC3XXX_SOC=y
 CONFIG_SND_LPC3XXX_SOC_I2S_UDA1380=y
 CONFIG_SND_LPC32XX_USEI2S1=y
@@ -1084,26 +1193,42 @@ CONFIG_USB_HID=y
 #
 # CONFIG_HID_3M_PCT is not set
 # CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
 # CONFIG_HID_APPLE is not set
 # CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CANDO is not set
 # CONFIG_HID_CHERRY is not set
 # CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
 # CONFIG_HID_CYPRESS is not set
 # CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
 # CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KEYTOUCH is not set
 # CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
 # CONFIG_HID_GYRATION is not set
 # CONFIG_HID_TWINHAN is not set
 # CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
 # CONFIG_HID_LOGITECH is not set
 # CONFIG_HID_MICROSOFT is not set
 # CONFIG_HID_MOSART is not set
 # CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
 # CONFIG_HID_NTRIG is not set
 # CONFIG_HID_ORTEK is not set
 # CONFIG_HID_PANTHERLORD is not set
 # CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
 # CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
 # CONFIG_HID_SAMSUNG is not set
 # CONFIG_HID_SONY is not set
 # CONFIG_HID_STANTUM is not set
@@ -1113,6 +1238,7 @@ CONFIG_USB_HID=y
 # CONFIG_HID_TOPSEED is not set
 # CONFIG_HID_THRUSTMASTER is not set
 # CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
 CONFIG_USB_SUPPORT=y
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
@@ -1167,6 +1293,7 @@ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 #
 CONFIG_USB_STORAGE=y
 # CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
 # CONFIG_USB_STORAGE_DATAFAB is not set
 # CONFIG_USB_STORAGE_FREECOM is not set
 # CONFIG_USB_STORAGE_ISD200 is not set
@@ -1178,6 +1305,8 @@ CONFIG_USB_STORAGE=y
 # CONFIG_USB_STORAGE_ONETOUCH is not set
 # CONFIG_USB_STORAGE_KARMA is not set
 # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
 CONFIG_USB_LIBUSUAL=y
 
 #
@@ -1212,6 +1341,7 @@ CONFIG_USB_LIBUSUAL=y
 # CONFIG_USB_IOWARRIOR is not set
 # CONFIG_USB_TEST is not set
 # CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
 # CONFIG_USB_GADGET is not set
 
 #
@@ -1223,11 +1353,13 @@ CONFIG_USB_LIBUSUAL=y
 CONFIG_MMC=y
 # CONFIG_MMC_DEBUG is not set
 # CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
 
 #
 # MMC/SD/SDIO Card Drivers
 #
 CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
 # CONFIG_MMC_BLOCK_BOUNCE is not set
 # CONFIG_SDIO_UART is not set
 # CONFIG_MMC_TEST is not set
@@ -1238,6 +1370,8 @@ CONFIG_MMC_BLOCK=y
 CONFIG_MMC_ARMMMCI=y
 # CONFIG_MMC_SDHCI is not set
 # CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_USHC is not set
 # CONFIG_MEMSTICK is not set
 CONFIG_NEW_LEDS=y
 CONFIG_LEDS_CLASS=y
@@ -1245,10 +1379,13 @@ CONFIG_LEDS_CLASS=y
 #
 # LED drivers
 #
+# CONFIG_LEDS_LM3530 is not set
 CONFIG_LEDS_PCA9532=y
 CONFIG_LEDS_GPIO=y
 CONFIG_LEDS_GPIO_PLATFORM=y
 # CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
 # CONFIG_LEDS_PCA955X is not set
 # CONFIG_LEDS_DAC124S085 is not set
 # CONFIG_LEDS_BD2802 is not set
@@ -1267,6 +1404,7 @@ CONFIG_LEDS_TRIGGER_HEARTBEAT=y
 #
 # iptables trigger is under Netfilter config (LED target)
 #
+# CONFIG_NFC_DEVICES is not set
 # CONFIG_ACCESSIBILITY is not set
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
@@ -1289,9 +1427,11 @@ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
 # CONFIG_RTC_DRV_DS1307 is not set
 # CONFIG_RTC_DRV_DS1374 is not set
 # CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
 # CONFIG_RTC_DRV_MAX6900 is not set
 # CONFIG_RTC_DRV_RS5C372 is not set
 # CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
 # CONFIG_RTC_DRV_X1205 is not set
 # CONFIG_RTC_DRV_PCF8563 is not set
 # CONFIG_RTC_DRV_PCF8583 is not set
@@ -1340,11 +1480,8 @@ CONFIG_RTC_DRV_LPC32XX=y
 # CONFIG_DMADEVICES is not set
 # CONFIG_AUXDISPLAY is not set
 # CONFIG_UIO is not set
-
-#
-# TI VLYNQ
-#
 # CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
 
 #
 # File systems
@@ -1356,19 +1493,18 @@ CONFIG_EXT2_FS=y
 # CONFIG_EXT4_FS is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_GFS2_FS is not set
-# CONFIG_OCFS2_FS is not set
 # CONFIG_BTRFS_FS is not set
 # CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 CONFIG_FILE_LOCKING=y
 CONFIG_FSNOTIFY=y
 CONFIG_DNOTIFY=y
-CONFIG_INOTIFY=y
 CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
 # CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
+# CONFIG_QUOTACTL is not set
 CONFIG_AUTOFS4_FS=y
 # CONFIG_FUSE_FS is not set
 
@@ -1432,6 +1568,7 @@ CONFIG_CRAMFS=y
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
 # CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
@@ -1445,9 +1582,6 @@ CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
 # CONFIG_CEPH_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
@@ -1515,12 +1649,12 @@ CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 CONFIG_NLS_UTF8=y
-# CONFIG_DLM is not set
 
 #
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
 CONFIG_ENABLE_WARN_DEPRECATED=y
 CONFIG_ENABLE_MUST_CHECK=y
 CONFIG_FRAME_WARN=1024
@@ -1529,9 +1663,11 @@ CONFIG_FRAME_WARN=1024
 # CONFIG_UNUSED_SYMBOLS is not set
 # CONFIG_DEBUG_FS is not set
 # CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
-# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
 # CONFIG_DETECT_HUNG_TASK is not set
 # CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
@@ -1546,16 +1682,19 @@ CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_MUTEXES is not set
 # CONFIG_DEBUG_LOCK_ALLOC is not set
 # CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
 # CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_WRITECOUNT is not set
 # CONFIG_DEBUG_MEMORY_INIT is not set
 # CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
 # CONFIG_DEBUG_SG is not set
 # CONFIG_DEBUG_NOTIFIERS is not set
 # CONFIG_DEBUG_CREDENTIALS is not set
@@ -1569,16 +1708,23 @@ CONFIG_FRAME_POINTER=y
 # CONFIG_FAULT_INJECTION is not set
 # CONFIG_LATENCYTOP is not set
 # CONFIG_SYSCTL_SYSCALL_CHECK is not set
-# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
 CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_TRACING_SUPPORT=y
 # CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
 # CONFIG_SAMPLES is not set
 CONFIG_HAVE_ARCH_KGDB=y
 # CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
 # CONFIG_ARM_UNWIND is not set
 CONFIG_DEBUG_USER=y
-CONFIG_DEBUG_ERRORS=y
 # CONFIG_DEBUG_STACK_USAGE is not set
 CONFIG_DEBUG_LL=y
 CONFIG_EARLY_PRINTK=y
@@ -1589,11 +1735,9 @@ CONFIG_EARLY_PRINTK=y
 # Security options
 #
 # CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
 # CONFIG_SECURITY is not set
 # CONFIG_SECURITYFS is not set
-# CONFIG_DEFAULT_SECURITY_SELINUX is not set
-# CONFIG_DEFAULT_SECURITY_SMACK is not set
-# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
 CONFIG_DEFAULT_SECURITY_DAC=y
 CONFIG_DEFAULT_SECURITY=""
 CONFIG_CRYPTO=y
@@ -1601,7 +1745,6 @@ CONFIG_CRYPTO=y
 #
 # Crypto core or helper
 #
-# CONFIG_CRYPTO_FIPS is not set
 CONFIG_CRYPTO_ALGAPI=y
 CONFIG_CRYPTO_ALGAPI2=y
 CONFIG_CRYPTO_AEAD2=y
@@ -1610,9 +1753,10 @@ CONFIG_CRYPTO_BLKCIPHER2=y
 CONFIG_CRYPTO_HASH2=y
 CONFIG_CRYPTO_RNG=y
 CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_PCOMP2=y
 CONFIG_CRYPTO_MANAGER=y
 CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
 # CONFIG_CRYPTO_GF128MUL is not set
 # CONFIG_CRYPTO_NULL is not set
 CONFIG_CRYPTO_WORKQUEUE=y
@@ -1693,6 +1837,8 @@ CONFIG_CRYPTO_AES=y
 # Random Number Generation
 #
 CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
 # CONFIG_CRYPTO_HW is not set
 # CONFIG_BINARY_PRINTF is not set
 
@@ -1710,9 +1856,12 @@ CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
 CONFIG_DECOMPRESS_GZIP=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
 CONFIG_HAS_DMA=y
 CONFIG_NLATTR=y
 CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
diff --git a/arch/arm/configs/fdi3250_defconfig b/arch/arm/configs/fdi3250_defconfig
index a895abc..d6a288e 100644
--- a/arch/arm/configs/fdi3250_defconfig
+++ b/arch/arm/configs/fdi3250_defconfig
@@ -1,14 +1,14 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.34
+# Linux/arm 2.6.39.2 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
 CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
 CONFIG_HAVE_PROC_CPU=y
-CONFIG_GENERIC_HARDIRQS=y
 CONFIG_STACKTRACE_SUPPORT=y
 CONFIG_HAVE_LATENCYTOP_SUPPORT=y
 CONFIG_LOCKDEP_SUPPORT=y
@@ -16,27 +16,29 @@ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
 CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 CONFIG_CONSTRUCTORS=y
+CONFIG_HAVE_IRQ_WORK=y
 
 #
 # General setup
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
 CONFIG_LOCALVERSION=""
 CONFIG_LOCALVERSION_AUTO=y
 CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
 CONFIG_HAVE_KERNEL_LZO=y
 CONFIG_KERNEL_GZIP=y
-# CONFIG_KERNEL_BZIP2 is not set
 # CONFIG_KERNEL_LZMA is not set
 # CONFIG_KERNEL_LZO is not set
 CONFIG_SWAP=y
@@ -44,15 +46,26 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
 # CONFIG_TASKSTATS is not set
 # CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
 
 #
 # RCU Subsystem
 #
-CONFIG_TREE_RCU=y
-# CONFIG_TREE_PREEMPT_RCU is not set
+CONFIG_TREE_PREEMPT_RCU=y
 # CONFIG_TINY_RCU is not set
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
 # CONFIG_RCU_TRACE is not set
 CONFIG_RCU_FANOUT=32
 # CONFIG_RCU_FANOUT_EXACT is not set
@@ -61,20 +74,22 @@ CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
 CONFIG_SYSFS_DEPRECATED=y
 CONFIG_SYSFS_DEPRECATED_V2=y
 # CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_RD_GZIP=y
 # CONFIG_RD_BZIP2 is not set
 # CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
 # CONFIG_RD_LZO is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
 CONFIG_ANON_INODES=y
-CONFIG_EMBEDDED=y
+CONFIG_EXPERT=y
 CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
@@ -92,6 +107,7 @@ CONFIG_TIMERFD=y
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
 CONFIG_AIO=y
+CONFIG_EMBEDDED=y
 CONFIG_HAVE_PERF_EVENTS=y
 CONFIG_PERF_USE_VMALLOC=y
 
@@ -110,11 +126,13 @@ CONFIG_HAVE_OPROFILE=y
 # CONFIG_KPROBES is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
 
 #
 # GCOV-based kernel profiling
 #
-# CONFIG_SLOW_WORK is not set
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
@@ -175,18 +193,20 @@ CONFIG_FREEZER=y
 # System Type
 #
 CONFIG_MMU=y
-# CONFIG_ARCH_AAEC2000 is not set
 # CONFIG_ARCH_INTEGRATOR is not set
 # CONFIG_ARCH_REALVIEW is not set
 # CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
 # CONFIG_ARCH_AT91 is not set
 # CONFIG_ARCH_BCMRING is not set
 # CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
 # CONFIG_ARCH_GEMINI is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
 # CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
 # CONFIG_ARCH_STMP3XXX is not set
 # CONFIG_ARCH_NETX is not set
 # CONFIG_ARCH_H720X is not set
@@ -196,7 +216,6 @@ CONFIG_MMU=y
 # CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
 # CONFIG_ARCH_DOVE is not set
 # CONFIG_ARCH_KIRKWOOD is not set
 # CONFIG_ARCH_LOKI is not set
@@ -208,6 +227,7 @@ CONFIG_ARCH_LPC32XX=y
 # CONFIG_ARCH_NS9XXX is not set
 # CONFIG_ARCH_W90X900 is not set
 # CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_MSM is not set
@@ -216,17 +236,21 @@ CONFIG_ARCH_LPC32XX=y
 # CONFIG_ARCH_SA1100 is not set
 # CONFIG_ARCH_S3C2410 is not set
 # CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P64X0 is not set
 # CONFIG_ARCH_S5P6442 is not set
-# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_S5PC100 is not set
 # CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
 # CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_TCC_926 is not set
 # CONFIG_ARCH_U300 is not set
 # CONFIG_ARCH_U8500 is not set
 # CONFIG_ARCH_NOMADIK is not set
 # CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
 # CONFIG_MACH_PHY3250 is not set
 # CONFIG_MACH_EA3250 is not set
 CONFIG_MACH_FDI3250=y
@@ -256,6 +280,10 @@ CONFIG_ARCH_LPC32XX_HSUART1_SELECT=y
 # CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
 
 #
+# System MMU
+#
+
+#
 # Processor Type
 #
 CONFIG_CPU_ARM926T=y
@@ -267,6 +295,7 @@ CONFIG_CPU_COPY_V4WB=y
 CONFIG_CPU_TLB_V4WBI=y
 CONFIG_CPU_CP15=y
 CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
 
 #
 # Processor Features
@@ -277,7 +306,6 @@ CONFIG_ARM_THUMB=y
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
 CONFIG_ARM_L1_CACHE_SHIFT=5
-CONFIG_COMMON_CLKDEV=y
 
 #
 # Bus support
@@ -309,19 +337,24 @@ CONFIG_OABI_COMPAT=y
 # CONFIG_HIGHMEM is not set
 CONFIG_SELECT_MEMORY_MODEL=y
 CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
 CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
 # CONFIG_PHYS_ADDR_T_64BIT is not set
 CONFIG_ZONE_DMA_FLAG=0
 CONFIG_VIRT_TO_BUS=y
 # CONFIG_KSM is not set
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_FORCE_MAX_ZONEORDER=11
 CONFIG_ALIGNMENT_TRAP=y
 # CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
 
 #
 # Boot options
@@ -329,8 +362,11 @@ CONFIG_ALIGNMENT_TRAP=y
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="console=ttyTX0,115200n81 init=/sbin/init"
+# CONFIG_CMDLINE_FORCE is not set
 # CONFIG_XIP_KERNEL is not set
 # CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
 
 #
 # CPU Power Management
@@ -363,14 +399,13 @@ CONFIG_BINFMT_AOUT=y
 #
 # Power management options
 #
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
 CONFIG_SUSPEND=y
 CONFIG_SUSPEND_FREEZER=y
-# CONFIG_APM_EMULATION is not set
+CONFIG_PM_SLEEP=y
 # CONFIG_PM_RUNTIME is not set
-CONFIG_PM_OPS=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_NET=y
 
@@ -388,13 +423,12 @@ CONFIG_XFRM=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
 # CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
 # CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
@@ -415,12 +449,14 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
 # CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
 # CONFIG_NETFILTER is not set
 # CONFIG_IP_DCCP is not set
 # CONFIG_IP_SCTP is not set
 # CONFIG_RDS is not set
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
+# CONFIG_L2TP is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_NET_DSA is not set
 # CONFIG_VLAN_8021Q is not set
@@ -436,6 +472,7 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_IEEE802154 is not set
 # CONFIG_NET_SCHED is not set
 # CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
 
 #
 # Network testing
@@ -450,6 +487,8 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
 
 #
 # Device Drivers
@@ -472,7 +511,6 @@ CONFIG_EXTRA_FIRMWARE=""
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
 # CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_CONCAT is not set
 CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 CONFIG_MTD_CMDLINE_PARTS=y
@@ -490,7 +528,9 @@ CONFIG_MTD_BLOCK=y
 # CONFIG_INFTL is not set
 # CONFIG_RFD_FTL is not set
 # CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
 # CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -534,9 +574,12 @@ CONFIG_MTD_CFI_I2=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
 CONFIG_MTD_NAND=y
 # CONFIG_MTD_NAND_VERIFY_WRITE is not set
-# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
 CONFIG_MTD_NAND_MUSEUM_IDS=y
 # CONFIG_MTD_NAND_GPIO is not set
 CONFIG_MTD_NAND_IDS=y
@@ -551,10 +594,6 @@ CONFIG_MTD_NAND_PLATFORM=y
 # LPDDR flash memory drivers
 #
 # CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
 # CONFIG_MTD_UBI is not set
 # CONFIG_PARPORT is not set
 CONFIG_BLK_DEV=y
@@ -574,6 +613,8 @@ CONFIG_BLK_DEV_RAM_SIZE=16384
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
 # CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
 # CONFIG_MISC_DEVICES is not set
 CONFIG_HAVE_IDE=y
 # CONFIG_IDE is not set
@@ -610,10 +651,12 @@ CONFIG_SCSI_WAIT_SCAN=m
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
 # CONFIG_SCSI_SAS_LIBSAS is not set
 # CONFIG_SCSI_SRP_ATTRS is not set
 CONFIG_SCSI_LOWLEVEL=y
 # CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
 # CONFIG_LIBFC is not set
 # CONFIG_LIBFCOE is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -621,6 +664,7 @@ CONFIG_SCSI_LOWLEVEL=y
 # CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
 # CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -628,6 +672,7 @@ CONFIG_NETDEVICES=y
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
 # CONFIG_VETH is not set
+CONFIG_MII=y
 CONFIG_PHYLIB=y
 
 #
@@ -641,6 +686,7 @@ CONFIG_PHYLIB=y
 # CONFIG_VITESSE_PHY is not set
 CONFIG_SMSC_PHY=y
 # CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM63XX_PHY is not set
 # CONFIG_ICPLUS_PHY is not set
 # CONFIG_REALTEK_PHY is not set
 # CONFIG_NATIONAL_PHY is not set
@@ -650,7 +696,6 @@ CONFIG_SMSC_PHY=y
 # CONFIG_FIXED_PHY is not set
 # CONFIG_MDIO_BITBANG is not set
 CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
 # CONFIG_AX88796 is not set
 # CONFIG_SMC91X is not set
 # CONFIG_DM9000 is not set
@@ -667,10 +712,10 @@ CONFIG_MII=y
 # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
 # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
 # CONFIG_B44 is not set
-# CONFIG_KS8842 is not set
 # CONFIG_KS8851 is not set
 # CONFIG_KS8851_MLL is not set
 CONFIG_LPC_ENET=y
+# CONFIG_FTMAC100 is not set
 # CONFIG_NETDEV_1000 is not set
 # CONFIG_NETDEV_10000 is not set
 # CONFIG_WLAN is not set
@@ -689,6 +734,10 @@ CONFIG_LPC_ENET=y
 # CONFIG_USB_USBNET is not set
 # CONFIG_USB_IPHETH is not set
 # CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
 # CONFIG_NETCONSOLE is not set
@@ -726,10 +775,12 @@ CONFIG_INPUT_EVDEV=y
 CONFIG_INPUT_TOUCHSCREEN=y
 # CONFIG_TOUCHSCREEN_ADS7846 is not set
 # CONFIG_TOUCHSCREEN_AD7877 is not set
-# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
-# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
 # CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
 # CONFIG_TOUCHSCREEN_EETI is not set
 # CONFIG_TOUCHSCREEN_FUJITSU is not set
 # CONFIG_TOUCHSCREEN_GUNZE is not set
@@ -745,7 +796,11 @@ CONFIG_TOUCHSCREEN_LPC32XX=y
 # CONFIG_TOUCHSCREEN_TOUCHWIN is not set
 # CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
 # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
 # CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
 # CONFIG_INPUT_MISC is not set
 
 #
@@ -762,8 +817,12 @@ CONFIG_CONSOLE_TRANSLATIONS=y
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
 # CONFIG_VT_HW_CONSOLE_BINDING is not set
-CONFIG_DEVKMEM=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+CONFIG_DEVKMEM=y
 
 #
 # Serial drivers
@@ -780,23 +839,28 @@ CONFIG_SERIAL_8250_RUNTIME_UARTS=4
 # CONFIG_SERIAL_AMBA_PL010 is not set
 # CONFIG_SERIAL_AMBA_PL011 is not set
 # CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
 CONFIG_SERIAL_HS_LPC32XX=y
 CONFIG_SERIAL_HS_LPC32XX_CONSOLE=y
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_SERIAL_TIMBERDALE is not set
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
 # CONFIG_IPMI_HANDLER is not set
 # CONFIG_HW_RANDOM is not set
 # CONFIG_R3964 is not set
 # CONFIG_RAW_DRIVER is not set
 # CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
 # CONFIG_I2C_COMPAT is not set
 CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
 CONFIG_I2C_HELPER_AUTO=y
 
 #
@@ -806,15 +870,19 @@ CONFIG_I2C_HELPER_AUTO=y
 #
 # I2C system bus drivers (mostly embedded / system-on-chip)
 #
+# CONFIG_I2C_DESIGNWARE is not set
 # CONFIG_I2C_GPIO is not set
 # CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
 CONFIG_I2C_PNX=y
+# CONFIG_I2C_PXA_PCI is not set
 # CONFIG_I2C_SIMTEC is not set
 # CONFIG_I2C_XILINX is not set
 
 #
 # External I2C/SMBus adapter drivers
 #
+# CONFIG_I2C_DIOLAN_U2C is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_TAOS_EVM is not set
 # CONFIG_I2C_TINY_USB is not set
@@ -822,7 +890,6 @@ CONFIG_I2C_PNX=y
 #
 # Other I2C/SMBus bus drivers
 #
-# CONFIG_I2C_PCA_PLATFORM is not set
 # CONFIG_I2C_STUB is not set
 # CONFIG_I2C_DEBUG_CORE is not set
 # CONFIG_I2C_DEBUG_ALGO is not set
@@ -834,9 +901,12 @@ CONFIG_SPI_MASTER=y
 #
 # SPI Master Controller Drivers
 #
+# CONFIG_SPI_ALTERA is not set
 # CONFIG_SPI_BITBANG is not set
 # CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
 CONFIG_SPI_PL022=y
+# CONFIG_SPI_PXA2XX_PCI is not set
 # CONFIG_SPI_XILINX is not set
 # CONFIG_SPI_DESIGNWARE is not set
 
@@ -850,6 +920,10 @@ CONFIG_SPI_SPIDEV=y
 # PPS support
 #
 # CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
 CONFIG_ARCH_REQUIRE_GPIOLIB=y
 CONFIG_GPIOLIB=y
 # CONFIG_DEBUG_GPIO is not set
@@ -858,6 +932,7 @@ CONFIG_GPIO_SYSFS=y
 #
 # Memory mapped GPIO expanders:
 #
+# CONFIG_GPIO_BASIC_MMIO is not set
 # CONFIG_GPIO_IT8761E is not set
 # CONFIG_GPIO_PL061 is not set
 
@@ -866,8 +941,8 @@ CONFIG_GPIO_SYSFS=y
 #
 # CONFIG_GPIO_MAX7300 is not set
 # CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
 # CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
 # CONFIG_GPIO_ADP5588 is not set
 
 #
@@ -880,10 +955,15 @@ CONFIG_GPIO_SYSFS=y
 # CONFIG_GPIO_MAX7301 is not set
 # CONFIG_GPIO_MCP23S08 is not set
 # CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
 
 #
 # AC97 GPIO expanders:
 #
+
+#
+# MODULbus GPIO expanders:
+#
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -895,6 +975,7 @@ CONFIG_WATCHDOG=y
 # Watchdog Device Drivers
 #
 # CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
 CONFIG_PNX4008_WATCHDOG=y
 # CONFIG_MAX63XX_WATCHDOG is not set
 
@@ -908,10 +989,7 @@ CONFIG_SSB_POSSIBLE=y
 # Sonics Silicon Backplane
 #
 # CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
+CONFIG_MFD_SUPPORT=y
 # CONFIG_MFD_CORE is not set
 # CONFIG_MFD_88PM860X is not set
 # CONFIG_MFD_SM501 is not set
@@ -919,28 +997,39 @@ CONFIG_SSB_POSSIBLE=y
 # CONFIG_HTC_EGPIO is not set
 # CONFIG_HTC_PASIC3 is not set
 # CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
 # CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
 # CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
 # CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
 # CONFIG_MFD_TC6393XB is not set
 # CONFIG_PMIC_DA903X is not set
 # CONFIG_PMIC_ADP5520 is not set
 # CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
 # CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
 # CONFIG_MFD_WM8350_I2C is not set
 # CONFIG_MFD_WM8994 is not set
 # CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_MC13783 is not set
-# CONFIG_AB3100_CORE is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
 # CONFIG_EZX_PCAP is not set
-# CONFIG_AB4500_CORE is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_WL1273_CORE is not set
 # CONFIG_REGULATOR is not set
 # CONFIG_MEDIA_SUPPORT is not set
 
 #
 # Graphics support
 #
+# CONFIG_DRM is not set
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
@@ -956,6 +1045,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 # CONFIG_FB_SYS_IMAGEBLIT is not set
 # CONFIG_FB_FOREIGN_ENDIAN is not set
 # CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
 # CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
 # CONFIG_FB_BACKLIGHT is not set
@@ -967,6 +1057,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 #
 CONFIG_FB_ARMCLCD=y
 # CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_UDL is not set
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
 # CONFIG_FB_MB862XX is not set
@@ -981,7 +1072,6 @@ CONFIG_FB_ARMCLCD=y
 #
 # Console display driver support
 #
-# CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
@@ -1010,26 +1100,41 @@ CONFIG_USB_HID=y
 #
 # CONFIG_HID_3M_PCT is not set
 # CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
 # CONFIG_HID_APPLE is not set
 # CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CANDO is not set
 # CONFIG_HID_CHERRY is not set
 # CONFIG_HID_CHICONY is not set
 # CONFIG_HID_CYPRESS is not set
 # CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
 # CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KEYTOUCH is not set
 # CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
 # CONFIG_HID_GYRATION is not set
 # CONFIG_HID_TWINHAN is not set
 # CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
 # CONFIG_HID_LOGITECH is not set
 # CONFIG_HID_MICROSOFT is not set
 # CONFIG_HID_MOSART is not set
 # CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
 # CONFIG_HID_NTRIG is not set
 # CONFIG_HID_ORTEK is not set
 # CONFIG_HID_PANTHERLORD is not set
 # CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
 # CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
 # CONFIG_HID_SAMSUNG is not set
 # CONFIG_HID_SONY is not set
 # CONFIG_HID_STANTUM is not set
@@ -1039,6 +1144,7 @@ CONFIG_USB_HID=y
 # CONFIG_HID_TOPSEED is not set
 # CONFIG_HID_THRUSTMASTER is not set
 # CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
 CONFIG_USB_SUPPORT=y
 CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB_ARCH_HAS_OHCI=y
@@ -1093,6 +1199,7 @@ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 #
 CONFIG_USB_STORAGE=y
 CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_REALTEK is not set
 # CONFIG_USB_STORAGE_DATAFAB is not set
 # CONFIG_USB_STORAGE_FREECOM is not set
 # CONFIG_USB_STORAGE_ISD200 is not set
@@ -1104,6 +1211,8 @@ CONFIG_USB_STORAGE_DEBUG=y
 # CONFIG_USB_STORAGE_ONETOUCH is not set
 # CONFIG_USB_STORAGE_KARMA is not set
 # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
 # CONFIG_USB_LIBUSUAL is not set
 
 #
@@ -1138,6 +1247,7 @@ CONFIG_USB_STORAGE_DEBUG=y
 # CONFIG_USB_IOWARRIOR is not set
 # CONFIG_USB_TEST is not set
 # CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
 # CONFIG_USB_GADGET is not set
 
 #
@@ -1154,9 +1264,12 @@ CONFIG_LEDS_CLASS=y
 #
 # LED drivers
 #
+# CONFIG_LEDS_LM3530 is not set
 # CONFIG_LEDS_PCA9532 is not set
 # CONFIG_LEDS_GPIO is not set
 # CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
 # CONFIG_LEDS_PCA955X is not set
 # CONFIG_LEDS_DAC124S085 is not set
 # CONFIG_LEDS_BD2802 is not set
@@ -1175,6 +1288,7 @@ CONFIG_LEDS_TRIGGER_HEARTBEAT=y
 #
 # iptables trigger is under Netfilter config (LED target)
 #
+# CONFIG_NFC_DEVICES is not set
 # CONFIG_ACCESSIBILITY is not set
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
@@ -1197,9 +1311,11 @@ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
 # CONFIG_RTC_DRV_DS1307 is not set
 # CONFIG_RTC_DRV_DS1374 is not set
 # CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
 # CONFIG_RTC_DRV_MAX6900 is not set
 # CONFIG_RTC_DRV_RS5C372 is not set
 # CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
 # CONFIG_RTC_DRV_X1205 is not set
 # CONFIG_RTC_DRV_PCF8563 is not set
 # CONFIG_RTC_DRV_PCF8583 is not set
@@ -1248,11 +1364,8 @@ CONFIG_RTC_DRV_LPC32XX=y
 # CONFIG_DMADEVICES is not set
 # CONFIG_AUXDISPLAY is not set
 # CONFIG_UIO is not set
-
-#
-# TI VLYNQ
-#
 # CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
 
 #
 # File systems
@@ -1267,19 +1380,18 @@ CONFIG_EXT2_FS_XATTR=y
 CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_GFS2_FS is not set
-# CONFIG_OCFS2_FS is not set
 # CONFIG_BTRFS_FS is not set
 # CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 CONFIG_FILE_LOCKING=y
 CONFIG_FSNOTIFY=y
 CONFIG_DNOTIFY=y
-CONFIG_INOTIFY=y
 CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
 # CONFIG_QUOTA is not set
-CONFIG_AUTOFS_FS=y
+# CONFIG_QUOTACTL is not set
 # CONFIG_AUTOFS4_FS is not set
 # CONFIG_FUSE_FS is not set
 
@@ -1343,6 +1455,7 @@ CONFIG_CRAMFS=y
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
 # CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
@@ -1356,9 +1469,6 @@ CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
 # CONFIG_CEPH_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
@@ -1426,12 +1536,12 @@ CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 CONFIG_NLS_UTF8=m
-# CONFIG_DLM is not set
 
 #
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
 CONFIG_ENABLE_WARN_DEPRECATED=y
 CONFIG_ENABLE_MUST_CHECK=y
 CONFIG_FRAME_WARN=1024
@@ -1440,9 +1550,11 @@ CONFIG_FRAME_WARN=1024
 # CONFIG_UNUSED_SYMBOLS is not set
 # CONFIG_DEBUG_FS is not set
 # CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
-# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
 # CONFIG_DETECT_HUNG_TASK is not set
 # CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
@@ -1457,16 +1569,19 @@ CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_MUTEXES is not set
 # CONFIG_DEBUG_LOCK_ALLOC is not set
 # CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
 # CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_WRITECOUNT is not set
 # CONFIG_DEBUG_MEMORY_INIT is not set
 # CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
 # CONFIG_DEBUG_SG is not set
 # CONFIG_DEBUG_NOTIFIERS is not set
 # CONFIG_DEBUG_CREDENTIALS is not set
@@ -1480,16 +1595,23 @@ CONFIG_FRAME_POINTER=y
 # CONFIG_FAULT_INJECTION is not set
 # CONFIG_LATENCYTOP is not set
 # CONFIG_SYSCTL_SYSCALL_CHECK is not set
-# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
 CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_TRACING_SUPPORT=y
 # CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
 # CONFIG_SAMPLES is not set
 CONFIG_HAVE_ARCH_KGDB=y
 # CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
 # CONFIG_ARM_UNWIND is not set
 CONFIG_DEBUG_USER=y
-CONFIG_DEBUG_ERRORS=y
 # CONFIG_DEBUG_STACK_USAGE is not set
 CONFIG_DEBUG_LL=y
 # CONFIG_EARLY_PRINTK is not set
@@ -1500,11 +1622,9 @@ CONFIG_DEBUG_LL=y
 # Security options
 #
 # CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
 # CONFIG_SECURITY is not set
 # CONFIG_SECURITYFS is not set
-# CONFIG_DEFAULT_SECURITY_SELINUX is not set
-# CONFIG_DEFAULT_SECURITY_SMACK is not set
-# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
 CONFIG_DEFAULT_SECURITY_DAC=y
 CONFIG_DEFAULT_SECURITY=""
 CONFIG_CRYPTO=y
@@ -1598,6 +1718,8 @@ CONFIG_CRYPTO_AES=m
 # Random Number Generation
 #
 CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
 # CONFIG_CRYPTO_HW is not set
 # CONFIG_BINARY_PRINTF is not set
 
@@ -1615,9 +1737,12 @@ CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
 CONFIG_DECOMPRESS_GZIP=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
 CONFIG_HAS_DMA=y
 CONFIG_NLATTR=y
 CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
diff --git a/arch/arm/configs/phy3250_defconfig b/arch/arm/configs/phy3250_defconfig
index b87b75e..0c80560 100644
--- a/arch/arm/configs/phy3250_defconfig
+++ b/arch/arm/configs/phy3250_defconfig
@@ -1,14 +1,14 @@
 #
 # Automatically generated make config: don't edit
-# Linux kernel version: 2.6.34
+# Linux/arm 2.6.39.2 Kernel Configuration
 #
 CONFIG_ARM=y
 CONFIG_SYS_SUPPORTS_APM_EMULATION=y
 CONFIG_GENERIC_GPIO=y
-CONFIG_GENERIC_TIME=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
 CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
 CONFIG_HAVE_PROC_CPU=y
-CONFIG_GENERIC_HARDIRQS=y
 CONFIG_STACKTRACE_SUPPORT=y
 CONFIG_HAVE_LATENCYTOP_SUPPORT=y
 CONFIG_LOCKDEP_SUPPORT=y
@@ -16,27 +16,29 @@ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
 CONFIG_HARDIRQS_SW_RESEND=y
 CONFIG_GENERIC_IRQ_PROBE=y
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
 CONFIG_GENERIC_HWEIGHT=y
 CONFIG_GENERIC_CALIBRATE_DELAY=y
 CONFIG_NEED_DMA_MAP_STATE=y
-CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
 CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
 CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
 CONFIG_CONSTRUCTORS=y
+CONFIG_HAVE_IRQ_WORK=y
 
 #
 # General setup
 #
 CONFIG_EXPERIMENTAL=y
 CONFIG_BROKEN_ON_SMP=y
-CONFIG_LOCK_KERNEL=y
 CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
 CONFIG_LOCALVERSION=""
 CONFIG_LOCALVERSION_AUTO=y
 CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
 CONFIG_HAVE_KERNEL_LZO=y
 CONFIG_KERNEL_GZIP=y
-# CONFIG_KERNEL_BZIP2 is not set
 # CONFIG_KERNEL_LZMA is not set
 # CONFIG_KERNEL_LZO is not set
 CONFIG_SWAP=y
@@ -44,15 +46,26 @@ CONFIG_SYSVIPC=y
 CONFIG_SYSVIPC_SYSCTL=y
 # CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
 # CONFIG_TASKSTATS is not set
 # CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
 
 #
 # RCU Subsystem
 #
-CONFIG_TREE_RCU=y
-# CONFIG_TREE_PREEMPT_RCU is not set
+CONFIG_TREE_PREEMPT_RCU=y
 # CONFIG_TINY_RCU is not set
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
 # CONFIG_RCU_TRACE is not set
 CONFIG_RCU_FANOUT=32
 # CONFIG_RCU_FANOUT_EXACT is not set
@@ -61,20 +74,22 @@ CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
 CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
 CONFIG_SYSFS_DEPRECATED=y
 CONFIG_SYSFS_DEPRECATED_V2=y
 # CONFIG_RELAY is not set
-# CONFIG_NAMESPACES is not set
 CONFIG_BLK_DEV_INITRD=y
 CONFIG_INITRAMFS_SOURCE=""
 CONFIG_RD_GZIP=y
 # CONFIG_RD_BZIP2 is not set
 # CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
 # CONFIG_RD_LZO is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
 CONFIG_SYSCTL=y
 CONFIG_ANON_INODES=y
-CONFIG_EMBEDDED=y
+CONFIG_EXPERT=y
 CONFIG_UID16=y
 CONFIG_SYSCTL_SYSCALL=y
 CONFIG_KALLSYMS=y
@@ -92,6 +107,7 @@ CONFIG_TIMERFD=y
 CONFIG_EVENTFD=y
 CONFIG_SHMEM=y
 CONFIG_AIO=y
+CONFIG_EMBEDDED=y
 CONFIG_HAVE_PERF_EVENTS=y
 CONFIG_PERF_USE_VMALLOC=y
 
@@ -110,11 +126,13 @@ CONFIG_HAVE_OPROFILE=y
 # CONFIG_KPROBES is not set
 CONFIG_HAVE_KPROBES=y
 CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
 
 #
 # GCOV-based kernel profiling
 #
-# CONFIG_SLOW_WORK is not set
 CONFIG_HAVE_GENERIC_DMA_COHERENT=y
 CONFIG_SLABINFO=y
 CONFIG_RT_MUTEXES=y
@@ -175,18 +193,20 @@ CONFIG_FREEZER=y
 # System Type
 #
 CONFIG_MMU=y
-# CONFIG_ARCH_AAEC2000 is not set
 # CONFIG_ARCH_INTEGRATOR is not set
 # CONFIG_ARCH_REALVIEW is not set
 # CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
 # CONFIG_ARCH_AT91 is not set
 # CONFIG_ARCH_BCMRING is not set
 # CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
 # CONFIG_ARCH_GEMINI is not set
 # CONFIG_ARCH_EBSA110 is not set
 # CONFIG_ARCH_EP93XX is not set
 # CONFIG_ARCH_FOOTBRIDGE is not set
 # CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
 # CONFIG_ARCH_STMP3XXX is not set
 # CONFIG_ARCH_NETX is not set
 # CONFIG_ARCH_H720X is not set
@@ -196,7 +216,6 @@ CONFIG_MMU=y
 # CONFIG_ARCH_IXP23XX is not set
 # CONFIG_ARCH_IXP2000 is not set
 # CONFIG_ARCH_IXP4XX is not set
-# CONFIG_ARCH_L7200 is not set
 # CONFIG_ARCH_DOVE is not set
 # CONFIG_ARCH_KIRKWOOD is not set
 # CONFIG_ARCH_LOKI is not set
@@ -208,6 +227,7 @@ CONFIG_ARCH_LPC32XX=y
 # CONFIG_ARCH_NS9XXX is not set
 # CONFIG_ARCH_W90X900 is not set
 # CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
 # CONFIG_ARCH_PNX4008 is not set
 # CONFIG_ARCH_PXA is not set
 # CONFIG_ARCH_MSM is not set
@@ -216,17 +236,22 @@ CONFIG_ARCH_LPC32XX=y
 # CONFIG_ARCH_SA1100 is not set
 # CONFIG_ARCH_S3C2410 is not set
 # CONFIG_ARCH_S3C64XX is not set
-# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P64X0 is not set
 # CONFIG_ARCH_S5P6442 is not set
-# CONFIG_ARCH_S5PC1XX is not set
+# CONFIG_ARCH_S5PC100 is not set
 # CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
 # CONFIG_ARCH_SHARK is not set
-# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_TCC_926 is not set
 # CONFIG_ARCH_U300 is not set
 # CONFIG_ARCH_U8500 is not set
 # CONFIG_ARCH_NOMADIK is not set
 # CONFIG_ARCH_DAVINCI is not set
 # CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
 CONFIG_MACH_PHY3250=y
 # CONFIG_MACH_EA3250 is not set
 # CONFIG_MACH_FDI3250 is not set
@@ -253,6 +278,10 @@ CONFIG_ARCH_LPC32XX_UART5_SELECT=y
 # CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
 
 #
+# System MMU
+#
+
+#
 # Processor Type
 #
 CONFIG_CPU_ARM926T=y
@@ -264,6 +293,7 @@ CONFIG_CPU_COPY_V4WB=y
 CONFIG_CPU_TLB_V4WBI=y
 CONFIG_CPU_CP15=y
 CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
 
 #
 # Processor Features
@@ -274,7 +304,6 @@ CONFIG_ARM_THUMB=y
 # CONFIG_CPU_DCACHE_WRITETHROUGH is not set
 # CONFIG_CPU_CACHE_ROUND_ROBIN is not set
 CONFIG_ARM_L1_CACHE_SHIFT=5
-CONFIG_COMMON_CLKDEV=y
 
 #
 # Bus support
@@ -306,19 +335,24 @@ CONFIG_OABI_COMPAT=y
 # CONFIG_HIGHMEM is not set
 CONFIG_SELECT_MEMORY_MODEL=y
 CONFIG_FLATMEM_MANUAL=y
-# CONFIG_DISCONTIGMEM_MANUAL is not set
-# CONFIG_SPARSEMEM_MANUAL is not set
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
 CONFIG_PAGEFLAGS_EXTENDED=y
 CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
 # CONFIG_PHYS_ADDR_T_64BIT is not set
 CONFIG_ZONE_DMA_FLAG=0
 CONFIG_VIRT_TO_BUS=y
 # CONFIG_KSM is not set
 CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_FORCE_MAX_ZONEORDER=11
 CONFIG_ALIGNMENT_TRAP=y
 # CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
 
 #
 # Boot options
@@ -326,8 +360,11 @@ CONFIG_ALIGNMENT_TRAP=y
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_CMDLINE="console=ttyS0,115200n81 root=/dev/ram0"
+# CONFIG_CMDLINE_FORCE is not set
 # CONFIG_XIP_KERNEL is not set
 # CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
 
 #
 # CPU Power Management
@@ -360,14 +397,13 @@ CONFIG_BINFMT_AOUT=y
 #
 # Power management options
 #
-CONFIG_PM=y
-# CONFIG_PM_DEBUG is not set
-CONFIG_PM_SLEEP=y
 CONFIG_SUSPEND=y
 CONFIG_SUSPEND_FREEZER=y
-# CONFIG_APM_EMULATION is not set
+CONFIG_PM_SLEEP=y
 # CONFIG_PM_RUNTIME is not set
-CONFIG_PM_OPS=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
 CONFIG_ARCH_SUSPEND_POSSIBLE=y
 CONFIG_NET=y
 
@@ -380,13 +416,12 @@ CONFIG_UNIX=y
 CONFIG_INET=y
 CONFIG_IP_MULTICAST=y
 # CONFIG_IP_ADVANCED_ROUTER is not set
-CONFIG_IP_FIB_HASH=y
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
 CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
 # CONFIG_NET_IPIP is not set
-# CONFIG_NET_IPGRE is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
 # CONFIG_IP_MROUTE is not set
 # CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
@@ -406,12 +441,14 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_TCP_MD5SIG is not set
 # CONFIG_IPV6 is not set
 # CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
 # CONFIG_NETFILTER is not set
 # CONFIG_IP_DCCP is not set
 # CONFIG_IP_SCTP is not set
 # CONFIG_RDS is not set
 # CONFIG_TIPC is not set
 # CONFIG_ATM is not set
+# CONFIG_L2TP is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_NET_DSA is not set
 # CONFIG_VLAN_8021Q is not set
@@ -427,6 +464,7 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_IEEE802154 is not set
 # CONFIG_NET_SCHED is not set
 # CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
 
 #
 # Network testing
@@ -441,6 +479,8 @@ CONFIG_DEFAULT_TCP_CONG="cubic"
 # CONFIG_WIMAX is not set
 # CONFIG_RFKILL is not set
 # CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
 
 #
 # Device Drivers
@@ -461,7 +501,6 @@ CONFIG_PREVENT_FIRMWARE_BUILD=y
 CONFIG_MTD=y
 # CONFIG_MTD_DEBUG is not set
 # CONFIG_MTD_TESTS is not set
-# CONFIG_MTD_CONCAT is not set
 CONFIG_MTD_PARTITIONS=y
 # CONFIG_MTD_REDBOOT_PARTS is not set
 CONFIG_MTD_CMDLINE_PARTS=y
@@ -479,7 +518,9 @@ CONFIG_MTD_BLOCK=y
 # CONFIG_INFTL is not set
 # CONFIG_RFD_FTL is not set
 # CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
 # CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
 
 #
 # RAM/ROM/Flash chip drivers
@@ -523,9 +564,12 @@ CONFIG_MTD_CFI_I2=y
 # CONFIG_MTD_DOC2000 is not set
 # CONFIG_MTD_DOC2001 is not set
 # CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
 CONFIG_MTD_NAND=y
 # CONFIG_MTD_NAND_VERIFY_WRITE is not set
-# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
 CONFIG_MTD_NAND_MUSEUM_IDS=y
 # CONFIG_MTD_NAND_GPIO is not set
 CONFIG_MTD_NAND_IDS=y
@@ -540,10 +584,6 @@ CONFIG_MTD_NAND_SLC_LPC32XX=y
 # LPDDR flash memory drivers
 #
 # CONFIG_MTD_LPDDR is not set
-
-#
-# UBI - Unsorted block images
-#
 # CONFIG_MTD_UBI is not set
 # CONFIG_PARPORT is not set
 CONFIG_BLK_DEV=y
@@ -563,14 +603,23 @@ CONFIG_BLK_DEV_RAM_SIZE=16384
 # CONFIG_CDROM_PKTCDVD is not set
 # CONFIG_ATA_OVER_ETH is not set
 # CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
 CONFIG_MISC_DEVICES=y
 # CONFIG_AD525X_DPOT is not set
 # CONFIG_ICS932S401 is not set
 # CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
 # CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
 # CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
 # CONFIG_DS1682 is not set
 # CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
 # CONFIG_C2PORT is not set
 
 #
@@ -582,6 +631,12 @@ CONFIG_EEPROM_AT25=y
 # CONFIG_EEPROM_MAX6875 is not set
 # CONFIG_EEPROM_93CX6 is not set
 # CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
 CONFIG_HAVE_IDE=y
 # CONFIG_IDE is not set
 
@@ -617,10 +672,12 @@ CONFIG_SCSI_WAIT_SCAN=m
 # CONFIG_SCSI_SPI_ATTRS is not set
 # CONFIG_SCSI_FC_ATTRS is not set
 # CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
 # CONFIG_SCSI_SAS_LIBSAS is not set
 # CONFIG_SCSI_SRP_ATTRS is not set
 CONFIG_SCSI_LOWLEVEL=y
 # CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
 # CONFIG_LIBFC is not set
 # CONFIG_LIBFCOE is not set
 # CONFIG_SCSI_DEBUG is not set
@@ -628,6 +685,7 @@ CONFIG_SCSI_LOWLEVEL=y
 # CONFIG_SCSI_OSD_INITIATOR is not set
 # CONFIG_ATA is not set
 # CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
 CONFIG_NETDEVICES=y
 # CONFIG_DUMMY is not set
 # CONFIG_BONDING is not set
@@ -635,6 +693,7 @@ CONFIG_NETDEVICES=y
 # CONFIG_EQUALIZER is not set
 # CONFIG_TUN is not set
 # CONFIG_VETH is not set
+CONFIG_MII=y
 CONFIG_PHYLIB=y
 
 #
@@ -648,6 +707,7 @@ CONFIG_PHYLIB=y
 # CONFIG_VITESSE_PHY is not set
 CONFIG_SMSC_PHY=y
 # CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM63XX_PHY is not set
 # CONFIG_ICPLUS_PHY is not set
 # CONFIG_REALTEK_PHY is not set
 # CONFIG_NATIONAL_PHY is not set
@@ -657,7 +717,6 @@ CONFIG_SMSC_PHY=y
 # CONFIG_FIXED_PHY is not set
 # CONFIG_MDIO_BITBANG is not set
 CONFIG_NET_ETHERNET=y
-CONFIG_MII=y
 # CONFIG_AX88796 is not set
 # CONFIG_SMC91X is not set
 # CONFIG_DM9000 is not set
@@ -674,10 +733,10 @@ CONFIG_MII=y
 # CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
 # CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
 # CONFIG_B44 is not set
-# CONFIG_KS8842 is not set
 # CONFIG_KS8851 is not set
 # CONFIG_KS8851_MLL is not set
 CONFIG_LPC_ENET=y
+# CONFIG_FTMAC100 is not set
 # CONFIG_NETDEV_1000 is not set
 # CONFIG_NETDEV_10000 is not set
 # CONFIG_WLAN is not set
@@ -696,6 +755,10 @@ CONFIG_LPC_ENET=y
 # CONFIG_USB_USBNET is not set
 # CONFIG_USB_IPHETH is not set
 # CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
 # CONFIG_NETCONSOLE is not set
@@ -729,13 +792,16 @@ CONFIG_INPUT_EVDEV=y
 CONFIG_INPUT_KEYBOARD=y
 # CONFIG_KEYBOARD_ADP5588 is not set
 CONFIG_KEYBOARD_ATKBD=y
-# CONFIG_QT2160 is not set
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
 # CONFIG_KEYBOARD_LKKBD is not set
 # CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
 # CONFIG_KEYBOARD_MATRIX is not set
 # CONFIG_KEYBOARD_LM8323 is not set
 # CONFIG_KEYBOARD_LPC32XX is not set
 # CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
 # CONFIG_KEYBOARD_NEWTON is not set
 # CONFIG_KEYBOARD_OPENCORES is not set
 # CONFIG_KEYBOARD_STOWAWAY is not set
@@ -747,10 +813,12 @@ CONFIG_KEYBOARD_ATKBD=y
 CONFIG_INPUT_TOUCHSCREEN=y
 # CONFIG_TOUCHSCREEN_ADS7846 is not set
 # CONFIG_TOUCHSCREEN_AD7877 is not set
-# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
-# CONFIG_TOUCHSCREEN_AD7879_SPI is not set
 # CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
 # CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
 # CONFIG_TOUCHSCREEN_EETI is not set
 # CONFIG_TOUCHSCREEN_FUJITSU is not set
 # CONFIG_TOUCHSCREEN_GUNZE is not set
@@ -766,7 +834,11 @@ CONFIG_TOUCHSCREEN_LPC32XX=y
 # CONFIG_TOUCHSCREEN_TOUCHWIN is not set
 # CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
 # CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
 # CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
 # CONFIG_INPUT_MISC is not set
 
 #
@@ -778,6 +850,7 @@ CONFIG_SERIO_SERPORT=y
 CONFIG_SERIO_LIBPS2=y
 # CONFIG_SERIO_RAW is not set
 # CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
 # CONFIG_GAMEPORT is not set
 
 #
@@ -788,8 +861,12 @@ CONFIG_CONSOLE_TRANSLATIONS=y
 CONFIG_VT_CONSOLE=y
 CONFIG_HW_CONSOLE=y
 # CONFIG_VT_HW_CONSOLE_BINDING is not set
-CONFIG_DEVKMEM=y
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
 # CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+CONFIG_DEVKMEM=y
 
 #
 # Serial drivers
@@ -806,22 +883,27 @@ CONFIG_SERIAL_8250_RUNTIME_UARTS=4
 # CONFIG_SERIAL_AMBA_PL010 is not set
 # CONFIG_SERIAL_AMBA_PL011 is not set
 # CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
 # CONFIG_SERIAL_HS_LPC32XX is not set
 CONFIG_SERIAL_CORE=y
 CONFIG_SERIAL_CORE_CONSOLE=y
 # CONFIG_SERIAL_TIMBERDALE is not set
-CONFIG_UNIX98_PTYS=y
-# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
-# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
 # CONFIG_IPMI_HANDLER is not set
 # CONFIG_HW_RANDOM is not set
 # CONFIG_R3964 is not set
 # CONFIG_RAW_DRIVER is not set
 # CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
 CONFIG_I2C=y
 CONFIG_I2C_BOARDINFO=y
 CONFIG_I2C_COMPAT=y
 CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
 CONFIG_I2C_HELPER_AUTO=y
 
 #
@@ -831,15 +913,19 @@ CONFIG_I2C_HELPER_AUTO=y
 #
 # I2C system bus drivers (mostly embedded / system-on-chip)
 #
+# CONFIG_I2C_DESIGNWARE is not set
 # CONFIG_I2C_GPIO is not set
 # CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
 CONFIG_I2C_PNX=y
+# CONFIG_I2C_PXA_PCI is not set
 # CONFIG_I2C_SIMTEC is not set
 # CONFIG_I2C_XILINX is not set
 
 #
 # External I2C/SMBus adapter drivers
 #
+# CONFIG_I2C_DIOLAN_U2C is not set
 # CONFIG_I2C_PARPORT_LIGHT is not set
 # CONFIG_I2C_TAOS_EVM is not set
 # CONFIG_I2C_TINY_USB is not set
@@ -847,7 +933,6 @@ CONFIG_I2C_PNX=y
 #
 # Other I2C/SMBus bus drivers
 #
-# CONFIG_I2C_PCA_PLATFORM is not set
 # CONFIG_I2C_STUB is not set
 # CONFIG_I2C_DEBUG_CORE is not set
 # CONFIG_I2C_DEBUG_ALGO is not set
@@ -859,9 +944,12 @@ CONFIG_SPI_MASTER=y
 #
 # SPI Master Controller Drivers
 #
+# CONFIG_SPI_ALTERA is not set
 # CONFIG_SPI_BITBANG is not set
 # CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
 CONFIG_SPI_PL022=y
+# CONFIG_SPI_PXA2XX_PCI is not set
 # CONFIG_SPI_XILINX is not set
 # CONFIG_SPI_DESIGNWARE is not set
 
@@ -875,6 +963,10 @@ CONFIG_SPI_PL022=y
 # PPS support
 #
 # CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
 CONFIG_ARCH_REQUIRE_GPIOLIB=y
 CONFIG_GPIOLIB=y
 # CONFIG_DEBUG_GPIO is not set
@@ -883,6 +975,7 @@ CONFIG_GPIO_SYSFS=y
 #
 # Memory mapped GPIO expanders:
 #
+# CONFIG_GPIO_BASIC_MMIO is not set
 # CONFIG_GPIO_IT8761E is not set
 # CONFIG_GPIO_PL061 is not set
 
@@ -891,8 +984,8 @@ CONFIG_GPIO_SYSFS=y
 #
 # CONFIG_GPIO_MAX7300 is not set
 # CONFIG_GPIO_MAX732X is not set
-# CONFIG_GPIO_PCA953X is not set
 # CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
 # CONFIG_GPIO_ADP5588 is not set
 
 #
@@ -905,10 +998,15 @@ CONFIG_GPIO_SYSFS=y
 # CONFIG_GPIO_MAX7301 is not set
 # CONFIG_GPIO_MCP23S08 is not set
 # CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
 
 #
 # AC97 GPIO expanders:
 #
+
+#
+# MODULbus GPIO expanders:
+#
 # CONFIG_W1 is not set
 # CONFIG_POWER_SUPPLY is not set
 # CONFIG_HWMON is not set
@@ -920,6 +1018,7 @@ CONFIG_WATCHDOG=y
 # Watchdog Device Drivers
 #
 # CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
 CONFIG_PNX4008_WATCHDOG=y
 # CONFIG_MAX63XX_WATCHDOG is not set
 
@@ -933,10 +1032,7 @@ CONFIG_SSB_POSSIBLE=y
 # Sonics Silicon Backplane
 #
 # CONFIG_SSB is not set
-
-#
-# Multifunction device drivers
-#
+CONFIG_MFD_SUPPORT=y
 # CONFIG_MFD_CORE is not set
 # CONFIG_MFD_88PM860X is not set
 # CONFIG_MFD_SM501 is not set
@@ -944,28 +1040,39 @@ CONFIG_SSB_POSSIBLE=y
 # CONFIG_HTC_EGPIO is not set
 # CONFIG_HTC_PASIC3 is not set
 # CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
 # CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
 # CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
 # CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
 # CONFIG_MFD_TC6393XB is not set
 # CONFIG_PMIC_DA903X is not set
 # CONFIG_PMIC_ADP5520 is not set
 # CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
 # CONFIG_MFD_WM8400 is not set
-# CONFIG_MFD_WM831X is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
 # CONFIG_MFD_WM8350_I2C is not set
 # CONFIG_MFD_WM8994 is not set
 # CONFIG_MFD_PCF50633 is not set
-# CONFIG_MFD_MC13783 is not set
-# CONFIG_AB3100_CORE is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
 # CONFIG_EZX_PCAP is not set
-# CONFIG_AB4500_CORE is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_WL1273_CORE is not set
 # CONFIG_REGULATOR is not set
 # CONFIG_MEDIA_SUPPORT is not set
 
 #
 # Graphics support
 #
+# CONFIG_DRM is not set
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
@@ -981,6 +1088,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 # CONFIG_FB_SYS_IMAGEBLIT is not set
 # CONFIG_FB_FOREIGN_ENDIAN is not set
 # CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
 # CONFIG_FB_SVGALIB is not set
 # CONFIG_FB_MACMODES is not set
 # CONFIG_FB_BACKLIGHT is not set
@@ -992,6 +1100,7 @@ CONFIG_FB_CFB_IMAGEBLIT=y
 #
 CONFIG_FB_ARMCLCD=y
 # CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_UDL is not set
 # CONFIG_FB_VIRTUAL is not set
 # CONFIG_FB_METRONOME is not set
 # CONFIG_FB_MB862XX is not set
@@ -1006,7 +1115,6 @@ CONFIG_FB_ARMCLCD=y
 #
 # Console display driver support
 #
-# CONFIG_VGA_CONSOLE is not set
 CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
@@ -1050,7 +1158,9 @@ CONFIG_SND_USB=y
 # CONFIG_SND_USB_AUDIO is not set
 # CONFIG_SND_USB_UA101 is not set
 # CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
 CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
 CONFIG_SND_LPC3XXX_SOC=y
 CONFIG_SND_LPC3XXX_SOC_I2S_UDA1380=y
 CONFIG_SND_LPC32XX_USEI2S1=y
@@ -1116,6 +1226,7 @@ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
 #
 CONFIG_USB_STORAGE=y
 # CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
 # CONFIG_USB_STORAGE_DATAFAB is not set
 # CONFIG_USB_STORAGE_FREECOM is not set
 # CONFIG_USB_STORAGE_ISD200 is not set
@@ -1127,6 +1238,8 @@ CONFIG_USB_STORAGE=y
 # CONFIG_USB_STORAGE_ONETOUCH is not set
 # CONFIG_USB_STORAGE_KARMA is not set
 # CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
 CONFIG_USB_LIBUSUAL=y
 
 #
@@ -1161,6 +1274,7 @@ CONFIG_USB_LIBUSUAL=y
 # CONFIG_USB_IOWARRIOR is not set
 # CONFIG_USB_TEST is not set
 # CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
 # CONFIG_USB_GADGET is not set
 
 #
@@ -1172,11 +1286,13 @@ CONFIG_USB_LIBUSUAL=y
 CONFIG_MMC=y
 # CONFIG_MMC_DEBUG is not set
 # CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
 
 #
 # MMC/SD/SDIO Card Drivers
 #
 CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
 # CONFIG_MMC_BLOCK_BOUNCE is not set
 # CONFIG_SDIO_UART is not set
 # CONFIG_MMC_TEST is not set
@@ -1187,6 +1303,8 @@ CONFIG_MMC_BLOCK=y
 CONFIG_MMC_ARMMMCI=y
 # CONFIG_MMC_SDHCI is not set
 # CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_USHC is not set
 # CONFIG_MEMSTICK is not set
 CONFIG_NEW_LEDS=y
 CONFIG_LEDS_CLASS=y
@@ -1194,10 +1312,13 @@ CONFIG_LEDS_CLASS=y
 #
 # LED drivers
 #
+# CONFIG_LEDS_LM3530 is not set
 # CONFIG_LEDS_PCA9532 is not set
 CONFIG_LEDS_GPIO=y
 CONFIG_LEDS_GPIO_PLATFORM=y
 # CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
 # CONFIG_LEDS_PCA955X is not set
 # CONFIG_LEDS_DAC124S085 is not set
 # CONFIG_LEDS_BD2802 is not set
@@ -1216,6 +1337,7 @@ CONFIG_LEDS_TRIGGER_HEARTBEAT=y
 #
 # iptables trigger is under Netfilter config (LED target)
 #
+# CONFIG_NFC_DEVICES is not set
 # CONFIG_ACCESSIBILITY is not set
 CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
@@ -1238,9 +1360,11 @@ CONFIG_RTC_INTF_DEV_UIE_EMUL=y
 # CONFIG_RTC_DRV_DS1307 is not set
 # CONFIG_RTC_DRV_DS1374 is not set
 # CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
 # CONFIG_RTC_DRV_MAX6900 is not set
 # CONFIG_RTC_DRV_RS5C372 is not set
 # CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
 # CONFIG_RTC_DRV_X1205 is not set
 # CONFIG_RTC_DRV_PCF8563 is not set
 # CONFIG_RTC_DRV_PCF8583 is not set
@@ -1289,11 +1413,8 @@ CONFIG_RTC_DRV_LPC32XX=y
 # CONFIG_DMADEVICES is not set
 # CONFIG_AUXDISPLAY is not set
 # CONFIG_UIO is not set
-
-#
-# TI VLYNQ
-#
 # CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
 
 #
 # File systems
@@ -1305,19 +1426,18 @@ CONFIG_EXT2_FS=y
 # CONFIG_EXT4_FS is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
-# CONFIG_FS_POSIX_ACL is not set
 # CONFIG_XFS_FS is not set
 # CONFIG_GFS2_FS is not set
-# CONFIG_OCFS2_FS is not set
 # CONFIG_BTRFS_FS is not set
 # CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
 CONFIG_FILE_LOCKING=y
 CONFIG_FSNOTIFY=y
 CONFIG_DNOTIFY=y
-CONFIG_INOTIFY=y
 CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
 # CONFIG_QUOTA is not set
-# CONFIG_AUTOFS_FS is not set
+# CONFIG_QUOTACTL is not set
 CONFIG_AUTOFS4_FS=y
 # CONFIG_FUSE_FS is not set
 
@@ -1381,6 +1501,7 @@ CONFIG_CRAMFS=y
 # CONFIG_HPFS_FS is not set
 # CONFIG_QNX4FS_FS is not set
 # CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
 CONFIG_NETWORK_FILESYSTEMS=y
@@ -1394,9 +1515,6 @@ CONFIG_LOCKD=y
 CONFIG_LOCKD_V4=y
 CONFIG_NFS_COMMON=y
 CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
-# CONFIG_RPCSEC_GSS_SPKM3 is not set
-# CONFIG_SMB_FS is not set
 # CONFIG_CEPH_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
@@ -1464,12 +1582,12 @@ CONFIG_NLS_ISO8859_1=y
 # CONFIG_NLS_KOI8_R is not set
 # CONFIG_NLS_KOI8_U is not set
 CONFIG_NLS_UTF8=y
-# CONFIG_DLM is not set
 
 #
 # Kernel hacking
 #
 # CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
 CONFIG_ENABLE_WARN_DEPRECATED=y
 CONFIG_ENABLE_MUST_CHECK=y
 CONFIG_FRAME_WARN=1024
@@ -1478,9 +1596,11 @@ CONFIG_FRAME_WARN=1024
 # CONFIG_UNUSED_SYMBOLS is not set
 # CONFIG_DEBUG_FS is not set
 # CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
 CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_SHIRQ is not set
-# CONFIG_DETECT_SOFTLOCKUP is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
 # CONFIG_DETECT_HUNG_TASK is not set
 # CONFIG_SCHED_DEBUG is not set
 # CONFIG_SCHEDSTATS is not set
@@ -1495,16 +1615,19 @@ CONFIG_DEBUG_KERNEL=y
 # CONFIG_DEBUG_MUTEXES is not set
 # CONFIG_DEBUG_LOCK_ALLOC is not set
 # CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
 # CONFIG_LOCK_STAT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
 # CONFIG_DEBUG_KOBJECT is not set
 CONFIG_DEBUG_BUGVERBOSE=y
 CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
 # CONFIG_DEBUG_VM is not set
 # CONFIG_DEBUG_WRITECOUNT is not set
 # CONFIG_DEBUG_MEMORY_INIT is not set
 # CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
 # CONFIG_DEBUG_SG is not set
 # CONFIG_DEBUG_NOTIFIERS is not set
 # CONFIG_DEBUG_CREDENTIALS is not set
@@ -1518,16 +1641,23 @@ CONFIG_FRAME_POINTER=y
 # CONFIG_FAULT_INJECTION is not set
 # CONFIG_LATENCYTOP is not set
 # CONFIG_SYSCTL_SYSCALL_CHECK is not set
-# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
 CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
 CONFIG_TRACING_SUPPORT=y
 # CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
 # CONFIG_SAMPLES is not set
 CONFIG_HAVE_ARCH_KGDB=y
 # CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
 # CONFIG_ARM_UNWIND is not set
 # CONFIG_DEBUG_USER is not set
-CONFIG_DEBUG_ERRORS=y
 # CONFIG_DEBUG_STACK_USAGE is not set
 CONFIG_DEBUG_LL=y
 CONFIG_EARLY_PRINTK=y
@@ -1538,11 +1668,9 @@ CONFIG_EARLY_PRINTK=y
 # Security options
 #
 # CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
 # CONFIG_SECURITY is not set
 # CONFIG_SECURITYFS is not set
-# CONFIG_DEFAULT_SECURITY_SELINUX is not set
-# CONFIG_DEFAULT_SECURITY_SMACK is not set
-# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
 CONFIG_DEFAULT_SECURITY_DAC=y
 CONFIG_DEFAULT_SECURITY=""
 CONFIG_CRYPTO=y
@@ -1550,7 +1678,6 @@ CONFIG_CRYPTO=y
 #
 # Crypto core or helper
 #
-# CONFIG_CRYPTO_FIPS is not set
 CONFIG_CRYPTO_ALGAPI=y
 CONFIG_CRYPTO_ALGAPI2=y
 CONFIG_CRYPTO_AEAD2=y
@@ -1559,9 +1686,10 @@ CONFIG_CRYPTO_BLKCIPHER2=y
 CONFIG_CRYPTO_HASH2=y
 CONFIG_CRYPTO_RNG=y
 CONFIG_CRYPTO_RNG2=y
-CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_PCOMP2=y
 CONFIG_CRYPTO_MANAGER=y
 CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
 # CONFIG_CRYPTO_GF128MUL is not set
 # CONFIG_CRYPTO_NULL is not set
 CONFIG_CRYPTO_WORKQUEUE=y
@@ -1642,6 +1770,8 @@ CONFIG_CRYPTO_AES=y
 # Random Number Generation
 #
 CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
 # CONFIG_CRYPTO_HW is not set
 # CONFIG_BINARY_PRINTF is not set
 
@@ -1659,9 +1789,12 @@ CONFIG_CRC32=y
 # CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
 CONFIG_DECOMPRESS_GZIP=y
 CONFIG_HAS_IOMEM=y
 CONFIG_HAS_IOPORT=y
 CONFIG_HAS_DMA=y
 CONFIG_NLATTR=y
 CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
-- 
1.7.0.4


From f24b98632f1652c68968f1eff76379c1a905ddb3 Mon Sep 17 00:00:00 2001
From: Sundar Andithevar <sundarapandian.andithevar@nxp.com>
Date: Thu, 19 Jan 2012 16:27:43 +0000
Subject: [PATCH 03/10] wdt:lpc32xx:Fix no-wayout on close

The PNX4008/LPC32XX WDT driver should not disable
the watchdog on close when nowayout has been set
for the module

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 drivers/watchdog/pnx4008_wdt.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/drivers/watchdog/pnx4008_wdt.c b/drivers/watchdog/pnx4008_wdt.c
index 6149332..ba531da 100644
--- a/drivers/watchdog/pnx4008_wdt.c
+++ b/drivers/watchdog/pnx4008_wdt.c
@@ -228,6 +228,10 @@ static int pnx4008_wdt_release(struct inode *inode, struct file *file)
 	if (!test_bit(WDT_OK_TO_CLOSE, &wdt_status))
 		printk(KERN_WARNING "WATCHDOG: Device closed unexpectdly\n");
 
+	/* We should not disable watchdog if nowayout is set */
+	if (nowayout)
+		return 0;
+
 	wdt_disable();
 	clk_disable(wdt_clk);
 	clear_bit(WDT_IN_USE, &wdt_status);
-- 
1.7.0.4


From 51bba6a287c981754d7542861d7c2278b61e7cbb Mon Sep 17 00:00:00 2001
From: Bangaragiri G <bangaragiri.g@nxp.com>
Date: Wed, 25 Jan 2012 10:20:54 +0000
Subject: [PATCH 04/10] usbgadget:lpc32xx:Fix write to USB protocol engine

The command/data write to USB HW protocol engine will
fail sometimes. The fix for the same is committed

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 drivers/usb/gadget/lpc32xx_udc.c |   33 +++++++++++++++++----------------
 1 files changed, 17 insertions(+), 16 deletions(-)

diff --git a/drivers/usb/gadget/lpc32xx_udc.c b/drivers/usb/gadget/lpc32xx_udc.c
index 34296d0..cd0605c 100644
--- a/drivers/usb/gadget/lpc32xx_udc.c
+++ b/drivers/usb/gadget/lpc32xx_udc.c
@@ -458,25 +458,26 @@ static void power_work(struct work_struct *work)
 /* Issues a single command to the USB device state machine */
 static void udc_protocol_cmd_w(struct lpc32xx_udc *udc, u32 cmd)
 {
-	volatile u32 tmp;
-	int to = 1000;
+	u32 pass = 0;
+	int to;
 
 	/* EP may lock on CLRI if this read isn't done */
-	tmp = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+	volatile u32 tmp = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+	(void) tmp;
 
-	/* Clear CCEMPTY flash */
-	__raw_writel(USBD_CCEMPTY, USBD_DEVINTCLR(udc->udp_baseaddr));
+	while (pass == 0) {
+		__raw_writel(USBD_CCEMPTY, USBD_DEVINTCLR(udc->udp_baseaddr));
 
-	/* Write command code and wait for protocol engine acceptance */
-	__raw_writel(cmd, USBD_CMDCODE(udc->udp_baseaddr));
+		/* Write command code */
+		__raw_writel(cmd, USBD_CMDCODE(udc->udp_baseaddr));
+		to = 10000;
+		while (((__raw_readl(USBD_DEVINTST(udc->udp_baseaddr)) &
+			USBD_CCEMPTY) == 0) && (to > 0)) {
+			to--;
+		}
 
-	/* Wait for CCEMPTY to signal command acceptance */
-	tmp = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
-	while ((!(__raw_readl(USBD_DEVINTST(udc->udp_baseaddr)) & USBD_CCEMPTY))
-		&& (to > 0))
-		to--;
-	if (!to)
-		dev_dbg(udc->dev, "Protocol engine didn't accept command (CCEMPTY)\n");
+		if (to > 0) pass = 1;
+	}
 }
 
 /* Issues 2 commands (or command and data) to the USB device state machine */
-- 
1.7.0.4


From ae1b5199757a5c681e8cd8096604dd3d3baad153 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 30 Jan 2012 10:17:00 +0000
Subject: [PATCH 05/10] lpc32x0: nand: Workaround for NAND data loss issue

Temporary workaround for DMA/NAND support. There seems to be an issue
when using dma_map_single for NAND buffers in very rare cases. When this
issue happens, the NAND data will be corrupted. This tends to happen only when
under heavy NAND load. For now, keep this define enabled.

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 drivers/mtd/nand/lpc32xx_nand.c |   70 ++++++++++++++++++++------------------
 1 files changed, 37 insertions(+), 33 deletions(-)

diff --git a/drivers/mtd/nand/lpc32xx_nand.c b/drivers/mtd/nand/lpc32xx_nand.c
index 694ff97..e5aaddf 100644
--- a/drivers/mtd/nand/lpc32xx_nand.c
+++ b/drivers/mtd/nand/lpc32xx_nand.c
@@ -37,6 +37,14 @@
 #include <mach/dmac.h>
 #include <mach/dma.h>
 
+/*
+ * Temporary workaround for DMA/NAND support. There seems to be an issue when
+ * using dma_map_single for NAND buffers in very rare cases. When this issue
+ * happens, the NAND data will be corrupted. This tends to happen only when
+ * under heavy NAND load. For now, keep this define enabled.
+ */
+#define USE_DMA_STATIC_BUFFERS
+
 #define LPC32XX_MODNAME			"lpc32xx-nand"
 
 /*
@@ -465,42 +473,49 @@ static int lpc32xx_dma_xfer(struct mtd_info *mtd, uint8_t *buf,
 {
 	struct nand_chip *chip = mtd->priv;
 	struct lpc32xx_nand_host *host = chip->priv;
-	uint32_t config, tmpreg;
+	uint32_t config;
 	dma_addr_t buf_phy;
 	int i, timeout, dma_mapped = 0, status = 0;
 
+#ifndef USE_DMA_STATIC_BUFFERS
 	/* Map DMA buffer */
 	if (likely((void *) buf < high_memory)) {
 		buf_phy = dma_map_single(mtd->dev.parent, buf, mtd->writesize,
 			read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
-		if (unlikely(dma_mapping_error(mtd->dev.parent, buf_phy))) {
+		if (unlikely(dma_mapping_error(mtd->dev.parent, buf_phy)))
 			dev_err(mtd->dev.parent,
 				"Unable to map DMA buffer\n");
-			dma_mapped = 0;
-		} else
+		else
 			dma_mapped = 1;
 	}
+#endif
 
-	/* If a buffer can't be mapped, use the local buffer */
 	if (!dma_mapped) {
 		buf_phy = host->data_buf_dma;
 		if (!read)
 			memcpy(host->data_buf, buf, mtd->writesize);
+			/* Need map sync here? */
 	}
 
-	if (read)
+	if (read) {
 		config = DMAC_CHAN_ITC | DMAC_CHAN_IE | DMAC_CHAN_FLOW_D_P2M |
 			DMAC_DEST_PERIP (0) |
 			DMAC_SRC_PERIP(DMA_PERID_NAND1) | DMAC_CHAN_ENABLE;
-	else
+
+		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) |
+			SLCCFG_DMA_DIR | SLCCFG_ECC_EN | SLCCFG_DMA_ECC |
+			SLCCFG_DMA_BURST, SLC_CFG(host->io_base));
+	} else {
 		config = DMAC_CHAN_ITC | DMAC_CHAN_IE | DMAC_CHAN_FLOW_D_M2P |
 			DMAC_DEST_PERIP(DMA_PERID_NAND1) |
 			DMAC_SRC_PERIP (0) | DMAC_CHAN_ENABLE;
 
-	/* DMA mode with ECC enabled */
-	tmpreg = __raw_readl(SLC_CFG(host->io_base));
-	__raw_writel(SLCCFG_ECC_EN | SLCCFG_DMA_ECC | tmpreg,
-		SLC_CFG(host->io_base));
+		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) |
+			SLCCFG_ECC_EN | SLCCFG_DMA_ECC |SLCCFG_DMA_BURST,
+			SLC_CFG(host->io_base));
+		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) &
+			~SLCCFG_DMA_DIR, SLC_CFG(host->io_base));
+	}
 
 	/* Clear initial ECC */
 	__raw_writel(SLCCTRL_ECC_CLEAR, SLC_CTRL(host->io_base));
@@ -508,16 +523,6 @@ static int lpc32xx_dma_xfer(struct mtd_info *mtd, uint8_t *buf,
 	/* Prepare DMA descriptors */
 	lpc32xx_nand_dma_configure(mtd, buf_phy, chip->ecc.steps, read);
 
-	/* Setup DMA direction and burst mode */
-	if (read)
-		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) |
-			SLCCFG_DMA_DIR, SLC_CFG(host->io_base));
-	else
-		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) &
-			~SLCCFG_DMA_DIR, SLC_CFG(host->io_base));
-	__raw_writel(__raw_readl(SLC_CFG(host->io_base)) | SLCCFG_DMA_BURST,
-		SLC_CFG(host->io_base));
-
 	/* Transfer size is data area only */
 	__raw_writel(mtd->writesize, SLC_TC(host->io_base));
 
@@ -578,18 +583,12 @@ static int lpc32xx_dma_xfer(struct mtd_info *mtd, uint8_t *buf,
 		host->ecc_buf[chip->ecc.steps - 1] =
 			__raw_readl(SLC_ECC(host->io_base));
 	else {
+		/* Just clears ECC */
 		for (i = 0; i < LPC32XX_DMA_ECC_REP_READ; i++)
 			host->ecc_buf[chip->ecc.steps - 1] =
 				__raw_readl(SLC_ECC(host->io_base));
 	}
 
-	/*
-	 * For reads, get the OOB data. For writes, the data will be written
-	 * later
-	 */
-	if (read)
-		chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
-
 	/* Flush DMA link list */
 	lpc32xx_dma_flush_llist(host->dmach);
 
@@ -600,17 +599,19 @@ static int lpc32xx_dma_xfer(struct mtd_info *mtd, uint8_t *buf,
 		status = -EIO;
 	}
 
+	/* Stop DMA & HW ECC */
+	__raw_writel(__raw_readl(SLC_CTRL(host->io_base)) &
+		~SLCCTRL_DMA_START, SLC_CTRL(host->io_base));
+	__raw_writel(__raw_readl(SLC_CFG(host->io_base)) & ~(SLCCFG_DMA_DIR |
+		SLCCFG_ECC_EN | SLCCFG_DMA_ECC | SLCCFG_DMA_BURST),
+		SLC_CFG(host->io_base));
+
 	if (dma_mapped)
 		dma_unmap_single(mtd->dev.parent, buf_phy, mtd->writesize,
 			read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
 	else if (read)
 		memcpy(buf, host->data_buf, mtd->writesize);
 
-	/* Stop DMA & HW ECC */
-	__raw_writel(__raw_readl(SLC_CTRL(host->io_base)) &
-		~SLCCTRL_DMA_START, SLC_CTRL(host->io_base));
-	__raw_writel(tmpreg, SLC_CFG(host->io_base));
-
 	return status;
 }
 
@@ -631,6 +632,9 @@ static int lpc32xx_nand_read_page_syndrome(struct mtd_info *mtd,
 	/* Read data and oob, calculate ECC */
 	status = lpc32xx_dma_xfer(mtd, buf, chip->ecc.steps, 1);
 
+	/* Get OOB data */
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
 	/* Convert to stored ECC format */
 	lpc32xx_slc_ecc_copy(tmpecc, (uint32_t *) host->ecc_buf,
 		chip->ecc.steps);
-- 
1.7.0.4


From 4d56aa27e40ae3df4d03a6020671d512be6e0f60 Mon Sep 17 00:00:00 2001
From: MattRedfearn <matt.redfearn@xxx.com>
Date: Mon, 9 Apr 2012 22:31:21 +0000
Subject: [PATCH 06/10] ethernet:lpc32xx: Ethernet PHY timeout fix

The lpc_mdio_read() function returns an EIO before the final
lpc_net_hard_start_xmit() is called. It turns out that this is because
jiffies rolls over 5 minutes after boot. On a build with my gcc-4.6.1
toolchain, the phy just happens to get polled at a point when jiffies is
0xFFFFFFF8. Timeout therefore becomes +2 and the timeout comparison
fails immediately. The function returns an error and does not set
LPC_ENET_MCMD back to 0. I guess this means that the phy can no longer
receive packets, hence the crc errors. The atached patch fixes the
issue.

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 drivers/net/lpc_eth.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/net/lpc_eth.c b/drivers/net/lpc_eth.c
index 75711f5..0b7e759 100644
--- a/drivers/net/lpc_eth.c
+++ b/drivers/net/lpc_eth.c
@@ -392,7 +392,7 @@ static void __lpc_net_shutdown(struct netdata_local *pldat)
 static int lpc_mdio_read(struct mii_bus *bus, int phy_id, int phyreg)
 {
 	struct netdata_local *pldat = bus->priv;
-	unsigned long timeout = jiffies + ((HZ * 100) / 1000); /* 100mS */
+	unsigned long timeout = jiffies + msecs_to_jiffies(100);
 	int lps;
 
 	writel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));
@@ -400,7 +400,7 @@ static int lpc_mdio_read(struct mii_bus *bus, int phy_id, int phyreg)
 
 	/* Wait for unbusy status */
 	while (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {
-		if (jiffies > timeout)
+		if (time_after(jiffies,timeout))
 			return -EIO;
 		cpu_relax();
 	}
@@ -415,14 +415,14 @@ static int lpc_mdio_write(struct mii_bus *bus, int phy_id, int phyreg,
 			u16 phydata)
 {
 	struct netdata_local *pldat = bus->priv;
-	unsigned long timeout = jiffies + ((HZ * 100) / 1000); /* 100mS */
+	unsigned long timeout = jiffies + msecs_to_jiffies(100);
 
 	writel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));
 	writel(phydata, LPC_ENET_MWTD(pldat->net_base));
 
 	/* Wait for completion */
 	while (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {
-		if (jiffies > timeout)
+		if (time_after(jiffies,timeout))
 			return -EIO;
 		cpu_relax();
 	}
-- 
1.7.0.4


From f2e83ed594e2697c25d2b4196246557c1ad7930c Mon Sep 17 00:00:00 2001
From: DaveSKok <DaveSKok@xxx.com>
Date: Wed, 16 May 2012 10:41:00 +0000
Subject: [PATCH 07/10] arm:lpc32xx:fdi3250 - config with mmc, no frame buffer

When support for frame buffer is disabled and MMC enabled, fdi3250.c
will not compile because MMC conditional compile construct mistakenly
placed inside of frame buffer conditional compile construct. This patch
moves MMC code out.

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 arch/arm/mach-lpc32xx/fdi3250.c |   84 +++++++++++++++++++-------------------
 1 files changed, 42 insertions(+), 42 deletions(-)

diff --git a/arch/arm/mach-lpc32xx/fdi3250.c b/arch/arm/mach-lpc32xx/fdi3250.c
index e0ae08d..2dff3c6 100644
--- a/arch/arm/mach-lpc32xx/fdi3250.c
+++ b/arch/arm/mach-lpc32xx/fdi3250.c
@@ -195,48 +195,6 @@ static struct clcd_panel conn_lcd_panel = {
 
 #endif // CONFIG_SOM9DIMM3250_LCD_PANEL
 
-#if defined (CONFIG_MMC_ARMMMCI)
-static u32 mmc_translate_vdd(struct device *dev, unsigned int vdd,
-		unsigned char mode)
-{
-	return 0;
-}
-
-unsigned int fdi_mmc_status_always_on(struct device *dev)
-{
-	return 0;
-}
-/*
- * Board specific MMC driver data
- */
-struct mmci_platform_data lpc32xx_plat_data = {
-	.ocr_mask       = MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|MMC_VDD_33_34,
-	.vdd_handler	= mmc_translate_vdd,
-	.capabilities   = MMC_CAP_4_BIT_DATA,
-	.gpio_wp        = ARCH_NR_GPIOS + 1,
-	.gpio_cd        = ARCH_NR_GPIOS + 1,
-	.status         = fdi_mmc_status_always_on,
-};
-
-/*
- * SD card controller resources
- */
-struct amba_device lpc32xx_mmc_device = {
-	.dev = {
-		.coherent_dma_mask      = ~0,
-		.init_name                 = "dev:mmc0",
-		.platform_data          = &lpc32xx_plat_data,
-	},
-	.res = {
-		.start                  = LPC32XX_SD_BASE,
-		.end                    = (LPC32XX_SD_BASE + SZ_4K - 1),
-		.flags                  = IORESOURCE_MEM,
-	},
-	.dma_mask                       = ~0,
-	.irq                            = {IRQ_LPC32XX_SD0, IRQ_LPC32XX_SD1},
-};
-#endif
-
 static int lpc32xx_clcd_setup(struct clcd_fb *fb)
 {
 	dma_addr_t dma;
@@ -320,6 +278,48 @@ struct amba_device lpc32xx_clcd_device = {
 };
 #endif
 
+#if defined (CONFIG_MMC_ARMMMCI)
+static u32 mmc_translate_vdd(struct device *dev, unsigned int vdd,
+		unsigned char mode)
+{
+	return 0;
+}
+
+unsigned int fdi_mmc_status_always_on(struct device *dev)
+{
+	return 0;
+}
+/*
+ * Board specific MMC driver data
+ */
+struct mmci_platform_data lpc32xx_plat_data = {
+	.ocr_mask       = MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|MMC_VDD_33_34,
+	.vdd_handler	= mmc_translate_vdd,
+	.capabilities   = MMC_CAP_4_BIT_DATA,
+	.gpio_wp        = ARCH_NR_GPIOS + 1,
+	.gpio_cd        = ARCH_NR_GPIOS + 1,
+	.status         = fdi_mmc_status_always_on,
+};
+
+/*
+ * SD card controller resources
+ */
+struct amba_device lpc32xx_mmc_device = {
+	.dev = {
+		.coherent_dma_mask      = ~0,
+		.init_name                 = "dev:mmc0",
+		.platform_data          = &lpc32xx_plat_data,
+	},
+	.res = {
+		.start                  = LPC32XX_SD_BASE,
+		.end                    = (LPC32XX_SD_BASE + SZ_4K - 1),
+		.flags                  = IORESOURCE_MEM,
+	},
+	.dma_mask                       = ~0,
+	.irq                            = {IRQ_LPC32XX_SD0, IRQ_LPC32XX_SD1},
+};
+#endif
+
 /* AMBA based devices list */
 static struct amba_device *amba_devs[] __initdata = {
 	&lpc32xx_ssp0_device,
-- 
1.7.0.4


From eb680c15c65539901fd2121b6c413b1615fd1866 Mon Sep 17 00:00:00 2001
From: Bangaragiri G <bangaragiri.g@nxp.com>
Date: Tue, 26 Jun 2012 10:20:02 +0000
Subject: [PATCH 08/10] arm:lpc32xx:Fix for Edge triggered IRQs

We need to fix our IRQ handling to have handle_edge_irq
flow handlers for edge triggered interrupts

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 arch/arm/mach-lpc32xx/irq.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-lpc32xx/irq.c b/arch/arm/mach-lpc32xx/irq.c
index 2a6652b..d3dfedc 100644
--- a/arch/arm/mach-lpc32xx/irq.c
+++ b/arch/arm/mach-lpc32xx/irq.c
@@ -336,11 +336,13 @@ static int lpc32xx_set_irq_type(struct irq_data *d, unsigned int type)
 	case IRQ_TYPE_EDGE_RISING:
 		/* Rising edge sensitive */
 		__lpc32xx_set_irq_type(d->irq, 1, 1);
+		__irq_set_handler_locked(d->irq, handle_edge_irq);
 		break;
 
 	case IRQ_TYPE_EDGE_FALLING:
 		/* Falling edge sensitive */
 		__lpc32xx_set_irq_type(d->irq, 0, 1);
+		__irq_set_handler_locked(d->irq, handle_edge_irq);
 		break;
 
 	case IRQ_TYPE_LEVEL_LOW:
-- 
1.7.0.4


From 126a5edc8e66550c5d7bed4209283f41cf4a8159 Mon Sep 17 00:00:00 2001
From: Anders Lindvall <anders.lindvall@xxx.com>
Date: Tue, 26 Jun 2012 12:28:22 +0000
Subject: [PATCH 09/10] arm:lpc32xx: Ea3250 LCD and MMC updates

The patch is submitted by Anders Lindvall.
The patch provides support to any mounted LCD displays.
The patch also includes MMC card detect functionality.

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 arch/arm/configs/ea3250_defconfig |    6 -
 arch/arm/mach-lpc32xx/Kconfig     |   14 -
 arch/arm/mach-lpc32xx/ea3250.c    |  861 ++++++++++++++++++++++++++++++++-----
 3 files changed, 751 insertions(+), 130 deletions(-)

diff --git a/arch/arm/configs/ea3250_defconfig b/arch/arm/configs/ea3250_defconfig
index 5a0cc53..7cd1a74 100644
--- a/arch/arm/configs/ea3250_defconfig
+++ b/arch/arm/configs/ea3250_defconfig
@@ -257,12 +257,6 @@ CONFIG_MACH_EA3250=y
 # CONFIG_MACH_FDI3250 is not set
 
 #
-# Embedded Artists Display Selection
-#
-CONFIG_EA3250_QVGA_3_2_LCD=y
-# CONFIG_EA3250_QVGA_2_8_OLED is not set
-
-#
 # Standard UARTS
 #
 # CONFIG_ARCH_LPC32XX_UART3_SELECT is not set
diff --git a/arch/arm/mach-lpc32xx/Kconfig b/arch/arm/mach-lpc32xx/Kconfig
index 16f0f8c..0ba9736 100644
--- a/arch/arm/mach-lpc32xx/Kconfig
+++ b/arch/arm/mach-lpc32xx/Kconfig
@@ -23,20 +23,6 @@ choice
 
 endchoice
 
-menu "Embedded Artists Display Selection"
-	depends on MACH_EA3250
-
-config EA3250_QVGA_3_2_LCD
-	bool "3.2 inch QVGA LCD display (RGB565)"
-	help
-	  Use 3.2 inch QVGA LCD display
-
-config EA3250_QVGA_2_8_OLED
-	bool "2.8 inch QVGA OLED display (RGB565)"
-	help
-	  Use 2.8 inch QVGA OLED display
-
-endmenu
 
 
 config SOM9DIMM3250_LCD_PANEL
diff --git a/arch/arm/mach-lpc32xx/ea3250.c b/arch/arm/mach-lpc32xx/ea3250.c
index f12297f..a4ee0aa 100644
--- a/arch/arm/mach-lpc32xx/ea3250.c
+++ b/arch/arm/mach-lpc32xx/ea3250.c
@@ -32,6 +32,7 @@
 #include <linux/amba/clcd.h>
 #include <linux/amba/pl022.h>
 #include <linux/amba/mmci.h>
+#include <linux/kthread.h>
 #include <mtd/mtd-abi.h>
 
 #include <asm/setup.h>
@@ -40,6 +41,8 @@
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
 #include <mach/board.h>
 #include "common.h"
 
@@ -66,7 +69,131 @@
  */
 #define SET_RS		(gpio_set_value(LCD_RS_GPIO, 1))
 #define RESET_RS	(gpio_set_value(LCD_RS_GPIO, 0))
-#define PANEL_SIZE	(3 * SZ_64K)
+
+#define LCDB_PCA9532_I2C_ADDR       (0x64)
+#define LCDB_CONFIG_EEPROM_I2C_ADDR (0x56)
+
+/* PCA9532 registers*/
+#define LCDB_PCA9532_INPUT0   0x00
+#define LCDB_PCA9532_INPUT1   0x01
+#define LCDB_PCA9532_PSC0     0x02
+#define LCDB_PCA9532_PWM0     0x03
+#define LCDB_PCA9532_PSC1     0x04
+#define LCDB_PCA9532_PWM1     0x05
+#define LCDB_PCA9532_LS0      0x06
+#define LCDB_PCA9532_LS1      0x07
+#define LCDB_PCA9532_LS2      0x08
+#define LCDB_PCA9532_LS3      0x09
+#define LCDB_PCA9532_AUTO_INC 0x10
+
+#define LCDB_LS_MODE_ON     0x01
+#define LCDB_LS_MODE_BLINK0 0x02
+#define LCDB_LS_MODE_BLINK1 0x03
+
+#define LCDB_CTRL_3V3     0x0001
+#define LCDB_CTRL_5V      0x0002
+#define LCDB_CTRL_DISP_EN 0x0010
+#define LCDB_CTRL_BL_EN   0x0080
+#define LCDB_CTRL_BL_C    0x0100
+#define LCDB_EEPROM_WP    0x8000
+
+#define LCDB_MAGIC 0xEA01CDAE
+
+#define LCDB_NAME_BUF_SZ 30
+
+static uint16_t blink0Shadow = 0;
+static uint16_t blink1Shadow = 0;
+static uint16_t ledStateShadow = 0;
+
+typedef struct {
+  uint32_t magic;        // magic number
+  uint8_t  lcd_name[LCDB_NAME_BUF_SZ]; // LCD name
+  uint8_t  lcd_mfg[LCDB_NAME_BUF_SZ];  // manufacturer name
+  uint16_t lcdParamOff;  // offset to LCD parameters
+  uint16_t initOff;      // offset to init sequence string
+  uint16_t pdOff;        // offset to power down sequence string
+  uint16_t tsOff;        // offset to touch parameters
+  uint16_t end;          // end offset
+} eaLcdbStore_t;
+
+/* LCD display types */
+typedef enum
+{
+  TFT = 0,      /* Panel type is standard TFT */
+  ADTFT,        /* Panel type is advanced TFT */
+  HRTFT,        /* Panel type is highly reflective TFT */
+  MONO_4BIT,    /* Panel type is 4-bit mono */
+  MONO_8BIT,    /* Panel type is 8-bit mono */
+  CSTN          /* Panel type is color STN */
+} LCD_PANEL_T;
+
+/* Structure containing the parameters for the LCD panel */
+typedef struct
+{
+  uint8_t           h_back_porch;         /* Horizontal back porch in
+                                             clocks (minimum of 1) */
+  uint8_t           h_front_porch;        /* Horizontal front porch in
+                                             clocks (minimum of 1) */
+  uint8_t           h_sync_pulse_width;   /* HSYNC pulse width in
+                                             clocks (minimum of 1) */
+  uint16_t          pixels_per_line;      /* Pixels per line (horizontal
+                                             resolution) */
+  uint8_t           v_back_porch;         /* Vertical back porch in
+                                             clocks */
+  uint8_t           v_front_porch;        /* Vertical front porch in
+                                             clocks */
+  uint8_t           v_sync_pulse_width;   /* VSYNC pulse width in
+                                             clocks (minimum 1 clock) */
+  uint16_t          lines_per_panel;      /* Lines per panel (vertical
+                                             resolution) */
+  uint8_t           invert_output_enable; /* Invert output enable, 1 =
+                                             invert*/
+  uint8_t           invert_panel_clock;   /* Invert panel clock, 1 =
+                                             invert*/
+  uint8_t           invert_hsync;         /* Invert HSYNC, 1 = invert */
+  uint8_t           invert_vsync;         /* Invert VSYNC, 1 = invert */
+  uint8_t           ac_bias_frequency;    /* AC bias frequency in
+                                             clocks (minimum 1) */
+  uint8_t           bits_per_pixel;       /* Maximum bits per pixel the
+                                             display supports */
+  uint32_t          optimal_clock;        /* Optimal clock rate (Hz) */
+  LCD_PANEL_T     lcd_panel_type;       /* LCD panel type */
+  uint8_t           dual_panel;           /* Dual panel, 1 = dual panel
+                                             display */
+
+  /* The following parameters are needed for ADTFT and HRTFT panels
+     only. For all other panels, these should be programmed to 0 */
+  uint8_t           hrtft_cls_enable;     /* HRTFT CLS enable flag, 1 =
+                                             enable */
+  uint8_t           hrtft_sps_enable;     /* HRTFT SPS enable flag, 1 =
+                                             enable */
+  uint8_t           hrtft_lp_to_ps_delay; /* HRTFT LP to PS delay in
+                                             clocks */
+  uint8_t           hrtft_polarity_delay; /* HRTFT polarity delay in
+                                             clocks */
+  uint8_t           hrtft_lp_delay;       /* HRTFT LP delay in clocks */
+  uint8_t           hrtft_spl_delay;      /* HRTFT SPL delay in
+                                             clocks */
+  /* HRTFT SPL to CLKS delay */
+  uint16_t          hrtft_spl_to_cls_delay;
+} LCD_PARAM_T;
+
+#define LCD_SEQUENCE_BUF_SZ  100
+typedef struct
+{
+  char init_seq[LCD_SEQUENCE_BUF_SZ];
+  char power_down_seq[LCD_SEQUENCE_BUF_SZ];
+  char hardware_name[LCDB_NAME_BUF_SZ];
+  char panel_name[LCDB_NAME_BUF_SZ];
+
+  struct clcd_panel lcd_panel_from_eeprom;
+} lpc32xx_lcd_parameters_t;
+
+lpc32xx_lcd_parameters_t* lpc32xx_lcd_parameters = NULL;
+
+static struct i2c_client *ea_i2c_video_client;
+
+struct clcd_board lpc32xx_clcd_data;
 
 /* SPI LCDC device structure */
 struct spi_device *ea3250_spi_lcd_dev = NULL;
@@ -279,7 +406,6 @@ arch_initcall(ea3250_spi_devices_register);
 /*
  * LCDC AMBA Driver Board Functions
  */
-#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
 /*
  * Support for Embedded Artists 3.2 inch QVGA LCD panel
  */
@@ -301,55 +427,37 @@ static struct clcd_panel conn_lcd_panel = {
 	},
 	.width = -1,
 	.height = -1,
-	.tim2 = (TIM2_IVS | TIM2_IHS),
+	.tim2 = (TIM2_IVS | TIM2_IHS | TIM2_IPC),
 	.cntl = (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
 			CNTL_LCDBPP16_565),
 	.bpp = 16,
 };
 
-#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
-/*
- * Support for Embedded Artists 2.8 inch QVGA OLED panel
-*/
-static struct clcd_panel conn_lcd_panel = {
-	.mode = {
-		.name = "QVGA portrait",
-		.refresh = 60,
-		.xres = 240,
-		.yres = 320,
-		.pixclock = 176366,
-		.left_margin = 33,
-		.right_margin = 26,
-		.upper_margin = 3,
-		.lower_margin = 8,
-		.hsync_len = 32,
-		.vsync_len = 4,
-		.sync = 0,
-		.vmode = FB_VMODE_NONINTERLACED,
-	},
-	.width = -1,
-	.height = -1,
-	.tim2 = (TIM2_IVS | TIM2_IHS),
-	.cntl = (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
-			CNTL_LCDBPP16_565),
-	.bpp = 16,
-};
-#endif
 
 static int lpc32xx_clcd_setup(struct clcd_fb *fb)
 {
 	dma_addr_t dma;
+	size_t panel_size = 3 * SZ_64K;
+	struct clcd_panel* panel_to_use = &conn_lcd_panel;
+
+    if (lpc32xx_lcd_parameters != NULL) {
+      panel_to_use = &lpc32xx_lcd_parameters->lcd_panel_from_eeprom;
+    }
+
+	while (panel_size < ((panel_to_use->bpp / 8) * panel_to_use->mode.xres * panel_to_use->mode.yres)) {
+	  panel_size += SZ_64K;
+	}
 
 	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev,
-			PANEL_SIZE, &dma, GFP_KERNEL);
+	    panel_size, &dma, GFP_KERNEL);
 	if (!fb->fb.screen_base) {
 		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
 		return -ENOMEM;
 	}
 
 	fb->fb.fix.smem_start = dma;
-	fb->fb.fix.smem_len = PANEL_SIZE;
-	fb->panel = &conn_lcd_panel;
+	fb->fb.fix.smem_len = panel_size;
+	fb->panel = panel_to_use;
 
 	if (gpio_request(SSEL0_GPIO5, "Unused GPIO5 input"))
 		return -EIO;
@@ -367,11 +475,7 @@ static int lpc32xx_clcd_setup(struct clcd_fb *fb)
 	if (gpio_request(BKL_POW_GPIO, "LCDC BKL"))
 		return -EIO;
 
-#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
-	if(gpio_direction_output(BKL_POW_GPIO, 0)) {
-#else
 	if(gpio_direction_output(BKL_POW_GPIO, 1)) {
-#endif
 		return -EIO;
 	}
 
@@ -392,30 +496,391 @@ static void lpc32xx_clcd_remove(struct clcd_fb *fb)
 			fb->fb.screen_base, fb->fb.fix.smem_start);
 }
 
-static void spiSend(u8 *buf, size_t len)
+static int lcdb_eeprom_read(struct i2c_client *client, uint8_t* buf, uint16_t offset, uint16_t len)
 {
-	BUG_ON(ea3250_spi_lcd_dev == NULL);
-	spi_write(ea3250_spi_lcd_dev, buf, len);
+  int i = 0;
+  int ret;
+  uint8_t off[2];
+
+  off[0] = ((offset >> 8) & 0xff);
+  off[1] = (offset & 0xff);
+
+  ret = i2c_master_send(client, off, 2);
+  if (ret != 2)
+  {
+    return -EIO;
+  }
+  for (i = 0; i < 0x2000; i++);
+  ret = i2c_master_recv(client, buf, len);
+  if (ret != len)
+  {
+    return -EIO;
+  }
+  return ret;
 }
 
-#if defined (CONFIG_EA3250_QVGA_2_8_OLED)
-static void writeToDisp(u16 data)
+/*
+ * Automatically detects the presence of the 4.3" and 7" displays
+ * from Embedded Artists. This is done by reading the display
+ * configuration from an EEPROM on the display board. If the
+ * configuration is present it will be used to setup the display.
+ * If the EEPROM is not found or the configuration is incorrect then
+ * it is assumed that the display is the 3.2" display. The 3.2" display
+ * is present on both the QVGA Base Board and as a separate display
+ * board to use with the OEM Base Board.
+ */
+static int ea_i2c_display_eeprom_probe(struct i2c_client *client,
+      const struct i2c_device_id *id)
 {
-	u8 buf[3];
+  int result = 0;
+  size_t size;
+  eaLcdbStore_t store;
+  LCD_PARAM_T lcdParams;
+
+  do
+  {
+    /* Read parameter header */
+    size = sizeof(store);
+    result = lcdb_eeprom_read(client, (uint8_t*)&store, 0, size);
+    if (result != size)
+    {
+      break;
+    }
+    if (store.magic != LCDB_MAGIC)
+    {
+      result = -ENODEV;
+      break;
+    }
+
+    /* Found header with correct magic number, now read the LCD parameters */
+    size = (store.initOff-store.lcdParamOff);
+    result = lcdb_eeprom_read(client, (uint8_t*)&lcdParams, store.lcdParamOff, size);
+    if (result != size)
+    {
+      break;
+    }
+
+    /* Allocate memory for display parameters that need to be kept */
+    lpc32xx_lcd_parameters = NULL;
+    size = sizeof(lpc32xx_lcd_parameters_t);
+    lpc32xx_lcd_parameters = kmalloc(size, GFP_KERNEL);
+    if (!lpc32xx_lcd_parameters) {
+      result = -ENOMEM;
+      break;
+    }
+
+    /* Read initialization sequence */
+    size = (store.pdOff-store.initOff);
+    BUG_ON(size > LCD_SEQUENCE_BUF_SZ);
+    result = lcdb_eeprom_read(client, (uint8_t*)lpc32xx_lcd_parameters->init_seq, store.initOff, size);
+    if (result != size)
+    {
+      break;
+    }
+
+    /* Read power down sequence */
+    size = (store.tsOff-store.pdOff);
+    BUG_ON(size > LCD_SEQUENCE_BUF_SZ);
+    result = lcdb_eeprom_read(client, (uint8_t*)lpc32xx_lcd_parameters->power_down_seq, store.pdOff, size);
+    if (result != size)
+    {
+      break;
+    }
+
+    memcpy(lpc32xx_lcd_parameters->hardware_name, store.lcd_name, LCDB_NAME_BUF_SZ);
+
+    if (lcdParams.pixels_per_line == 800 && lcdParams.lines_per_panel == 480) {
+      sprintf(lpc32xx_lcd_parameters->panel_name, "7 inch WVGA landscape");
+    } else if (lcdParams.pixels_per_line == 480 && lcdParams.lines_per_panel == 272) {
+      sprintf(lpc32xx_lcd_parameters->panel_name, "4.3 inch WVGA landscape");
+    } else {
+      sprintf(lpc32xx_lcd_parameters->panel_name, "%d x %d unknown", lcdParams.pixels_per_line, lcdParams.lines_per_panel);
+    }
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.name = lpc32xx_lcd_parameters->panel_name;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.refresh = 60;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.xres = lcdParams.pixels_per_line;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.yres = lcdParams.lines_per_panel;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.pixclock = KHZ2PICOS((lcdParams.optimal_clock / 1000)); //optimal_clock is in Hz
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.left_margin = lcdParams.h_front_porch;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.right_margin = lcdParams.h_back_porch;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.upper_margin = lcdParams.v_front_porch;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.lower_margin = lcdParams.v_back_porch;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.hsync_len = lcdParams.h_sync_pulse_width;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.vsync_len = lcdParams.v_sync_pulse_width;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.sync = 0;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.vmode = FB_VMODE_NONINTERLACED;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.width = -1;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.height = -1;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.tim2 = (TIM2_IVS | TIM2_IHS);
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.cntl = (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) | CNTL_LCDBPP16_565);
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.bpp = 16;
+
+    lpc32xx_clcd_data.name = lpc32xx_lcd_parameters->hardware_name;
+    return 0;
+  } while(0);
+
+  if (lpc32xx_lcd_parameters != NULL)
+  {
+    kfree(lpc32xx_lcd_parameters);
+    lpc32xx_lcd_parameters = NULL;
+  }
+
+  return result;
+}
 
-	/* Initiliase buffer */
-	buf[0] = 0x72;
-	buf[1] = data >> 8;
-	buf[2] = data & 0xff;
-	spiSend(buf, 3);
+static int __devexit ea_i2c_display_eeprom_remove(struct i2c_client *client)
+{
+  if (lpc32xx_lcd_parameters != NULL)
+  {
+    kfree(lpc32xx_lcd_parameters);
+    lpc32xx_lcd_parameters = NULL;
+  }
+
+  return 0;
+}
+
+static int ea_i2c_video_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+  ea_i2c_video_client = client;
+  return 0;
+}
+
+static int __devexit ea_i2c_video_remove(struct i2c_client *client)
+{
+  ea_i2c_video_client = NULL;
+  return 0;
+}
+
+static const struct i2c_device_id ea_i2c_video_id[] = {
+    { "ea_i2c_video", 0 },
+    { }
+};
+
+static struct i2c_driver ea_i2c_video_driver = {
+	.driver = {
+		.name	= "ea_i2c_video",
+	},
+	.probe		= ea_i2c_video_probe,
+	.remove		= ea_i2c_video_remove,
+	.id_table	= ea_i2c_video_id,
+};
+
+static const struct i2c_device_id ea_i2c_display_eeprom_id[] = {
+    { "ea_i2c_disp_cfg", 0 },
+    { }
+};
+
+static struct i2c_driver ea_i2c_display_eeprom_driver = {
+  .driver = {
+    .name = "ea_i2c_disp_cfg",
+  },
+  .probe    = ea_i2c_display_eeprom_probe,
+  .remove   = ea_i2c_display_eeprom_remove,
+  .id_table = ea_i2c_display_eeprom_id,
+};
+
+static void init_ea_i2c_video(void)
+{
+  i2c_add_driver(&ea_i2c_display_eeprom_driver);
+  i2c_add_driver(&ea_i2c_video_driver);
+}
+
+/**
+ * Helper function to set LED states
+ */
+static void setLsStates(uint16_t states, uint8_t* ls, uint8_t mode)
+{
+#define IS_LED_SET(bit, x) ( ( ((x) & (bit)) != 0 ) ? 1 : 0 )
+
+    int i = 0;
+
+    for (i = 0; i < 4; i++) {
+
+        ls[i] |= ( (IS_LED_SET(0x0001, states)*mode << 0)
+                | (IS_LED_SET(0x0002, states)*mode << 2)
+                | (IS_LED_SET(0x0004, states)*mode << 4)
+                | (IS_LED_SET(0x0008, states)*mode << 6) );
+
+        states >>= 4;
+    }
+}
+
+/**
+ * Set LEDs (PCA9532 on LCD board)
+ */
+static void setLeds(void)
+{
+    uint8_t buf[5];
+    uint8_t ls[4] = {0,0,0,0};
+    uint16_t states = ledStateShadow;
+
+    /* LEDs in On/Off state */
+    setLsStates(states, ls, LCDB_LS_MODE_ON);
+
+    /* set the LEDs that should blink */
+    setLsStates(blink0Shadow, ls, LCDB_LS_MODE_BLINK0);
+    setLsStates(blink1Shadow, ls, LCDB_LS_MODE_BLINK1);
+
+    buf[0] = LCDB_PCA9532_LS0 | LCDB_PCA9532_AUTO_INC;
+    buf[1] = ls[0];
+    buf[2] = ls[1];
+    buf[3] = ls[2];
+    buf[4] = ls[3];
+    i2c_master_send(ea_i2c_video_client, buf, 5);
+}
+
+/**
+ * Set LED states (on or off).
+ *
+ * Params:
+ *    [in]  ledOnMask  - The LEDs that should be turned on. This mask has
+ *                       priority over ledOffMask
+ *    [in]  ledOffMask - The LEDs that should be turned off.
+ *
+ */
+static void lcdb_pca9532_setLeds (uint16_t ledOnMask, uint16_t ledOffMask)
+{
+    /* turn off leds */
+    ledStateShadow &= (~(ledOffMask) & 0xffff);
+
+    /* ledOnMask has priority over ledOffMask */
+    ledStateShadow |= ledOnMask;
+
+    /* turn off blinking */
+    blink0Shadow &= (~(ledOffMask) & 0xffff);
+    blink1Shadow &= (~(ledOffMask) & 0xffff);
+
+    setLeds();
+}
+
+/**
+ *  Set the blink period for PWM0. Valid values are 0 - 255 where 0
+ *  means 152 Hz and 255 means 0.59 Hz. A value of 151 means 1 Hz.
+ *
+ * Params:
+ *    [in]  period  - the period for pwm0
+ *
+ */
+static void lcdb_pca9532_setBlink0Period(uint8_t period)
+{
+    uint8_t buf[2];
+
+    buf[0] = LCDB_PCA9532_PSC0;
+    buf[1] = period;
+    i2c_master_send(ea_i2c_video_client, buf, 2);
+}
+
+/**
+ * Set the duty cycle for PWM0. Valid values are 0 - 100. 25 means the LED
+ * is on 25% of the period.
+ *
+ * Params:
+ *    [in]  duty  - duty cycle
+ *
+ */
+static void lcdb_pca9532_setBlink0Duty(uint8_t duty)
+{
+    uint8_t buf[2];
+    uint32_t tmp = duty;
+    if (tmp > 100) {
+        tmp = 100;
+    }
+
+    tmp = (255 * tmp)/100;
+
+    buf[0] = LCDB_PCA9532_PWM0;
+    buf[1] = tmp;
+    i2c_master_send(ea_i2c_video_client, buf, 2);
+}
+
+/**
+ *  Set the LEDs that should blink with rate and duty cycle from PWM0.
+ *  Blinking is turned off with pca9532_setLeds.
+ *
+ * Params:
+ *    [in]  ledMask  - LEDs that should blink.
+ *
+ */
+static void lcdb_pca9532_setBlink0Leds(uint16_t ledMask)
+{
+    blink0Shadow |= ledMask;
+    setLeds();
+}
+
+/******************************************************************************
+ *
+ * Description:
+ *    Enable/disable 3V3 signal
+ *
+ *****************************************************************************/
+static void ea_lcdb_ctrl_3v3(uint32_t enable)
+{
+  if (enable) {
+    lcdb_pca9532_setLeds(LCDB_CTRL_3V3, 0);
+  } else {
+    lcdb_pca9532_setLeds(0, LCDB_CTRL_3V3);
+  }
+
+}
+
+/******************************************************************************
+ *
+ * Description:
+ *    Enable/disable 5V signal
+ *
+ *****************************************************************************/
+static void ea_lcdb_ctrl_5v(uint32_t enable)
+{
+  if (enable) {
+    lcdb_pca9532_setLeds(LCDB_CTRL_5V, 0);
+  } else {
+    lcdb_pca9532_setLeds(0, LCDB_CTRL_5V);
+  }
+}
+
+/******************************************************************************
+ *
+ * Description:
+ *    Enable/disable display enable signal
+ *
+ *****************************************************************************/
+static void ea_lcdb_ctrl_display(uint32_t enable)
+{
+  if (!enable) {
+    lcdb_pca9532_setLeds(LCDB_CTRL_DISP_EN, 0);
+  } else {
+    lcdb_pca9532_setLeds(0, LCDB_CTRL_DISP_EN);
+  }
+}
+
+/******************************************************************************
+ *
+ * Description:
+ *    Set backlight contrast
+ *
+ * Params:
+ *   [in] value - backlight value; valid values 0-100
+ *
+ *****************************************************************************/
+static void ea_lcdb_ctrl_backlightContrast(uint32_t value)
+{
+  lcdb_pca9532_setBlink0Duty(100-value);
+  lcdb_pca9532_setBlink0Period(0);
+  lcdb_pca9532_setBlink0Leds(LCDB_CTRL_BL_C);
+}
+
+
+static void spiSend(u8 *buf, size_t len)
+{
+	BUG_ON(ea3250_spi_lcd_dev == NULL);
+	spi_write(ea3250_spi_lcd_dev, buf, len);
 }
-#endif
 
 static void writeToReg(u16 addr, u16 data)
 {
 	u8 buf[3];
 
-#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
 	RESET_RS;
 	buf[0] = 0x00;
 	buf[1] = addr & 0xff;
@@ -430,13 +895,6 @@ static void writeToReg(u16 addr, u16 data)
 	buf[0] = 0x00;
 	buf[1] = 0x22;
 	spiSend(buf, 2);
-#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
-	buf[0] = 0x70;
-	buf[1] = data >> 8;
-	buf[2] = data & 0xff;
-	spiSend(buf, 3);
-#endif
-
 }
 
 static void clcd_display_init(void)
@@ -447,7 +905,6 @@ static void clcd_display_init(void)
 	__raw_writel(( _BIT(12) | _BIT(10) | _BIT(9) ), LPC32XX_GPIO_P_MUX_SET);
 	tmp = __raw_readl(LPC32XX_GPIO_P_MUX_SET);
 
-#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
 	writeToReg (0x00,0x0001);
 	mdelay(20);
 	writeToReg (0x03,0xA2A4);
@@ -496,63 +953,168 @@ static void clcd_display_init(void)
 	writeToReg (0x4E,0x0000);
 	writeToReg (0x4F,0x0000);
 	writeToReg (0x46,0x013F);
+}
 
-#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
-	writeToReg(0,0x02);
-	writeToDisp(0x0192);
+/**
+ * Convert a string to an integer
+ *
+ * @params str - the string to convert
+ * @params len - length of the string (it might not be null terminated)
+ */
+static uint32_t str_to_uint(char* str, uint32_t len)
+{
+  uint32_t val = 0;
 
-	writeToReg(0,0x03);
-	writeToDisp(0x0130);
+  while(len > 0 && *str <= '9' && *str >= '0') {
+    val = (val * 10) + (*str - '0');
+    str++;
+    len--;
+  }
 
-	/* set standby off */
-	writeToReg(0,0x10);
-	writeToDisp(0x0000);
+  return val;
+}
 
-	mdelay(100);
+/**
+ * Check if the sequence string version can be handled.
+ *
+ */
+static int checkVersion(char* v, uint32_t len)
+{
+  uint32_t ver = str_to_uint(v, len);
 
-	/* set display on */
-	writeToReg(0,0x05);
-	writeToDisp(0x0001);
+  if (ver > 1) {
+    return -1; //only supports v1
+  }
 
-	/* enable image data transfer */
-	writeToReg(0,0x22);
-#endif
+  return 0;
 }
 
-void clcd_disable(struct clcd_fb *fb)
+/**
+ * Execute a control request (PCA9532)
+ */
+static int execSeqCtrl(char* cmd, uint32_t len)
 {
-	/* Disable the backlight */
-#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
-	gpio_set_value(BKL_POW_GPIO, 1);
-#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
-	gpio_set_value(BKL_POW_GPIO, 0);
-#endif
+
+  switch (*cmd++) {
+    // display enable
+    case 'd':
+      ea_lcdb_ctrl_display(*cmd == '1');
+      break;
+
+    // backlight contrast
+    case 'c':
+      ea_lcdb_ctrl_backlightContrast(str_to_uint(cmd, len));
+      break;
+
+    // 3v3 enable
+    case '3':
+      ea_lcdb_ctrl_3v3(*cmd == '1');
+      break;
+
+    // 5v enable
+    case '5':
+      ea_lcdb_ctrl_5v(*cmd == '1');
+      break;
+
+  }
+
+  return 0;
 }
 
-void clcd_enable(struct clcd_fb *fb)
+static void lcd_processSequence(char* str)
 {
-	clcd_display_init();
+  char* c = NULL;
+  int result = 0;
+  uint32_t len;
+
+  BUG_ON(str == NULL);
+
+  while(*str != '\0') {
+
+    // skip whitespace
+    while(*str == ' ') {
+      str++;
+    }
+
+    c = str;
+
+    // find end of command
+    while(*str != ',' && *str != '\0') {
+      str++;
+    }
+
+    len = (str-c);
+
+    if (*str == ',') {
+      str++;
+    }
+
+    switch (*c++) {
+
+      case 'v':
+        result = checkVersion(c, len-1);
+        break;
+
+      // sequence control command (pca9532)
+      case 'c':
+        execSeqCtrl(c, len-1);
+        break;
+
+      // delay
+      case 'd':
+        //execDelay(c, len-1);
+        mdelay(str_to_uint(c, len-1));
+        break;
+
+      // open lcd (init LCD controller)
+      case 'o':
+//        if (lcdParams != NULL) {
+//          *pDev = lcd_open(CLCDC, (int32_t)lcdParams);
+//        }
+//        else {
+//          result = LCDB_RESULT_INVALID_ARG;
+//        }
+        break;
+    }
+
+    if (result != 0) {
+      break;
+    }
+  }
+}
 
-	/* Enable the backlight */
-#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
-	gpio_set_value(BKL_POW_GPIO, 0);
-#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
-	gpio_set_value(BKL_POW_GPIO, 1);
-#endif
+static void lpc32xx_clcd_disable(struct clcd_fb *fb)
+{
+    /* Disable the backlight */
+  if (lpc32xx_lcd_parameters != NULL)
+  {
+    lcd_processSequence(lpc32xx_lcd_parameters->power_down_seq);
+  }
+  else
+  {
+    gpio_set_value(BKL_POW_GPIO, 1);
+  }
+}
+
+static void lpc32xx_clcd_enable(struct clcd_fb *fb)
+{
+  if (lpc32xx_lcd_parameters != NULL)
+  {
+    lcd_processSequence(lpc32xx_lcd_parameters->init_seq);
+  }
+  else
+  {
+    clcd_display_init();
+    gpio_set_value(BKL_POW_GPIO, 0);
+  }
 }
 
 struct clcd_board lpc32xx_clcd_data = {
-#if defined (CONFIG_EA3250_QVGA_3_2_LCD)
-	.name = "Embedded Artists 3.2 inch LCD",
-#elif defined (CONFIG_EA3250_QVGA_2_8_OLED)
-	.name = "Embedded Artists 2.8 inch OLED",
-#else
-	.name = "Unknown Display",
-#endif
+    .name = "Default 3.2 inch LCD",
 	.check = clcdfb_check,
 	.decode = clcdfb_decode,
-	.disable = clcd_disable,
-	.enable = clcd_enable,
+	.disable = lpc32xx_clcd_disable,
+	.enable = lpc32xx_clcd_enable,
 	.setup = lpc32xx_clcd_setup,
 	.mmap = lpc32xx_clcd_mmap,
 	.remove = lpc32xx_clcd_remove,
@@ -572,7 +1134,7 @@ struct amba_device lpc32xx_clcd_device = {
 	.dma_mask = ~0,
 	.irq = {IRQ_LPC32XX_LCD, NO_IRQ},
 };
-#endif
+
 
 /*
  * SPI LCDC Driver Probe function
@@ -614,11 +1176,75 @@ static struct spi_driver ea3250_spi_lcdc_driver = {
 
 void __init ea3250_spi_lcdc_drv_init(void)
 {
-	spi_register_driver(&ea3250_spi_lcdc_driver);
+  if (lpc32xx_lcd_parameters == NULL)
+  {
+    spi_register_driver(&ea3250_spi_lcdc_driver);
+  }
 }
+#endif //defined (CONFIG_FB_ARMCLCD)
 
 #if defined (CONFIG_MMC_ARMMMCI)
 
+static int card_inserted = 1;
+
+static int card_detect_thread(void __iomem* d)
+{
+    int err = 0;
+    struct i2c_adapter *adap;
+    struct i2c_client *client;
+    u8 data = 0;
+
+    while (!kthread_should_stop()) {
+        adap = i2c_get_adapter(0);
+
+        if (!adap) {
+            set_current_state(TASK_INTERRUPTIBLE);
+            schedule_timeout(HZ);
+
+            continue;
+        }
+
+        list_for_each_entry(client, &adap->userspace_clients, detected) {
+            if (client->addr == I2C_PCA9532_ADDR) {
+
+                i2c_put_adapter(adap);
+
+                /* select input0 register */
+                data = 0;
+                err = i2c_master_send(client, (char*)&data ,1);
+
+                /* read value from register */
+                err = i2c_master_recv(client, (char*)&data, 1);
+
+                /* LED4 input on PCA9532 is connected to card detect (active low) */
+                card_inserted = ((data & 0x10) == 0);
+
+                break;
+            }
+        }
+
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(HZ);
+    }
+
+    return 0;
+}
+
+static struct task_struct *cd_thread;
+
+static void card_detect_start(void)
+{
+    cd_thread = kthread_run(card_detect_thread, NULL, "card-detect");
+    if (IS_ERR(cd_thread)) {
+        printk(KERN_INFO "Failed to start card detect thread\n");
+    }
+}
+
+static void card_detect_stop(void)
+{
+    kthread_stop(cd_thread);
+}
+
 /*
  * Returns !0 when card is removed, 0 when present
  */
@@ -629,7 +1255,7 @@ unsigned int mmc_card_detect(struct device *dev)
 	 * status over the I2C bus, from PCA9532 pin 8 (LED4). For now, simply
 	 * indicate that a card is always present.
 	*/
-	return 0;
+	return card_inserted;
 }
 
 /*
@@ -638,11 +1264,15 @@ unsigned int mmc_card_detect(struct device *dev)
 void mmc_power_enable(int enable)
 {
 	if (enable != 0) {
+	    card_detect_start();
+
 		/* active low */
 		gpio_set_value(MMC_POWER_GPIO,0);
 	}
 	else {
-		gpio_set_value(MMC_POWER_GPIO,0);
+	    card_detect_stop();
+
+		gpio_set_value(MMC_POWER_GPIO,1);
 	}
 }
 
@@ -670,7 +1300,7 @@ struct mmci_platform_data lpc32xx_plat_data = {
 	 * Callback function, used by MMC driver in case 'gpio_cd'
 	 * equals -ENOSYS
 	 */
-	//.status		= mmc_card_detect,
+	.status		= mmc_card_detect,
 };
 
 /*
@@ -849,7 +1479,7 @@ static struct platform_device lpc32xx_net_device = {
 /*
  * I2C devices support
  */
-#if defined (CONFIG_LEDS_PCA9532) || defined (CONFIG_AT24)
+#if defined (CONFIG_LEDS_PCA9532) || defined (CONFIG_EEPROM_AT24) || defined (CONFIG_FB_ARMCLCD)
 	static struct i2c_board_info __initdata ea3250_i2c_board_info [] = {
 #if defined (CONFIG_LEDS_PCA9532)
 		{
@@ -857,7 +1487,16 @@ static struct platform_device lpc32xx_net_device = {
 			.platform_data = &ea3250_leds,
 		},
 #endif
-#if defined (CONFIG_AT24)
+#if defined (CONFIG_FB_ARMCLCD)
+		{
+			/* 8Kb Configuration EEPROM on display board */
+			I2C_BOARD_INFO("ea_i2c_disp_cfg", LCDB_CONFIG_EEPROM_I2C_ADDR),
+		},
+		{
+			I2C_BOARD_INFO("ea_i2c_video", LCDB_PCA9532_I2C_ADDR),
+		},
+#endif
+#if defined (CONFIG_EEPROM_AT24)
 		{
 			I2C_BOARD_INFO("24c256", I2C_24LC256_ADDR),
 		},
@@ -886,7 +1525,6 @@ static struct platform_device* ea3250_devs[] __initdata = {
 	&lpc32xx_asoc_plat_device,
 };
 
-extern void __init ea3250_spi_lcdc_drv_init(void);
 
 /*
  * Board specific functions
@@ -971,18 +1609,21 @@ void __init ea3250_board_init(void)
 	/* Add platform devcies */
 	platform_add_devices(ea3250_devs, ARRAY_SIZE(ea3250_devs));
 
-	/* Register SPI driver */
-	ea3250_spi_lcdc_drv_init();
-
 	/* Test clock needed for UDA1380 initial init */
 	__raw_writel(LPC32XX_CLKPWR_TESTCLK2_SEL_MOSC |
 			LPC32XX_CLKPWR_TESTCLK_TESTCLK2_EN,
 			LPC32XX_CLKPWR_TEST_CLK_SEL);
 
-#if defined (CONFIG_LEDS_PCA9532) || defined (CONFIG_AT24)
+#if defined (CONFIG_LEDS_PCA9532) || defined (CONFIG_EEPROM_AT24) || defined (CONFIG_FB_ARMCLCD)
 	i2c_register_board_info(0, ea3250_i2c_board_info,
 			ARRAY_SIZE(ea3250_i2c_board_info));
 #endif
+
+	/* Register the I2C driver for LCD */
+	init_ea_i2c_video();
+
+	/* Register SPI driver for LCD */
+	ea3250_spi_lcdc_drv_init();
 }
 
 static int __init lpc32xx_display_uid(void)
-- 
1.7.0.4


From 0772755e05778cddd1e0a856576bd4872ef0b233 Mon Sep 17 00:00:00 2001
From: Bangaragiri G <bangaragiri.g@nxp.com>
Date: Fri, 12 Apr 2013 09:30:13 +0530
Subject: [PATCH 10/10] usb: gadget: lpc32xx_udc: Fix compatibility with STOTG04

The STOTG04 is an replacement for ISP1301.

Most of the registers on STOTG04 are the same as on ISP1301, but the
register ISP1301_I2C_OTG_CONTROL_2 (address 0x10) doesn't exist on the
ST part.

This is a work around for this by using the interrupt source register
that
should behave the same on both parts and has the needed information.

Tested-by: Roland Stigge <stigge@antcom.de>
Signed-off-by: Alexandre Pereira da Silva <aletes.xgr@gmail.com>
Signed-off-by: Felipe Balbi <balbi@ti.com>
---
 drivers/usb/gadget/lpc32xx_udc.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/usb/gadget/lpc32xx_udc.c b/drivers/usb/gadget/lpc32xx_udc.c
index cd0605c..2fd31f7 100644
--- a/drivers/usb/gadget/lpc32xx_udc.c
+++ b/drivers/usb/gadget/lpc32xx_udc.c
@@ -2671,10 +2671,10 @@ static void vbus_work(struct work_struct *work)
 		i2c_write(~0, ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR);
 
 		/* Get the VBUS status from the transceiver */
-		value = i2c_read(ISP1301_I2C_OTG_CONTROL_2);
+		value = i2c_read(ISP1301_I2C_INTERRUPT_SOURCE);
 
 		/* VBUS on or off? */
-		if (value & OTG_B_SESS_VLD)
+		if (value & INT_SESS_VLD)
 			udc->vbus = 1;
 		else
 			udc->vbus = 0;
-- 
1.7.0.4

