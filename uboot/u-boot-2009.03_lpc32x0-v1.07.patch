From 6326683f6dacbfbffef7cfa52c3153f901d45320 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:45:31 -0700
Subject: [PATCH 01/28] Initial release of u-boot for Phytec 3250 board

---
 Makefile                         |    7 +
 board/phy3250/Makefile           |   52 ++
 board/phy3250/config.mk          |   37 +
 board/phy3250/lowlevel_init.S    |   63 ++
 board/phy3250/lowlevelsys_init.c |  225 +++++
 board/phy3250/nand.c             |  190 ++++
 board/phy3250/net.c              |  553 ++++++++++++
 board/phy3250/phy3250.c          |  220 +++++
 board/phy3250/phy3250_prv.h      |  153 ++++
 board/phy3250/u-boot.lds         |   56 ++
 cpu/arm926ejs/lpc3250/Makefile   |   45 +
 cpu/arm926ejs/lpc3250/clkpwr.c   |  337 +++++++
 cpu/arm926ejs/lpc3250/config.mk  |    6 +
 cpu/arm926ejs/lpc3250/cpu.c      |  111 +++
 cpu/arm926ejs/lpc3250/serial.c   |  226 +++++
 include/configs/phy3250.h        |  244 +++++
 include/lpc3250.h                | 1817 ++++++++++++++++++++++++++++++++++++++
 17 files changed, 4342 insertions(+), 0 deletions(-)
 create mode 100644 board/phy3250/Makefile
 create mode 100644 board/phy3250/config.mk
 create mode 100644 board/phy3250/lowlevel_init.S
 create mode 100644 board/phy3250/lowlevelsys_init.c
 create mode 100644 board/phy3250/nand.c
 create mode 100644 board/phy3250/net.c
 create mode 100644 board/phy3250/phy3250.c
 create mode 100644 board/phy3250/phy3250_prv.h
 create mode 100644 board/phy3250/u-boot.lds
 create mode 100644 cpu/arm926ejs/lpc3250/Makefile
 create mode 100644 cpu/arm926ejs/lpc3250/clkpwr.c
 create mode 100644 cpu/arm926ejs/lpc3250/config.mk
 create mode 100644 cpu/arm926ejs/lpc3250/cpu.c
 create mode 100644 cpu/arm926ejs/lpc3250/serial.c
 create mode 100644 include/configs/phy3250.h
 create mode 100644 include/lpc3250.h

diff --git a/Makefile b/Makefile
index 3d0b986..7b6ae40 100644
--- a/Makefile
+++ b/Makefile
@@ -2708,6 +2708,13 @@ at91sam9rlek_config	:	unconfig
 	fi;
 	@$(MKCONFIG) -a at91sam9rlek arm arm926ejs at91sam9rlek atmel at91
 
+#########################################################################
+## NXP ARM926EJ-S Systems
+#########################################################################
+
+phy3250_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs phy3250 NULL lpc3250
+
 ########################################################################
 ## ARM Integrator boards - see doc/README-integrator for more info.
 integratorap_config	\
diff --git a/board/phy3250/Makefile b/board/phy3250/Makefile
new file mode 100644
index 0000000..3c0d392
--- /dev/null
+++ b/board/phy3250/Makefile
@@ -0,0 +1,52 @@
+#
+# Copyright (C) 2008 by NXP Semiconductors
+# All rights reserved.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= phy3250.o nand.o net.o
+COBJS	+= lowlevelsys_init.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/phy3250/config.mk b/board/phy3250/config.mk
new file mode 100644
index 0000000..35f345b
--- /dev/null
+++ b/board/phy3250/config.mk
@@ -0,0 +1,37 @@
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# Phytec 3250 board with or without S1L
+#
+
+#
+# 64 or 128 MB SDRAM @ 0x80000000
+#
+# Linux-Kernel is @ 0x80008000, entry 0x80008000
+# params @ 0x80000100
+# optionally with a ramdisk at 0x80300000
+#
+# we load ourself to 0x00000000 or 0x83FC0000
+#
+# download area is 0x80f00000
+#
+
+TEXT_BASE = 0x83FC0000
+
diff --git a/board/phy3250/lowlevel_init.S b/board/phy3250/lowlevel_init.S
new file mode 100644
index 0000000..a589735
--- /dev/null
+++ b/board/phy3250/lowlevel_init.S
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: Phytec 3250 board low level init code
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+#define IRAM_STK_TEMP 0x0003C000
+.globl phy3250_sys_init
+.globl dcache_kill
+
+.globl lowlevel_init
+lowlevel_init:
+	/*
+	 * Setup basic stack and save return address
+	 */
+	ldr	sp, =IRAM_STK_TEMP
+	stmia	sp, {lr}
+
+	/*
+	 * Initialize Phytec 3250 board
+	 */
+	bl	phy3250_sys_init
+
+	ldmia	sp, {r0}
+	mov	pc, r0
+
+dcache_kill:
+	/*
+	 * The data cache may have been enabled when booting from
+	 * S1l, so disable it now to prevent problems.
+	 */
+flush1:
+	mrc	p15, 0, r15, c7, c10, 3
+	bne	flush1
+	mcr	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #4
+	mrc	p15, 0, r0, c1, c0, 0
+	mov	pc, lr
+
diff --git a/board/phy3250/lowlevelsys_init.c b/board/phy3250/lowlevelsys_init.c
new file mode 100644
index 0000000..fd2da9a
--- /dev/null
+++ b/board/phy3250/lowlevelsys_init.c
@@ -0,0 +1,225 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: Phytec 3250 board support functions
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <configs/phy3250.h>
+#include <asm/mach-types.h>
+#include <lpc3250.h>
+#include <net.h>
+#include "phy3250_prv.h"
+
+PHY_HW_T phyhwdesc;
+
+static int ssp_read(void *buffer,
+			int max_fifo)
+{
+	volatile unsigned long tmp1;
+	int count = 0;
+	u_char *data8 = (u_char *) buffer;
+
+	while ((max_fifo > 0) && ((SSP0->sr & SSP_SR_RNE) != 0))
+	{
+		tmp1 = SSP0->data;
+		*data8 = (u_char) tmp1;
+		data8++;
+
+		/* Increment data count and decrement buffer size count */
+		count++;
+		max_fifo--;
+	}
+
+	return count;
+}
+
+static int ssp_write(void *buffer,
+                 int n_fifo)
+{
+	int count = 0;
+	u_char *data8 = (u_char *) buffer;
+
+	/* Loop until transmit ring buffer is full or until n_bytes
+	   expires */
+	while ((n_fifo > 0) && ((SSP0->sr & SSP_SR_TNF) != 0))
+	{
+		SSP0->data = (unsigned long) * data8;
+		data8++;
+
+		/* Increment data count and decrement buffer size count */
+		count++;
+		n_fifo--;
+	}
+
+	return count;
+}
+
+static void ssp_set_clock(unsigned long target_clock)
+{
+	unsigned long control, prescale, cr0_div, cmp_clk, ssp_clk;
+
+	/* Get clock for SSP */
+	ssp_clk = sys_get_rate(CLKPWR_HCLK);
+
+	/* Find closest divider to get at or under the target frequency.
+	   Use smallest prescaler possible and rely on the divider to get
+	   the closest target frequency */
+	cr0_div = 0;
+	cmp_clk = 0xFFFFFFFF;
+	prescale = 2;
+	while (cmp_clk > target_clock)
+	{
+		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
+		if (cmp_clk > target_clock)
+		{
+			cr0_div++;
+			if (cr0_div > 0xFF)
+			{
+				cr0_div = 0;
+				prescale += 2;
+			}
+		}
+	}
+
+	/* Write computed prescaler and divider back to register */
+	control = SSP0->cr0 &= ~(SSP_CR0_SCR(0xFF));
+	SSP0->cr0 = control | SSP_CR0_SCR(cr0_div - 1);
+	SSP0->cpsr = prescale;
+}
+
+/*
+ * Initialize SSP0 for interface to the serial EEPROM
+ */
+static void phy3250_ssp0_init(void)
+{
+	volatile unsigned long tmp;
+
+	/* Enable SSP0 clock */
+	CLKPWR->clkpwr_ssp_blk_ctrl |= CLKPWR_SSPCTRL_SSPCLK0_EN;
+
+	SSP0->cr0 = (SSP_CR0_DSS(8) | SSP_CR0_FRF_SPI);
+	SSP0->cr1 |= SSP_CR1_SSP_ENABLE;
+
+	/* Empty FIFO */
+	while ((SSP0->sr & SSP_SR_RNE) != 0)
+	{
+		tmp = SSP0->data;
+	}
+
+	ssp_set_clock(500000);
+
+	/* Clear latched interrupts */
+	SSP0->icr = (SSP_ICR_RORIC | SSP_ICR_RTIC);
+
+	/* Disable interrupts */
+	SSP0->imsc = 0; // TBD (SSP_IMSC_RORIM | SSP_IMSC_RTIM | SSP_IMSC_RXIM);
+}
+
+static int phy3250_sspxfer(u_char *out,
+                               u_char *in,
+                               int bytes)
+{
+  int rbytes = 0, xfrd = 0;
+
+	/* Assert chip select */
+	GPIO->p3_outp_clr = OUTP_STATE_GPIO(5);
+	ssp_write(out, bytes);
+	while (rbytes < bytes)
+	{
+		rbytes += ssp_read(&in [rbytes], 1);
+	}
+
+	GPIO->p3_outp_set = OUTP_STATE_GPIO(5);
+	xfrd = 1;
+
+	return xfrd;
+}
+
+static u_char phy3250_sspread(int index)
+{
+	u_char datai [8], datao [8];
+	u_char byte = 0;
+
+	/* Read byte */
+	datao [0] = SEEPROM_READ;
+	datao [1] = (u_char)((index >> 8) & 0xFF);
+	datao [2] = (u_char)((index >> 0) & 0xFF);
+	datao [3] = 0xFF;
+	phy3250_sspxfer(datao, datai, 4);
+	byte = datai [3];
+
+	return byte;
+}
+
+void phy3250_get_board_info(void)
+{
+	u_char *p8;
+	int idx;
+
+	/* Initialize SSP0 */
+	phy3250_ssp0_init();
+
+	/* Read data from EEPROM - this needs to be done here as the
+	   SDRAM configuration depends on these settings. */
+	p8 = (u_char *) & phyhwdesc;
+	for (idx = 0; idx < sizeof(phyhwdesc); idx++)
+	{
+		*p8 = phy3250_sspread(PHY3250_SEEPROM_CFGOFS + idx);
+		p8++;
+	}
+
+	if (phyhwdesc.fieldvval != PHY_HW_VER_VAL)
+	{
+		/* Set some defaults */
+		phyhwdesc.dramcfg = (PHYHW_DRAM_TYPE_LPSDRAM | PHYHW_DRAM_SIZE_64M);
+		phyhwdesc.syscfg = PHYHW_SDIO_POP;
+		phyhwdesc.fieldvval = PHY_HW_VER_VAL;
+
+		/* Default MAC address in index order of 0:1:2:3:4:5 */
+		phyhwdesc.mac [0] = 0x00;
+		phyhwdesc.mac [1] = 0x01;
+		phyhwdesc.mac [2] = 0x90;
+		phyhwdesc.mac [3] = 0x00;
+		phyhwdesc.mac [4] = 0xC0;
+		phyhwdesc.mac [5] = 0x81;
+		phyhwdesc.mac [6] = 0x00;
+		phyhwdesc.mac [7] = 0x00;
+
+	}
+}
+
+/*
+ * Miscellaneous platform dependent initializations
+ */
+void phy3250_sys_init(void)
+{
+	/* Get board information to determine DRAM size and MAC address */
+	phy3250_get_board_info();
+
+#ifndef CFG_BOOT_USES1L
+	/* Initialize system including clocking, SDRAM, muxing, MMU, etc. */
+	/* TBD stubbed */
+#endif
+}
+
diff --git a/board/phy3250/nand.c b/board/phy3250/nand.c
new file mode 100644
index 0000000..bf3a57b
--- /dev/null
+++ b/board/phy3250/nand.c
@@ -0,0 +1,190 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include "lpc3250.h"
+#include <nand.h>
+#include <asm/errno.h>
+
+#define	NAND_ALE_OFFS   4
+#define	NAND_CLE_OFFS   8
+
+static void phy3250_nand_init(void)
+{
+	/* Enable clocks to the SLC NAND controller */
+	CLKPWR->clkpwr_nand_clk_ctrl = 0x05;
+
+        /* Reset SLC NAND controller & clear ECC */
+        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
+
+        /* 8-bit bus, no DMA, CE normal */
+        SLCNAND->slc_cfg = 0;
+
+        /* Interrupts disabled and cleared */
+        SLCNAND->slc_ien = 0;
+        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
+
+	/* This is optimized for a 266MHz clock rate, but will work fine for
+           rates lower then 266MHz */
+        SLCNAND->slc_tac = (SLCTAC_WDR(3) |
+                    SLCTAC_WWIDTH(10) |
+                    SLCTAC_WHOLD(3) |
+                    SLCTAC_WSETUP(4) |
+                    SLCTAC_RDR(3) |
+                    SLCTAC_RWIDTH(10) |
+                    SLCTAC_RHOLD(3) |
+                    SLCTAC_RSETUP(4));
+}
+
+static void phy3250_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+	ulong *pCMD, IO_ADDR_W;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		IO_ADDR_W = (ulong) this->IO_ADDR_W;
+		IO_ADDR_W &= ~(NAND_CLE_OFFS | NAND_ALE_OFFS);
+
+		if ( ctrl & NAND_CLE ) {
+			IO_ADDR_W |= NAND_CLE_OFFS;
+		}
+		else if ( ctrl & NAND_ALE ) {
+			IO_ADDR_W |= NAND_ALE_OFFS;
+		}
+
+		if ( ctrl & NAND_NCE ) {
+			SLCNAND->slc_cfg |= SLCCFG_CE_LOW;
+		}
+		else {
+			SLCNAND->slc_cfg &= ~SLCCFG_CE_LOW;
+		}
+
+		this->IO_ADDR_W = (void *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		pCMD = (ulong *) this->IO_ADDR_W;
+		*pCMD = cmd;
+	}
+}
+
+static int phy3250_nand_ready(struct mtd_info *mtd)
+{
+	/* Check the SLC NAND controller status */
+	return (SLCNAND->slc_stat & SLCSTAT_NAND_READY);
+}
+
+static u_char phy3250_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+	tmp32 = *pReg;
+	return (u_char) tmp32;
+}
+
+/**
+ * phy3250_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ */
+static void phy3250_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_W;
+
+	for (i=0; i<len; i++)
+		*pReg = (unsigned long) buf[i];
+}
+
+/**
+ * phy3250_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ */
+static void phy3250_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+
+	for (i=0; i<len; i++)
+	{
+		tmp32 = *pReg;
+		buf[i] = (u_char) tmp32;
+	}
+}
+
+/**
+ * nand_verify_buf - [DEFAULT] Verify chip data against buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ *
+ * Default verify function for 8bit buswith
+ */
+static int phy3250_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+
+	for (i=0; i<len; i++)
+	{
+		tmp32 = *pReg;
+		if (buf[i] != (u_char) tmp32)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	/* Initial NAND interface */
+	phy3250_nand_init();
+
+	nand->ecc.mode = NAND_ECC_SOFT;
+	nand->cmd_ctrl = phy3250_nand_hwcontrol;
+	nand->dev_ready = phy3250_nand_ready;
+	nand->chip_delay = 2000;
+
+	nand->read_byte = phy3250_read_byte;
+	nand->write_buf = phy3250_write_buf;
+	nand->read_buf = phy3250_read_buf;
+	nand->verify_buf = phy3250_verify_buf;
+
+	return 0;
+}
diff --git a/board/phy3250/net.c b/board/phy3250/net.c
new file mode 100644
index 0000000..e1c1eeb
--- /dev/null
+++ b/board/phy3250/net.c
@@ -0,0 +1,553 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: Phytec 3250 net interface support functions
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <lpc3250.h>
+#include <configs/phy3250.h>
+#include "phy3250_prv.h"
+
+static unsigned long g_dmabase;
+static unsigned long gdma_size;
+static TXRX_DESC_T *pTXDesc;
+static unsigned long *pTXStatus;
+static unsigned long pTXVBuffs [ENET_MAX_TX_PACKETS];
+static TXRX_DESC_T *pRXDesc;
+static RX_STATUS_T *pRXStatus;
+static unsigned long pRXVBuffs [ENET_MAX_RX_PACKETS];
+#ifndef USE_IRAM_FOR_ETH_BUFFERS
+static unsigned long ethbuffs[4096];
+#endif
+extern PHY_HW_T phyhwdesc;
+
+static void msDelay(unsigned long ms)
+{
+	udelay(ms * 1000);
+}
+
+//------------------------------------------------------------------------------
+static int RMII_Write (unsigned long PhyReg, unsigned long Value)
+{
+	unsigned long mst = 250;
+	int sts = 0;
+
+	// Write value at PHY address and register
+	ENETMAC->madr = (PHYDEF_PHYADDR << 8) | PhyReg;
+	ENETMAC->mwtd = Value;
+
+	// Wait for unbusy status
+	while (mst > 0)
+	{
+		if ((ENETMAC->mind & MIND_BUSY) == 0)
+		{
+			mst = 0;
+			sts = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	return sts;
+}
+
+//------------------------------------------------------------------------------
+int RMII_Read(unsigned long PhyReg, unsigned long *data) 
+{
+	unsigned long mst = 250;
+	int sts = 0;
+
+	// Read value at PHY address and register
+	ENETMAC->madr = (PHYDEF_PHYADDR << 8) | PhyReg;
+	ENETMAC->mcmd = MCMD_READ;
+
+	// Wait for unbusy status
+	while (mst > 0)
+	{
+		if ((ENETMAC->mind & MIND_BUSY) == 0)
+		{
+			mst = 0;
+			*data = ENETMAC->mrdd;
+			sts = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	ENETMAC->mcmd = 0;
+
+	return sts;
+}
+
+//------------------------------------------------------------------------------
+int HYPHYReset(void)
+{
+	int goodacc;
+	unsigned long tmp1, mst;
+
+	// Reset the PHY and wait for reset to complete
+	goodacc = RMII_Write(PHY_REG_BMCR, PHY_BMCR_RESET_BIT);
+	if (goodacc == 0)
+	{
+		return 0;
+	}
+	mst = 400;
+	goodacc = 0;
+	while (mst > 0)
+	{
+		RMII_Read(PHY_REG_BMCR, &tmp1);
+		if ((tmp1 & PHY_BMCR_RESET_BIT) == 0)
+		{
+			mst = 0;
+			goodacc = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	return goodacc;
+}
+
+//------------------------------------------------------------------------------
+int txrx_setup(void)
+{
+	int idx;
+	unsigned long *pTXStatusL, pbase1, pbase2, pbase3;
+	TXRX_DESC_T *pTXRXDesc;
+	RX_STATUS_T *pRXStatusL;
+
+	// Get physical address and size of DMA buffers
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+	g_dmabase = (unsigned long) IRAM_ETH_BUFF_BASE;
+	gdma_size = IRAM_ETH_BUFF_SIZE;
+#else
+	g_dmabase = (unsigned long) &ethbuffs;
+	gdma_size = sizeof(ethbuffs);
+#endif
+
+	// Setup base pointers
+	pbase1 = g_dmabase;     // Start of descriptors
+	pbase2 = pbase1 + 256;  // Start of statuses
+	pbase3 = pbase1 + 1024; // Start of buffers
+
+	// Setup pointers to TX structures
+	ENETMAC->txdescriptor =  pbase1;
+	ENETMAC->txstatus = pbase2;
+	ENETMAC->txdescriptornumber = (ENET_MAX_TX_PACKETS - 1);
+
+	// Save base address of TX descriptor table and TX status
+	pTXRXDesc = (TXRX_DESC_T *) pbase1;
+	pTXStatusL = (unsigned long *) pbase2;
+	pTXDesc = pTXRXDesc;
+	pTXStatus = pTXStatusL;
+
+	// Build TX descriptors
+	for (idx = 0; idx < ENET_MAX_TX_PACKETS; idx++)
+	{
+		pTXRXDesc->packet = pbase3;
+		pTXRXDesc->control = 0;
+		*pTXStatusL = 0;
+
+		// Save virtual address of buffer
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+		pTXVBuffs [idx] = (unsigned long) pbase3;
+#else
+#pragma error "NOT supported"
+#endif
+
+		// Next descriptor and status
+		pTXRXDesc++;
+		pTXStatusL++;
+		pbase1 += sizeof (TXRX_DESC_T);
+		pbase2 += sizeof (unsigned long);
+		pbase3 += ENET_MAXF_SIZE;
+	}
+
+	// Setup pointers to RX structures
+	ENETMAC->rxdescriptor = pbase1;
+	ENETMAC->rxstatus = pbase2;
+	ENETMAC->rxdescriptornumber = (ENET_MAX_RX_PACKETS - 1);
+
+	// Save base address of RX descriptor table and RX status
+	pRXDesc = pTXRXDesc;
+	pRXStatus = pRXStatusL = (RX_STATUS_T *) pTXStatusL;
+
+	// Build RX descriptors
+	for (idx = 0; idx < ENET_MAX_TX_PACKETS; idx++)
+	{
+		pTXRXDesc->packet = pbase3;
+		pTXRXDesc->control = 0x80000000 | (ENET_MAXF_SIZE - 1);
+		pRXStatusL->statusinfo = 0;
+		pRXStatusL->statushashcrc = 0;
+
+		// Save virtual address of buffer
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+		pRXVBuffs [idx] = (unsigned long) pbase3;
+#else
+#pragma error "NOT supported"
+#endif
+
+		// Next descriptor and status
+		pTXRXDesc++;
+		pRXStatusL++;
+		pbase1 += sizeof (TXRX_DESC_T);
+		pbase2 += sizeof (unsigned long);
+		pbase3 += ENET_MAXF_SIZE;
+	}
+
+    return 1;
+}
+
+//------------------------------------------------------------------------------
+int HWInit(bd_t * bd)
+{
+	int btemp, goodacc;
+	unsigned long tmp1, mst = 250;
+
+	// Enable MAC interface
+	CLKPWR->clkpwr_macclk_ctrl = (CLKPWR_MACCTRL_HRCCLK_EN |
+		CLKPWR_MACCTRL_MMIOCLK_EN | CLKPWR_MACCTRL_DMACLK_EN |
+#ifdef USE_PHY_RMII
+		CLKPWR_MACCTRL_USE_RMII_PINS);
+#else
+		CLKPWR_MACCTRL_USE_MII_PINS);
+#endif
+
+	// Set RMII management clock rate. This clock should be slower
+	// than 12.5MHz (for NXP PHYs only). For a divider of 28, the
+	// clock rate when HCLK is 150MHz will be 5.4MHz
+	ENETMAC->mcfg = MCFG_CLOCK_SELECT(MCFG_CLOCK_HOST_DIV_28);
+
+	// Reset all MAC logic
+	ENETMAC->mac1 = (MAC1_SOFT_RESET | MAC1_SIMULATION_RESET |
+		MAC1_RESET_MCS_TX | MAC1_RESET_TX | MAC1_RESET_MCS_RX |
+		MAC1_RESET_RX);
+	ENETMAC->command = (COMMAND_REG_RESET | COMMAND_TXRESET |
+		COMMAND_RXRESET);
+	msDelay(10);
+
+	// Initial MAC initialization
+	ENETMAC->mac1 = MAC1_PASS_ALL_RX_FRAMES;
+	ENETMAC->mac2 = (MAC2_PAD_CRC_ENABLE | MAC2_CRC_ENABLE);
+	ENETMAC->maxf = ENET_MAXF_SIZE;
+
+	// Maximum number of retries, 0x37 collision window, gap */
+	ENETMAC->clrt = (CLRT_LOAD_RETRY_MAX(0xF) |
+		CLRT_LOAD_COLLISION_WINDOW(0x37));
+	ENETMAC->ipgr = IPGR_LOAD_PART2(0x12);
+
+#ifdef USE_PHY_RMII
+	// RMII setup
+	ENETMAC->command = (COMMAND_RMII | COMMAND_PASSRUNTFRAME);
+	ENETMAC->supp = SUPP_RESET_RMII;
+	msDelay(10);
+#else
+	// MII setup
+	ENETMAC->command = COMMAND_PASSRUNTFRAME;
+#endif
+
+	// Reset PHY
+	goodacc = HYPHYReset();
+	if (goodacc == 0)
+	{
+		printf("ENET:Reset of PHY timed out\n");
+		return 0;
+	}
+
+	// Enable rate auto-negotiation for the link
+	if (RMII_Write(PHY_REG_BMCR,
+		(PHY_BMCR_SPEED_BIT | PHY_BMCR_AUTON_BIT)) == 0)
+	{
+		return 0;
+	}
+
+	// Wait up to 5 seconds for auto-negotiation to finish
+	mst = 5000;
+	goodacc = 1;
+	btemp = 0;
+	while (mst > 0)
+	{
+		goodacc &= RMII_Read(PHY_REG_BMSR, &tmp1);
+		if ((tmp1 & PHY_BMSR_AUTON_COMPLETE) != 0)
+		{
+			mst = 0;
+			btemp = 1;
+			printf("ENET:auto-negotiation complete\n");
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+	if ((goodacc == 0) || (btemp == 0))
+	{
+		printf("ENET:auto-negotiation failed\n");
+		return 0;
+	}
+
+	// Check link status
+	mst = 1000;
+	goodacc = 1;
+	btemp = 0;
+	while (mst > 0)
+	{
+		goodacc &= RMII_Read(PHY_REG_BMSR, &tmp1);
+		if ((tmp1 & PHY_BMSR_LINKUP_STATUS) != 0)
+		{
+			mst = 0;
+			btemp = 1;
+			printf("ENET:Link status up\n");
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+	if ((goodacc == 0) || (btemp == 0))
+	{
+		printf("ENET:Link status failure\n");
+		return 0;
+	}
+
+	// Try 100MBase/full duplex
+	goodacc = btemp = 0;
+	if ((tmp1 & PHY_BMSR_TX_FULL) != 0)
+	{
+		// Setup for full duplex and 100MBase
+		goodacc = btemp = 1;
+	}
+	else if ((tmp1 & PHY_BMSR_TX_HALF) != 0)
+	{
+		// Setup for half duplex and 100MBase
+		goodacc = 1;
+	}
+	else if ((tmp1 & PHY_BMSR_TX_HALF) != 0)
+	{
+		// Setup for full duplex and 10MBase
+		btemp = 1;
+	}
+
+	// Configure Full/Half Duplex mode
+	if (btemp == 1)
+	{
+		// 10MBase full duplex is supported
+		ENETMAC->mac2 |= MAC2_FULL_DUPLEX;
+		ENETMAC->command |= COMMAND_FULLDUPLEX;
+		ENETMAC->ipgt = IPGT_LOAD(0x15);
+		printf("ENET:FULL DUPLEX\n");
+	}
+	else
+	{
+		ENETMAC->ipgt = IPGT_LOAD(0x12);
+		printf("ENET:HALF DUPLEX\n");
+	}
+
+	// Configure 100MBit/10MBit mode
+	if (goodacc == 1)
+	{
+		// 100MBase mode
+		ENETMAC->supp = SUPP_SPEED;
+		printf("ENET:100MBase\n");
+	}
+	else
+	{
+		// 10MBase mode
+		ENETMAC->supp = 0;
+		printf("ENET:10Base\n");
+	}
+
+	// Save station address
+	ENETMAC->sa [2] = (unsigned long) (bd->bi_enetaddr[0] | (bd->bi_enetaddr[1] << 8));
+	ENETMAC->sa [1] = (unsigned long) (bd->bi_enetaddr[2] | (bd->bi_enetaddr[3] << 8));
+	ENETMAC->sa [0] = (unsigned long) (bd->bi_enetaddr[4] | (bd->bi_enetaddr[5] << 8));
+
+	// Setup TX and RX descriptors
+	txrx_setup();
+
+	// Enable broadcast and matching address packets
+	ENETMAC->rxfliterctrl = (RXFLTRW_ACCEPTUBROADCAST |
+		RXFLTRW_ACCEPTPERFECT);
+
+	// Clear and enable interrupts
+	ENETMAC->intclear = 0xFFFF;
+	ENETMAC->intenable = 0;
+
+	// Enable receive and transmit mode of MAC ethernet core
+	ENETMAC->command |= (COMMAND_RXENABLE | COMMAND_TXENABLE);
+	ENETMAC->mac1 |= MAC1_RECV_ENABLE;
+
+	// Perform a 'dummy' send of the first ethernet frame with a size of 0
+	// to 'prime' the MAC. The first packet after a reset seems to wait
+	// until at least 2 packets are ready to go.
+	goodacc = 0;
+	eth_send(&goodacc, 4);
+
+	return 1;
+}
+
+//------------------------------------------------------------------------------
+int HWDeInit(void)
+{
+	// Reset PHY
+	(void) HYPHYReset();
+
+	// Reset all MAC logic
+	ENETMAC->mac1 = (MAC1_SOFT_RESET | MAC1_SIMULATION_RESET |
+		MAC1_RESET_MCS_TX | MAC1_RESET_TX | MAC1_RESET_MCS_RX |
+		MAC1_RESET_RX);
+	ENETMAC->command = (COMMAND_REG_RESET | COMMAND_TXRESET |
+		COMMAND_RXRESET);
+	msDelay(2);
+
+	// Disable MAC clocks, but keep MAC interface active
+#ifdef USE_PHY_RMII
+	CLKPWR->clkpwr_macclk_ctrl = CLKPWR_MACCTRL_USE_RMII_PINS;
+#else
+	CLKPWR->clkpwr_macclk_ctrl = CLKPWR_MACCTRL_USE_MII_PINS;
+#endif
+
+	return 1;
+}
+
+void eth_halt (void)
+{
+	HWDeInit();
+}
+
+int eth_init (bd_t * bd)
+{
+	int rc;
+
+	// Set MAC address from hardware
+	bd->bi_enetaddr[0] = phyhwdesc.mac[0];	bd->bi_enetaddr[1] = phyhwdesc.mac[1];	bd->bi_enetaddr[2] = phyhwdesc.mac[2];	bd->bi_enetaddr[3] = phyhwdesc.mac[3];	bd->bi_enetaddr[4] = phyhwdesc.mac[4];	bd->bi_enetaddr[5] = phyhwdesc.mac[5];
+	printf ("\tHW MAC address:  "
+		"%02X:%02X:%02X:%02X:%02X:%02X\n",
+		bd->bi_enetaddr[0], bd->bi_enetaddr[1],
+		bd->bi_enetaddr[2], bd->bi_enetaddr[3],
+		bd->bi_enetaddr[4], bd->bi_enetaddr[5] );
+
+	rc = HWInit(bd);
+
+	// De-init if an error occurred
+	if (rc == 0)
+	{
+		printf ("ENET init failure\n");
+		HWDeInit();
+	}
+
+	return 0;
+}
+
+/* Get a data block via Ethernet */
+int eth_rx (void)
+{
+	unsigned long idx, length;
+
+	// Determine if a frame has been received
+	length = 0;
+	idx = ENETMAC->rxconsumeindex;
+	if (ENETMAC->rxproduceindex != idx)
+	{
+		// Clear interrupt
+		ENETMAC->intclear = MACINT_RXDONEINTEN;
+
+		// Frame received, get size of RX packet
+		length = (pRXStatus[idx].statusinfo & 0x7FF);
+
+		/* Pass the packet up to the protocol layer */
+		if (length > 0)
+		{
+		        memcpy((void *) NetRxPackets[0], (void *) pRXVBuffs [idx], length);
+			NetReceive (NetRxPackets[0], (unsigned short) length);
+		}
+
+		// Return DMA buffer
+		idx++;
+		if (idx >= ENET_MAX_TX_PACKETS)
+		{
+			idx = 0;
+		}
+		ENETMAC->rxconsumeindex = (unsigned long) idx;
+	}
+
+	return (int) length;
+}
+
+/* Send a data block via Ethernet. */
+int eth_send (volatile void *packet, int length)
+{
+	unsigned long idx, cidx, fb;
+
+	// Determine number of free buffers and wait for a buffer if needed
+	fb = 0;
+	while (fb == 0)
+	{
+		idx = ENETMAC->txproduceindex;
+		cidx = ENETMAC->txconsumeindex;
+
+		if (idx == cidx)
+		{
+			// Producer and consumer are the same, all buffers are free
+			fb = ENET_MAX_TX_PACKETS;
+		}
+		else if (cidx > idx)
+		{
+			fb = (ENET_MAX_TX_PACKETS - 1) -
+				((idx + ENET_MAX_TX_PACKETS) - cidx);
+		}
+		else
+		{
+			fb = (ENET_MAX_TX_PACKETS - 1) - (cidx - idx);
+		}
+	}
+
+	// Update descriptor with new frame size
+	pTXDesc[idx].control = (length | 0x40000000);
+
+	// Move data to buffer
+	memcpy((void *) pTXVBuffs [idx], (void *) packet, length);
+
+	// Get next index for transmit data DMA buffer and descriptor
+	idx++;
+	if (idx >= ENET_MAX_TX_PACKETS)
+	{
+		idx = 0;
+	}
+	ENETMAC->txproduceindex = idx;
+
+	return 0;
+}
+
diff --git a/board/phy3250/phy3250.c b/board/phy3250/phy3250.c
new file mode 100644
index 0000000..b1a7143
--- /dev/null
+++ b/board/phy3250/phy3250.c
@@ -0,0 +1,220 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: Phytec 3250 board support functions
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <configs/phy3250.h>
+#include <asm/mach-types.h>
+#include <lpc3250.h>
+#include <net.h>
+#include "phy3250_prv.h"
+		
+DECLARE_GLOBAL_DATA_PTR;
+extern PHY_HW_T phyhwdesc;
+extern void phy3250_get_board_info(void);
+extern int dcache_kill(void);
+
+void reset_timer (void)
+{
+	unsigned int clkdlycnt, tbaseclk;
+
+	/* Reset timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR0->tcr = 0;
+	TIMER_CNTR0->tc = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR0->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR0->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
+	/* Set prescale counter value for a 1mS tick */
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	clkdlycnt = (tbaseclk / CONFIG_SYS_HZ);
+	TIMER_CNTR0->pr = clkdlycnt - 1;
+
+	/* Enable the timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_EN;
+}
+
+ulong get_timer (ulong base)
+{
+	ulong tcr = TIMER_CNTR0->tc;
+	return tcr;
+}
+
+void timer_init(void)
+{
+	/* Enable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
+		CLKPWR_TMRPWMCLK_TIMER0_EN;
+
+	reset_timer();
+}
+
+/*
+ * Use the watchdog timer to reset the system
+ */
+void reset_cpu(ulong addr)
+{
+	/* Enable the WDT clock */
+	CLKPWR->clkpwr_timer_clk_ctrl |= CLKPWR_PWMCLK_WDOG_EN;
+
+	/* Force RESETOUT_N active */
+	WDT->wdtim_mctrl = WDT_RESFRC1;
+	WDT->wdtim_ctrl = WDT_COUNT_ENAB;
+
+	/* Wait forever */
+	while (1);
+}
+
+void udelay(unsigned long usec)
+{
+	unsigned long tbaseclk;
+
+	/* Enable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
+		CLKPWR_TMRPWMCLK_TIMER1_EN;
+
+	/* Reset timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR1->tcr = 0;
+	TIMER_CNTR1->tc = 0;
+	TIMER_CNTR1->pr = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR1->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR1->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
+	/* Set prescale counter value for a 1uS tick */
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	tbaseclk = (tbaseclk / 1000000) - 1;
+	TIMER_CNTR1->pr = tbaseclk;
+
+	/* Set match for number of usecs */
+	TIMER_CNTR1->mr[0] = usec;
+
+	/* Interrupt on match 0 */
+	TIMER_CNTR1->mcr = TIMER_CNTR_MCR_MTCH(0);
+
+	/* Enable the timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_EN;
+
+	/* Loop until match occurs */
+	while ((TIMER_CNTR1->ir & TIMER_CNTR_MTCH_BIT(0)) == 0);
+
+	/* Stop timer */
+	TIMER_CNTR1->tcr = 0;
+
+	/* Disable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 &=
+		~CLKPWR_TMRPWMCLK_TIMER1_EN;
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+
+int board_init (void)
+{
+	/* Kill data cache */
+	dcache_kill();
+
+#ifdef CONFIG_SKIP_LOWLEVEL_INIT
+	/* Normally, the phy3250_get_board_info() function is called as part of the
+	   low level system initialization. For systems that don't do low level system
+	   init (S1L based), call this function here to get the board configuration
+	   structure */
+	phy3250_get_board_info();
+#endif
+
+	/* arch number of Logic-Board - MACH_TYPE_LPC3XXX */
+	gd->bd->bi_arch_number = MACH_TYPE_UBOOTSYS;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_ENV_ADDR;
+
+#ifdef CONFIG_CMD_NAND
+	/* Enable clocks to the SLC NAND controller */
+	CLKPWR->clkpwr_nand_clk_ctrl = 0x05;
+
+        /* Reset SLC NAND controller & clear ECC */
+        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
+
+        /* 8-bit bus, no DMA, CE normal */
+        SLCNAND->slc_cfg = 0;
+
+        /* Interrupts disabled and cleared */
+        SLCNAND->slc_ien = 0;
+        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
+
+	// TBD fix me with optimal timings later
+        /* Start with slowest timings possible */
+        SLCNAND->slc_tac = (SLCTAC_WDR(15) |
+                    SLCTAC_WWIDTH(15) |
+                    SLCTAC_WHOLD(15) |
+                    SLCTAC_WSETUP(15) |
+                    SLCTAC_RDR(15) |
+                    SLCTAC_RWIDTH(15) |
+                    SLCTAC_RHOLD(15) |
+                    SLCTAC_RSETUP(15));
+#endif	
+
+	return 0;
+}
+
+int dram_init (void)
+{
+	unsigned long sz = phyhwdesc.dramcfg & PHYHW_DRAM_SIZE_MASK;
+
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+
+	if (sz == PHYHW_DRAM_SIZE_16M)
+	{
+		/* 32M available */
+		gd->bd->bi_dram[0].size = 0x01000000; /* 16M */
+	}
+	else if (sz == PHYHW_DRAM_SIZE_32M)
+	{
+		/* 32M available */
+		gd->bd->bi_dram[0].size = 0x02000000; /* 32M */
+	}
+	else if (sz == PHYHW_DRAM_SIZE_64M)
+	{
+		/* 64M available */
+		gd->bd->bi_dram[0].size = 0x04000000; /* 64M */
+	}
+	else
+	{
+		/* 128M available */
+		gd->bd->bi_dram[0].size = 0x08000000; /* 128M */
+	}
+
+	return 0;
+}
+
diff --git a/board/phy3250/phy3250_prv.h b/board/phy3250/phy3250_prv.h
new file mode 100644
index 0000000..6b040f8
--- /dev/null
+++ b/board/phy3250/phy3250_prv.h
@@ -0,0 +1,153 @@
+/***********************************************************************
+ * $Id:: phy3250_board.h 970 2008-07-28 21:01:39Z wellsk               $
+ *
+ * Project: Phytec 3250 board definitions
+ *
+ * Description:
+ *     This file contains board specific information such as the
+ *     chip select wait states, and other board specific information.
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+#ifndef PHY3250_PRV_H
+#define PHY3250_PRV_H
+
+/* Structure used to define the hardware for the Phytec board */
+typedef struct
+{
+  unsigned long dramcfg;    /* DRAM config word */
+  unsigned long syscfg;     /* Configuration word */
+  /* MAC address, use lower 6 bytes only, index 0 is first byte */
+  u_char  mac[8];     /* Only the first 6 are used */
+  unsigned long rsvd [5];   /* Reserved, must be 0 */
+  unsigned long fieldvval;  /* Must be PHY_HW_VER_VAL */
+} PHY_HW_T;
+extern PHY_HW_T phyhwdesc;
+
+/* Phytec hardware verification value for configuation field */
+#define PHY_HW_VER_VAL 0x000A3250
+
+/***********************************************************************
+ * DRAM config word (dramcfg) bits
+ * Bits        Value             Description
+ * 1..0        00                Low power SDRAM
+ * 1..0        01                SDRAM
+ * 1..0        1x                Reserved
+ * 4..2        000               SDRAM 16M,  16 bits x 2 devices, 0xa5
+ * 4..2        001               SDRAM 32M,  16 bits x 2 devices, 0xa9
+ * 4..2        010               SDRAM 64M,  16 bits x 2 devices, 0xad
+ * 4..2        011               SDRAM 128M, 16 bits x 2 devices, 0xb1
+ * 31..5       0                 Reserved
+ **********************************************************************/
+/* Mask for get the DRAM type */
+#define PHYHW_DRAM_TYPE_MASK       0x3
+/* DRAM types (2 bits) */
+#define PHYHW_DRAM_TYPE_LPSDRAM    0x0
+#define PHYHW_DRAM_TYPE_SDRAM      0x1
+#define PHYHW_DRAM_TYPE_LPDDR      0x2
+#define PHYHW_DRAM_TYPE_DDR        0x3
+/* DRAM configuration mask */
+#define PHYHW_DRAM_SIZE_MASK       _SBF(2, 0x3)
+/* DRAM configurations (3 bits) */
+#define PHYHW_DRAM_SIZE_16M        _SBF(2, 0x0)
+#define PHYHW_DRAM_SIZE_32M        _SBF(2, 0x1)
+#define PHYHW_DRAM_SIZE_64M        _SBF(2, 0x2)
+#define PHYHW_DRAM_SIZE_128M       _SBF(2, 0x3)
+
+/***********************************************************************
+ * Configuation word (syscfg) bits
+ * Bits        Value             Description
+ * 0           0                 SDIO not populated
+ * 0           1                 SDIO populated
+ * 31..1       0                 Reserved
+ **********************************************************************/
+/* SDIO populated bit */
+#define PHYHW_SDIO_POP             _BIT(0)
+
+/***********************************************************************
+ * NAND timing information
+ **********************************************************************/
+/* NAND256R3A2CZA6 device */
+#define PHY_NAND_TCEA_DELAY   22222222
+#define PHY_NAND_BUSY_DELAY   10000000
+#define PHY_NAND_NAND_TA      33333333
+#define PHY_NAND_RD_HIGH      66666666
+#define PHY_NAND_RD_LOW       33333333
+#define PHY_NAND_WR_HIGH      50000000
+#define PHY_NAND_WR_LOW       25000000
+
+/***********************************************************************
+ * Functions
+ **********************************************************************/
+
+/* Serial EEPROM commands (SPI via SSP) */
+#define SEEPROM_WREN          0x06
+#define SEEPROM_WRDI          0x04
+#define SEEPROM_RDSR          0x05
+#define SEEPROM_WRSR          0x01
+#define SEEPROM_READ          0x03
+#define SEEPROM_WRITE         0x02
+
+/* Size of serial EEPROM */
+#define PHY3250_SEEPROM_SIZE  0x8000
+
+/* Offset into serial EEPROM where board configuration information is
+   saved */
+#define PHY3250_SEEPROM_CFGOFS (PHY3250_SEEPROM_SIZE - 0x100)
+
+
+
+
+// Enable the following define to setup for RMII mode
+#define USE_PHY_RMII
+
+// PHY address (configured via PHY ADRx pins)
+#define PHYDEF_PHYADDR           0x00
+
+//------------------------------------------------------------------------------
+// PHY register and bitfield data
+//------------------------------------------------------------------------------
+
+// PHY Register indices
+#define PHY_REG_BMCR             0x00        // Basic Mode Control Register
+#define PHY_REG_BMSR             0x01        // Basic Mode Status Register
+#define PHY_REG_IDR1             0x02        // PHY Identifier 1
+#define PHY_REG_IDR2             0x03        // PHY Identifier 2
+#define PHY_REG_ANAR             0x04        // Auto-Negotiation Advertisement
+#define PHY_REG_ANLPAR           0x05        // Auto-Neg. Link Partner Abitily
+#define PHY_REG_ANER             0x06        // Auto-Neg. Expansion Register
+#define PHY_REG_ANNPTR           0x07        // Auto-Neg. Next Page TX
+
+// BMCR register specific control bits
+#define PHY_BMCR_RESET_BIT         0x8000    // Reset bit
+#define PHY_BMCR_SPEED_BIT         0x2000    // 100M speed enable bit
+#define PHY_BMCR_AUTON_BIT         0x1000    // Auto-negotiation rate bit
+
+// BMSR register specific control bits
+#define PHY_BMSR_LINKUP_STATUS     0x0004    // Link up status bit
+#define PHY_BMSR_AUTON_COMPLETE    0x0020    // Auto-negotiation complete bit
+#define PHY_BMSR_10M_HALF          0x0800    // 10MBase with half duplex support
+#define PHY_BMSR_10M_FULL          0x1000    // 10MBase with full duplex support
+#define PHY_BMSR_TX_HALF           0x2000    // TX with half duplex support
+#define PHY_BMSR_TX_FULL           0x4000    // TX with full duplex support
+#define PHY_BMSR_T4_ABLE           0x8000    // T4 able
+
+// Maximum ethernet frame size, maximum RX and TX packets
+#define ENET_MAXF_SIZE             1536
+#define ENET_MAX_TX_PACKETS        16
+#define ENET_MAX_RX_PACKETS        16
+
+
+
+#endif /* PHY3250_PRV_H */
diff --git a/board/phy3250/u-boot.lds b/board/phy3250/u-boot.lds
new file mode 100644
index 0000000..6d768b3
--- /dev/null
+++ b/board/phy3250/u-boot.lds
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x83FC0000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) }
+	_end = .;
+}
diff --git a/cpu/arm926ejs/lpc3250/Makefile b/cpu/arm926ejs/lpc3250/Makefile
new file mode 100644
index 0000000..8a90671
--- /dev/null
+++ b/cpu/arm926ejs/lpc3250/Makefile
@@ -0,0 +1,45 @@
+#
+# Copyright (C) 2008 by NXP Semiconductors
+# All rights reserved.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(SOC).a
+
+COBJS-y	+= serial.o cpu.o clkpwr.o
+
+SRCS    := $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS    := $(addprefix $(obj),$(SOBJS) $(COBJS-y))
+
+all:	$(obj).depend $(LIB)
+
+$(LIB):	$(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/arm926ejs/lpc3250/clkpwr.c b/cpu/arm926ejs/lpc3250/clkpwr.c
new file mode 100644
index 0000000..dcb88f6
--- /dev/null
+++ b/cpu/arm926ejs/lpc3250/clkpwr.c
@@ -0,0 +1,337 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: LPC3250 clock and power query functions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+#include <lpc3250.h>
+
+//DECLARE_GLOBAL_DATA_PTR;
+
+
+/* CLK divider values for HCLK based on selected register value */
+static unsigned int hclkdivs[4] =
+{
+  1, 2, 4, 4
+};
+
+/* Post divider values for PLLs based on selected register value */
+static unsigned int pll_postdivs[4] =
+{
+  1, 2, 4, 8
+};
+
+/*
+ * Structure used for setting up the HCLK PLL
+ */
+typedef struct
+{
+  /* (0) = analog off, (!0) = on */
+  int analog_on;
+  /* (0) = CCO clock sent to post divider, (!0) = PLL input clock sent
+  to post div */
+  int cco_bypass_b15;
+  /* (0) = PLL out from post divider, (!0) = PLL out bypasses post
+  divider */
+  int direct_output_b14;
+  /* (0) = use CCO clock, (!0) = use FCLKOUT */
+  int fdbk_div_ctrl_b13;
+  /* Must be 1, 2, 4, or 8 */
+  int pll_p;
+  /* Must be 1, 2, 3, or 4 */
+  int pll_n;
+  /* Feedback multiplier 1-256 */
+  unsigned int pll_m;
+} CLKPWR_HCLK_PLL_SETUP_T;
+
+/*
+ * Determine if PLL rate is valid
+ */
+static unsigned int clkpwr_check_pll_setup(unsigned int ifreq,
+						CLKPWR_HCLK_PLL_SETUP_T *pllsetup)
+{
+  unsigned long long i64freq, p, m, n, fcco, fref, cfreq;
+  int mode;
+
+  /* PLL requirements */
+  /* ifreq must be >= 1MHz and <= 20MHz */
+  /* FCCO must be >= 156MHz and <= 320MHz */
+  /* FREF must be >= 1MHz and <= 27MHz. */
+  /* Assume the passed input data is not valid */
+
+	fcco = fref = cfreq = 0;
+
+  /* Work with 64-bit values to prevent overflow */
+  i64freq = (unsigned long long) ifreq;
+  m = (unsigned long long) pllsetup->pll_m;
+  n = (unsigned long long) pllsetup->pll_n;
+  p = (unsigned long long) pllsetup->pll_p;
+
+  /* Get components of the PLL register */
+  mode = (pllsetup->cco_bypass_b15 << 2) |
+         (pllsetup->direct_output_b14 << 1) |
+         pllsetup->fdbk_div_ctrl_b13;
+  switch (mode)
+  {
+    case 0x0: /* Non-integer mode */
+      cfreq = (m * i64freq) / (2 * p * n);
+      fcco = (m * i64freq) / n;
+      fref = i64freq / n;
+      break;
+
+    case 0x1: /* integer mode */
+      cfreq = (m * i64freq) / n;
+      fcco = (m * i64freq) / (n * 2 * p);
+      fref = i64freq / n;
+      break;
+
+    case 0x2:
+    case 0x3: /* Direct mode */
+      cfreq = (m * i64freq) / n;
+      fcco = cfreq;
+      fref = i64freq / n;
+      break;
+
+    case 0x4:
+    case 0x5: /* Bypass mode */
+      cfreq = i64freq / (2 * p);
+      fcco = 156000000;
+      fref = 1000000;
+      break;
+
+    case 0x6:
+    case 0x7: /* Direct bypass mode */
+      cfreq = i64freq;
+      fcco = 156000000;
+      fref = 1000000;
+      break;
+  }
+
+  if ((fcco < 156000000) || (fcco > 320000000))
+  {
+    /* not a valid range */
+    cfreq = 0;
+  }
+
+  if ((fref < 1000000) || (fref > 27000000))
+  {
+    /* not a valid range */
+    cfreq = 0;
+  }
+
+  return (int) cfreq;
+}
+
+/*
+ * Get PLL values and compute PLL rate
+ */
+static unsigned int clkpwr_pll_rate_from_val(unsigned int osc_rate,
+						unsigned int val)
+{
+  CLKPWR_HCLK_PLL_SETUP_T pllcfg;
+
+  /* Get components of the PLL register */
+  pllcfg.cco_bypass_b15 = 0;
+  pllcfg.direct_output_b14 = 0;
+  pllcfg.fdbk_div_ctrl_b13 = 0;
+  if ((val & CLKPWR_HCLKPLL_CCO_BYPASS) != 0)
+  {
+    pllcfg.cco_bypass_b15 = 1;
+  }
+  if ((val & CLKPWR_HCLKPLL_POSTDIV_BYPASS) != 0)
+  {
+    pllcfg.direct_output_b14 = 1;
+  }
+  if ((val & CLKPWR_HCLKPLL_FDBK_SEL_FCLK) != 0)
+  {
+    pllcfg.fdbk_div_ctrl_b13 = 1;
+  }
+  pllcfg.pll_m = 1 + ((val >> 1) & 0xFF);
+  pllcfg.pll_n = 1 + ((val >> 9) & 0x3);
+  pllcfg.pll_p = pll_postdivs[((val >> 11) & 0x3)];
+
+  return clkpwr_check_pll_setup(osc_rate, &pllcfg);
+}
+
+/*
+ * Get PLL rate from USB or HCLK PLL
+ */
+static unsigned int clkpwr_pll_rate(unsigned int osc_rate,
+				unsigned int *pPllreg)
+{
+  return clkpwr_pll_rate_from_val(osc_rate, *pPllreg);
+}
+
+/*
+ * Clock rate fetch function
+ */
+unsigned int sys_get_rate(CLKPWR_BASE_CLOCK_T clkid)
+{
+	unsigned int sys_clk, ddr_clock, ddr_hclk_div, hclkpll_clk;
+	unsigned int periph_clk, tmp, hclk1_clk, arm1_clk;
+	unsigned int hclk_clk, arm_clk, clkrate;
+
+	/* Is PLL397 oscillator being used? */
+	if ((CLKPWR->clkpwr_sysclk_ctrl & CLKPWR_SYSCTRL_USEPLL397) != 0)
+	{
+		/* PLL397 is used */
+		sys_clk = CLOCK_OSC_FREQ * 397;
+	}
+	else
+	{
+		sys_clk = MAIN_OSC_FREQ;
+	}
+
+	/* Compute HCLK DDR divider */
+	ddr_hclk_div = 0;
+	if ((CLKPWR->clkpwr_sdramclk_ctrl & CLKPWR_SDRCLK_USE_DDR) != 0)
+	{
+		/* DDR is being used */
+		if ((CLKPWR->clkpwr_hclk_div & CLKPWR_HCLKDIV_DDRCLK_NORM) != 0)
+		{
+			ddr_hclk_div = 1;
+		}
+		else if ((CLKPWR->clkpwr_hclk_div &
+			CLKPWR_HCLKDIV_DDRCLK_HALF) != 0)
+		{
+			ddr_hclk_div = 2;
+		}
+	}
+	else
+	{
+		/* SDRAM is being used */
+		tmp = CLKPWR->clkpwr_hclk_div & CLKPWR_HCLKDIV_DIV_2POW(0x3);
+		ddr_hclk_div = hclkdivs[tmp] - 1;
+	}
+
+	/* Is the device in run mode? */
+	if ((CLKPWR->clkpwr_pwr_ctrl & CLKPWR_SELECT_RUN_MODE) != 0)
+	{
+		/* In run mode */
+
+		/* Compute HCLK PLL rate */
+		hclkpll_clk = clkpwr_pll_rate(sys_clk,
+			(unsigned int *) &CLKPWR->clkpwr_hclkpll_ctrl);
+
+		/* Base DDR rate */
+		ddr_clock = hclkpll_clk;
+
+		/* Base peripheral clock rate */
+		tmp = 1 + ((CLKPWR->clkpwr_hclk_div >> 2) & 0x1F);
+		periph_clk = hclkpll_clk / tmp;
+
+		/* Base HCLK rate (when not using peripheral clock */
+		hclk1_clk = hclkpll_clk /
+			hclkdivs[CLKPWR_HCLKDIV_DIV_2POW(CLKPWR->clkpwr_hclk_div)];
+
+		/* Base ARM clock (when not using peripheral clock */
+		arm1_clk = hclkpll_clk;
+	}
+	else
+	{
+		/* In direct-run mode */
+
+		/* Base DDR rate */
+		ddr_clock = sys_clk;
+
+		/* Base peripheral clock rate */
+		periph_clk = sys_clk;
+
+		/* Base HCLK rate (when not using peripheral clock */
+		hclk1_clk = sys_clk;
+
+		/* Base ARM clock (when not using peripheral clock */
+		arm1_clk = sys_clk;
+	}
+
+	/* Compute SDRAM/DDR clock */
+	ddr_clock = ddr_clock / (ddr_hclk_div + 1);
+
+	/* Compute HCLK and ARM clock rates */
+	if ((CLKPWR->clkpwr_pwr_ctrl & CLKPWR_CTRL_FORCE_PCLK) != 0)
+	{
+		/* HCLK and ARM clock run from peripheral clock */
+		hclk_clk = periph_clk;
+		arm_clk = periph_clk;
+	}
+	else
+	{
+		/* Normal clock is used for HCLK and ARM clock */
+		hclk_clk = hclk1_clk;
+		arm_clk = arm1_clk;
+	}
+
+	/* Determine rates */
+	switch (clkid)
+	{
+		case CLKPWR_MAINOSC_CLK:
+			/* Main oscillator rate */
+			clkrate = MAIN_OSC_FREQ;
+			break;
+
+		case CLKPWR_RTC_CLK:
+			/* RTC oscillator rate */
+			clkrate = CLOCK_OSC_FREQ;
+			break;
+
+		case CLKPWR_SYSCLK:
+			/* System oscillator (main osc or PLL397) rate */
+			clkrate = sys_clk;
+			break;
+
+		case CLKPWR_ARM_CLK:
+			clkrate = arm_clk;
+			break;
+
+		case CLKPWR_HCLK:
+			clkrate = hclk_clk;
+			break;
+
+		case CLKPWR_PERIPH_CLK:
+			clkrate = periph_clk;
+			break;
+
+		case CLKPWR_USB_HCLK_SYS:
+			clkrate = 0; // Not supported
+			break;
+
+		case CLKPWR_48M_CLK:
+			clkrate = 0; // Not supported
+			break;
+
+		case CLKPWR_DDR_CLK:
+			clkrate = ddr_clock;
+			break;
+
+		case CLKPWR_MSSD_CLK:
+			clkrate = hclk_clk;
+			break;
+
+		default:
+			clkrate = 0;
+			break;
+	}
+
+	return clkrate;
+}
+
+
+
diff --git a/cpu/arm926ejs/lpc3250/config.mk b/cpu/arm926ejs/lpc3250/config.mk
new file mode 100644
index 0000000..56e20a1
--- /dev/null
+++ b/cpu/arm926ejs/lpc3250/config.mk
@@ -0,0 +1,6 @@
+PLATFORM_CPPFLAGS += -march=armv5te 
+PLATFORM_CPPFLAGS += $(call cc-option,-mtune=arm926ejs,)
+
+PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8
+
+PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
diff --git a/cpu/arm926ejs/lpc3250/cpu.c b/cpu/arm926ejs/lpc3250/cpu.c
new file mode 100644
index 0000000..1372ada
--- /dev/null
+++ b/cpu/arm926ejs/lpc3250/cpu.c
@@ -0,0 +1,111 @@
+/*
+ * (C) Copyright 2002
+ * Sysgo Real-Time Solutions, GmbH <www.elinos.com>
+ * Marius Groeger <mgroeger@sysgo.de>
+ *
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * CPU specific code
+ */
+
+#include <common.h>
+#include <command.h>
+#include <arm926ejs.h>
+
+/* read co-processor 15, register #1 (control register) */
+static unsigned long read_p15_c1 (void)
+{
+	unsigned long value;
+
+	__asm__ __volatile__(
+		"mrc     p15, 0, %0, c1, c0, 0   @ read control reg\n"
+		: "=r" (value)
+		:
+		: "memory");
+
+#ifdef MMU_DEBUG
+	printf ("p15/c1 is = %08lx\n", value);
+#endif
+	return value;
+}
+
+/* write to co-processor 15, register #1 (control register) */
+static void write_p15_c1 (unsigned long value)
+{
+#ifdef MMU_DEBUG
+	printf ("write %08lx to p15/c1\n", value);
+#endif
+	__asm__ __volatile__(
+		"mcr     p15, 0, %0, c1, c0, 0   @ write it back\n"
+		:
+		: "r" (value)
+		: "memory");
+
+	read_p15_c1 ();
+}
+
+static void cp_delay (void)
+{
+	volatile int i;
+
+	/* copro seems to need some delay between reading and writing */
+	for (i = 0; i < 100; i++);
+}
+
+/* See also ARM Ref. Man. */
+#define C1_MMU		(1<<0)		/* mmu off/on */
+#define C1_ALIGN	(1<<1)		/* alignment faults off/on */
+#define C1_DC		(1<<2)		/* dcache off/on */
+#define C1_BIG_ENDIAN	(1<<7)	/* big endian off/on */
+#define C1_SYS_PROT	(1<<8)		/* system protection */
+#define C1_ROM_PROT	(1<<9)		/* ROM protection */
+#define C1_IC		(1<<12)		/* icache off/on */
+#define C1_HIGH_VECTORS	(1<<13)	/* location of vectors: low/high addresses */
+#define RESERVED_1	(0xf << 3)	/* must be 111b for R/W */
+
+/* It makes no sense to use the dcache if the MMU is not enabled */
+void dcache_enable (void)
+{
+	ulong reg;
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	write_p15_c1 (reg | C1_DC);
+}
+
+void dcache_disable (void)
+{
+	ulong reg;
+
+	reg = read_p15_c1 ();
+	cp_delay ();
+	reg &= ~C1_DC;
+	write_p15_c1 (reg);
+}
+
+int dcache_status (void)
+{
+	return (read_p15_c1 () & C1_DC) != 0;
+}
+
diff --git a/cpu/arm926ejs/lpc3250/serial.c b/cpu/arm926ejs/lpc3250/serial.c
new file mode 100644
index 0000000..7739d8e
--- /dev/null
+++ b/cpu/arm926ejs/lpc3250/serial.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: LPC3250 serial port functions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <common.h>
+#include <lpc3250.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/*
+ * ABS function
+ */
+int serial_abs(int v1, int v2)
+{
+  if (v1 > v2)
+  {
+    return v1 - v2;
+  }
+
+  return v2 - v1;
+}
+
+/*
+ * Find the best UART clock divider to get the desired port rate
+ */
+void serial_getdiv(u32 baudrate,
+			unsigned int *xdiv,
+			unsigned int *ydiv)
+{
+	unsigned int clkrate, savedclkrate, diff, basepclk;
+	int idxx, idyy;
+
+	/* Get the clock rate for the UART block */
+	basepclk = sys_get_rate(CLKPWR_PERIPH_CLK) >> 4;
+
+	/* Find the best divider */
+	*xdiv = *ydiv = 0;
+	savedclkrate = 0;
+	diff = 0xFFFFFFFF;
+	for (idxx = 1; idxx < 0xFF; idxx++)
+	{
+		for (idyy = idxx; idyy < 0xFF; idyy++)
+		{
+			clkrate = (basepclk * idxx) / idyy;
+			if (serial_abs(clkrate, baudrate) < diff)
+			{
+				diff = serial_abs(clkrate, baudrate);
+				savedclkrate = clkrate;
+				*xdiv = idxx;
+				*ydiv = idyy;
+			}
+		}
+	}
+}
+
+void serial_setbrg (void)
+{
+	unsigned int xdiv, ydiv;
+
+	/* Find closest baud rate for desired clock frequency */
+	serial_getdiv(gd->baudrate, &xdiv, &ydiv);
+
+	/* Set clock x/y divider for the UART */
+	if (CFG_UART_SEL == UART3)
+	{
+		CLKPWR->clkpwr_uart3_clk_ctrl =
+			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+	}
+	else if (CFG_UART_SEL == UART4)
+	{
+		CLKPWR->clkpwr_uart4_clk_ctrl =
+			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+	}
+	else if (CFG_UART_SEL == UART5)
+	{
+		CLKPWR->clkpwr_uart5_clk_ctrl =
+			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+	}
+	else if (CFG_UART_SEL == UART6)
+	{
+		CLKPWR->clkpwr_uart6_clk_ctrl =
+			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+	}
+}
+
+/*
+ * Initialise the serial port with the given baudrate. The settings
+ * are always 8 data bits, no parity, 1 stop bit, no start bits.
+ *
+ */
+int serial_init (void)
+{
+	volatile unsigned int tmp32;
+	int unum;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+
+	/* UART setup */
+
+	/* Enable UART system clock */
+	if (puregs == UART3)
+	{
+		CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART3_EN;
+		unum = 3;
+	}
+	else if (puregs == UART4)
+	{
+		CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART4_EN;
+		unum = 4;
+	}
+	else if (puregs == UART5)
+	{
+		CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART5_EN;
+		unum = 5;
+	}
+	else if (puregs == UART6)
+	{
+		CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART6_EN;
+		unum = 6;
+	}
+
+	/* Place UART in autoclock mode */
+	tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum);
+	UARTCNTL->clkmode = (tmp32 |
+		UART_CLKMODE_LOAD(UART_CLKMODE_AUTO, (unum)));
+
+	/* UART baud rate generator isn't used, so just set it to divider
+	   by 1 */
+	puregs->lcr |= UART_LCR_DIVLATCH_EN;
+	puregs->dll_fifo = 1;
+	puregs->dlm_ier = 0;
+	puregs->lcr &= ~UART_LCR_DIVLATCH_EN;
+
+	/* Setup default UART state for N81 with FIFO mode */
+	puregs->lcr = UART_LCR_WLEN_8BITS;
+
+	/* set baudrate */
+	serial_setbrg();
+
+	/* Clear FIFOs and set FIFO level */
+	puregs->iir_fcr = (UART_FCR_RXFIFO_TL16 |
+		UART_FCR_TXFIFO_TL0 | UART_FCR_FIFO_CTRL |
+		UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
+		UART_FCR_RXFIFO_FLUSH);
+	tmp32 = puregs->iir_fcr;
+	tmp32 = puregs->lsr;
+
+	/* Use automatic clocking */
+//	tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum + 3);
+//	UARTCNTL->clkmode = tmp32 | UART_CLKMODE_LOAD(
+//        	UART_CLKMODE_AUTO, (unum + 3));  // TBD delete me
+
+	return 0;
+}
+
+/*
+ * Read a single byte from the serial port.
+ */
+int serial_getc (void)
+{
+	/* Wait for a character from the UART */
+	while ((CFG_UART_SEL->lsr & UART_LSR_RDR) == 0);
+
+	return (int) (CFG_UART_SEL->dll_fifo & 0xFF);
+}
+
+/*
+ * Output a single byte to the serial port.
+ */
+void serial_putc (const char c)
+{
+	/* Wait for FIFO to become empty */
+	while ((CFG_UART_SEL->lsr & UART_LSR_THRE) == 0);
+
+	CFG_UART_SEL->dll_fifo = (u32) c;
+
+	/* If \n, also do \r */
+	if (c == '\n')
+	{
+		serial_putc ('\r');
+	}
+}
+
+/*
+ * Test whether a character is in the RX buffer
+ */
+int serial_tstc (void)
+{
+	/* Wait for a character from the UART */
+	if ((CFG_UART_SEL->lsr & UART_LSR_RDR) == 0)
+	{
+		return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * Put a string to the UART
+ */
+void serial_puts (const char *s)
+{
+	while (*s)
+	{
+		serial_putc (*s++);
+	}
+}
+
diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
new file mode 100644
index 0000000..1bef2dc
--- /dev/null
+++ b/include/configs/phy3250.h
@@ -0,0 +1,244 @@
+/*
+ * Copyright (C) 2009 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: Phytec 3250 board configuration file
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Phytec 3250 board configuation data
+ */
+
+#ifndef __PHY3250_H__
+#define __PHY3250_H__
+
+/*
+ *
+ * Chip speific options
+ *
+ */
+
+/*
+ * Ethernet buffer support in uncached IRAM and buffer size
+ */
+#define USE_IRAM_FOR_ETH_BUFFERS
+#define IRAM_ETH_BUFF_BASE 0x08010000 /* Uncached IRAM */
+#define IRAM_ETH_BUFF_SIZE 0x00010000
+
+/*
+ * There are 2 boot options for u-boot on the Phytec 3250 board. Option 1
+ * or option 2. In either cases, u-boot does not need to be relocated.
+ *
+ * Option 1 - define CFG_BOOT_USES1L
+ * With this option, the S1L loader present in the board initializes the
+ * system (including SDRAM, MMUs, some MUX states, etc.). U-boot is loaded
+ * into an already initialized system in SDRAM at address 0x83FC0000 (the
+ * end of SDRAM in a 64M system). Because most of the system is already
+ * initialized, system init is not performed again.
+ *
+ * Option 2 - undefine CFG_BOOT_USES1L
+ * With this option, u-boot is the primary boot loader that is loaded and
+ * started from the Phytec kickstart loader (see documentation with the
+ * Phytec board for the kickstart loader). In this configuration, u-boot
+ * loads and runs from RAM at address 0x00000000 and requires complete
+ * system initialization. The kickstart loader will copy the u-boot image
+ * from FLASH starting at block 1 into IRAM and start it at address 0x0.
+ */
+#define CFG_BOOT_USES1L
+
+#ifdef CFG_BOOT_USES1L
+/*
+ * Skip low level init of MMU, SDRAM, muxing, etc. if u-boot is loaded
+ * and executed from S1L
+ */
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+/*
+ * Linux machine type
+ */
+#define MACH_TYPE_UBOOTSYS MACH_TYPE_LPC3XXX
+
+/*
+ * System UART selection, valid selections include UART3, UART4,
+ * UART5, and UART6
+ */
+#define CFG_UART_SEL UART5
+
+/*
+ * SDRAM physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS    1
+#define PHYS_SDRAM_1		0x80000000 /* SDRAM Bank #1 */
+
+/*
+ * NOR FLASH not supported
+ */
+#define CONFIG_SYS_NO_FLASH
+#undef CONFIG_ENV_IS_IN_FLASH
+
+/*
+ * 1KHz clock tick
+ */
+#define CONFIG_SYS_HZ		1000
+
+/*
+ * ARM926ejs options
+ */
+#define CONFIG_ARM926EJS	   1 /* This is an arm926ejs CPU core  */
+
+/*
+ *
+ * u-boot specific options
+ *
+ */
+
+/*
+ * Address and size of Environment Data
+ */
+#define CONFIG_ENV_IS_IN_NAND	1
+#define CONFIG_ENV_SIZE		0x4000 /* 1 block */
+#define CONFIG_ENV_OFFSET	0x168000 /* Block 90 */
+#define CONFIG_ENV_ADDR		0x80000100 /* Passed to kernel here */
+
+/*
+ * Area and size for malloc
+ */
+#define CONFIG_SYS_MALLOC_LEN (CONFIG_ENV_SIZE + 128 * 1024)
+#define CONFIG_SYS_GBL_DATA_SIZE 128
+
+/*
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE (32*1024) /* 32K stack */
+
+/*
+ * ATAG support
+ */
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+/*
+ * Default baud rate and baud rate table, console config
+ */
+#define CONFIG_CONS_INDEX	   1
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * Default load address for programs
+ */
+#define CONFIG_SYS_LOAD_ADDR	0x80100000 /* default load address */
+
+/*
+ * Default boot delay is 3 seconds
+ */
+#define CONFIG_BOOTDELAY 3
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+/*
+ * Interrupts are not supported in this boot loader
+ */
+#undef CONFIG_USE_IRQ
+
+/*
+ * Use verbose help
+ */
+#define CONFIG_SYS_LONGHELP
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_ECHO /* ECHO command */
+#define CONFIG_CMD_CACHE /* Cache support */
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_LOADB
+#define CONFIG_CMD_LOADS
+#define CONFIG_CMD_SAVES
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_ELF
+#undef CONFIG_CMD_MISC
+
+/*
+ * Prompt, command buffer
+ */
+#define	CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CONFIG_SYS_PROMPT	"uboot> "	/* Monitor Command Prompt	*/
+#define	CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+/*
+ * Default range for the memory tests
+ */
+#define CONFIG_SYS_MEMTEST_START 0x80010000
+#define CONFIG_SYS_MEMTEST_END 0x81000000
+
+/*
+ * Support for NAND FLASH, environment store in NAND at block 100
+ */
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_MAX_NAND_DEVICE 1
+#define CONFIG_SYS_NAND_BASE 0x20020000 /* SLC NAND controller */
+#define CFG_ENV_IS_IN_NAND
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Support for various capabilities
+ */
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_LOADS_BAUD_CHANGE
+
+/*
+ * Network setup
+ */
+#define CONFIG_NETMASK		   255.255.255.0
+#define CONFIG_IPADDR		   192.168.1.193
+#define CONFIG_SERVERIP		   192.168.1.51
+#define CONFIG_BOOTFILE		   "uImage"  /* File to load */
+#define CONFIG_BOOTARGS		   "console=ttyS0,115200n8 root=/dev/nfs rw nfsroot=192.168.1.51:/home/user/ltib/rootfs ip=192.168.1.193"
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+#endif  /* __PHY3250_H__*/
+
diff --git a/include/lpc3250.h b/include/lpc3250.h
new file mode 100644
index 0000000..785b1be
--- /dev/null
+++ b/include/lpc3250.h
@@ -0,0 +1,1817 @@
+/***********************************************************************
+ *
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: Definitions for LPC3250 chip
+ * @References: NXP LPC3250 User's Guide
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ ***********************************************************************/
+
+#ifndef __LPC3250_H
+#define __LPC3250_H
+
+/*
+ * AHB physical address bases used in u-boot
+ */
+#define SSP0_BASE       0x20084000 	/* SSP0 registers base */
+#define MLC_BASE	0x200A8000	/* MLC NAND Flash registers base*/
+#define ETHERNET_BASE	0x31060000	/* Ethernet ctrl register base*/
+#define EMC_BASE        0x31080000 	/* EMC registers base*/
+#define SLC_BASE	0x20020000	/* SLC NAND Flash registers base*/
+#define SD_BASE		0x20098000	/* SD card interface registers base*/
+#define DMA_BASE	0x31000000	/* DMA controller registers base*/
+
+/*
+ * FAB physical address bases used in u-boot
+ */
+#define TIMER0_BASE     0x40044000
+#define TIMER1_BASE     0x4004C000
+#define CLK_PM_BASE	0x40004000	/* System control registers base*/
+#define WDTIM_BASE	0x4003C000	/* Watchdog timer registers base*/
+#define UART_CTRL_BASE	0x40054000	/* general UART ctrl regs base*/
+#define GPIO_BASE	0x40028000	/* GPIO registers base*/
+
+/*
+ * APB physical address bases used in u-boot
+ */
+#define UART3_BASE	0x40080000	/* UART 3 registers base*/
+#define UART4_BASE	0x40088000	/* UART 4 registers base*/
+#define UART5_BASE	0x40090000	/* UART 5 registers base*/
+#define UART6_BASE	0x40098000	/* UART 6 registers base*/
+
+/*
+ * Internal memory physical address bases used in u-boot
+ */
+#define IRAM_BASE       0x08000000  	/* Internal RAM address */
+
+/*
+ * External Static Memory Bank Address Space physical address bases
+ */
+#define EMC_CS0_BASE	0xE0000000
+#define EMC_CS1_BASE	0xE1000000
+#define EMC_CS2_BASE	0xE2000000
+#define EMC_CS3_BASE	0xE3000000
+
+/*
+ * External SDRAM Memory Bank Address Space Bases
+ */
+#define EMC_DYCS0_BASE	0x80000000  	/* SDRAM DYCS0 base address */
+#define EMC_DYCS1_BASE	0xA0000000  	/* SDRAM DYCS1 base address */
+
+/*
+ * Clock and crystal information
+ */
+#define MAIN_OSC_FREQ	13000000
+#define CLOCK_OSC_FREQ	32768
+
+/* bit position macro */
+#define _BIT(n)		(0x1 << (n))
+
+#define _SBF(f,v) (((unsigned long)(v)) << (f))
+
+/*
+ * Standard UART register structures
+ */
+typedef struct
+{
+	volatile unsigned int dll_fifo;     /* UART data FIFO/holding/dll reg */
+	volatile unsigned int dlm_ier;      /* UART high divisor/int enable reg */
+	volatile unsigned int iir_fcr;      /* UART int pending/FIFO contrl reg */
+	volatile unsigned int lcr;          /* UART line control reg */
+	volatile unsigned int modem_ctrl;   /* UART modem control reg */
+	volatile unsigned int lsr;          /* UART line status reg */
+	volatile unsigned int modem_status; /* UART modem status reg */
+	volatile unsigned int rxlev;        /* UART RX FIFO level reg */
+} UART_REGS_T;
+
+/*
+ * UART control structure
+ */
+typedef struct
+{
+	volatile unsigned int ctrl;         /* General UART control register */
+	volatile unsigned int clkmode;      /* UART clock control register */
+	volatile unsigned int loop;         /* UART loopmode enable/disable */
+} UART_CNTL_REGS_T;
+
+/*
+ * UART dll and dlm register definitions
+ */
+#define UART_LOAD_DM(div)          ((div) & 0xFF)
+
+/*
+ * UART ier register definitions
+ */
+/* Bit for enabling the modem status interrupt */
+#define UART_IER_MODEM_STS         _BIT(3)
+/* Bit for enabling the RX line status interrupt(s) */
+#define UART_IER_RXLINE_STS        _BIT(2)
+/* Bit for enabling the transmit holding register empty interrupt */
+#define UART_IER_THRE              _BIT(1)
+/* Bit for enabling the receive data available (RDA) interrupt */
+#define UART_IER_RDA               _BIT(0)
+
+/*
+ * UART iir register definitions
+ */
+/* Bit for masking interrupt pending status */
+#define UART_IIR_INT_PENDING       _BIT(0)
+/* Mask for getting interrupt source */
+#define UART_IIR_INT_MASK          0xE
+/* Interrupt sources */
+#define UART_IIR_MODEM_STS         0x0
+#define UART_IIR_INTSRC_THRE       0x2
+#define UART_IIR_INTSRC_RDA        0x4
+#define UART_IIR_INTSRC_RXLINE     0x6
+#define UART_IIR_INTSRC_CTI        0xC /* Character timeout */
+/* Interrupt bits mask word */
+#define UART_IIR_INTSRC_MASK       0xE
+
+/*
+ * UART fcr register definitions
+ */
+/* Receive FIFO trigger level selections */
+#define UART_FCR_RXFIFO_TL16       0x0
+#define UART_FCR_RXFIFO_TL32       _BIT(6)
+#define UART_FCR_RXFIFO_TL48       _BIT(7)
+#define UART_FCR_RXFIFO_TL60       (_BIT(7) | _BIT(6))
+/* Transmit FIFO trigger level selections */
+#define UART_FCR_TXFIFO_TL0        0x0
+#define UART_FCR_TXFIFO_TL4        _BIT(4)
+#define UART_FCR_TXFIFO_TL8        _BIT(5)
+#define UART_FCR_TXFIFO_TL16       (_BIT(5) | _BIT(4))
+/* Enable FIFO bit - must be set with UART_FCR_FIFO_EN */
+#define UART_FCR_FIFO_CTRL         _BIT(3)
+/* Clear TX FIFO bit */
+#define UART_FCR_TXFIFO_FLUSH      _BIT(2)
+/* Clear RX FIFO bit */
+#define UART_FCR_RXFIFO_FLUSH      _BIT(1)
+/* Enable FIFO bit - must be set with UART_FCR_FIFO_CTRL */
+#define UART_FCR_FIFO_EN           _BIT(0)
+
+/*
+ * UART lcr register definitions
+ */
+/* Bit for enabling divisor latch and IER register */
+#define UART_LCR_DIVLATCH_EN       _BIT(7)
+/* Bit for enabling break transmission (forces TX low) */
+#define UART_LCR_BREAK_EN          _BIT(6)
+/* Parity selection */
+#define UART_LCR_PARITY_ODD        0x0
+#define UART_LCR_PARITY_EVEN       _BIT(4)
+#define UART_LCR_PARITY_FORCE1     _BIT(5)
+#define UART_LCR_PARITY_FORCE0     (_BIT(5) | _BIT(4))
+/* Parity selection mask */
+#define UART_LCR_PARITY_MASK       (_BIT(5) | _BIT(4))
+/* Parity enable bit */
+#define UART_LCR_PARITY_ENABLE     _BIT(3)
+/* Stop bit selection */
+#define UART_LCR_STOP1BIT          0x0
+#define UART_LCR_STOP2BITS         _BIT(2)
+/* Word length selections */
+#define UART_LCR_WLEN_5BITS        0x0
+#define UART_LCR_WLEN_6BITS        _BIT(0)
+#define UART_LCR_WLEN_7BITS        _BIT(1)
+#define UART_LCR_WLEN_8BITS        (_BIT(1) | _BIT(0))
+/* Word length mask */
+#define UART_LCR_WLEN_MASK         (_BIT(1) | _BIT(0))
+
+/*
+ * UART modem_ctrl register definitions
+ */
+/* Bit for enabling modem loopback mode */
+#define UART_MDMC_LOOPB_EN         _BIT(4)
+/* Bit for driving RTS low */
+#define UART_MDMC_RTS_LOW          _BIT(1)
+/* Bit for driving DTR low */
+#define UART_MDMC_DTR_LOW          _BIT(0)
+
+/*
+ * UART lsr register definitions
+ */
+/* Bit for masking FIFO RX error status */
+#define UART_LSR_FIFORX_ERR        _BIT(7)
+/* Bit for masking transmitter empty status */
+#define UART_LSR_TEMT              _BIT(6)
+/* Bit for masking transmit FIFO trip point status */
+#define UART_LSR_THRE              _BIT(5)
+/* Bit for masking break interrupt status */
+#define UART_LSR_BI                _BIT(4)
+/* Bit for masking framing error status */
+#define UART_LSR_FR                _BIT(3)
+/* Bit for masking parity error status */
+#define UART_LSR_PE                _BIT(2)
+/* Bit for masking RX FIFO overrun error status */
+#define UART_LSR_OE                _BIT(1)
+/* Bit for masking RX FIFO empty status */
+#define UART_LSR_RDR               _BIT(0)
+
+/*
+ * UART modem_status register definitions
+ */
+/* Bit for masking data carrier detect state */
+#define UART_MDMS_DCD              _BIT(7)
+/* Bit for masking ring indicator state */
+#define UART_MDMS_RI               _BIT(6)
+/* Bit for masking data set ready state */
+#define UART_MDMS_DSR              _BIT(5)
+/* Bit for masking clear to send state */
+#define UART_MDMS_CTS              _BIT(4)
+/* Bit for detecting state change on DCD */
+#define UART_MDMS_DCD_CHG          _BIT(3)
+/* Bit for detecting state change on RI */
+#define UART_MDMS_RI_CHG           _BIT(2)
+/* Bit for detecting state change on DSR */
+#define UART_MDMS_DSR_CHG          _BIT(1)
+/* Bit for detecting state change on CTS */
+#define UART_MDMS_CTS_CHG          _BIT(0)
+
+/*
+ * UART rxlev register definitions
+ */
+/* Macro for masking off the receive FIFO level */
+#define UART_RXLEV(n)              ((n) & 0x7F)
+
+/*
+ * UART ctrl register definitions
+*/
+/* UART3 modem control pin enable bit */
+#define UART_U3_MD_CTRL_EN         _BIT(11)
+/* IRRX6 inversion enable bit */
+#define UART_IRRX6_INV_EN          _BIT(10)
+/* IRRX6 RX mask while TX enabled enable bit */
+#define UART_HDPX_EN               _BIT(9)
+/* UART6 IRA modulator bypass bit */
+#define UART_UART6_IRDAMOD_BYPASS  _BIT(5)
+/* IRTX6 inversion enable bit */
+#define RT_IRTX6_INV_EN            _BIT(4)
+/* IRRX6 inversion enable bit */
+#define RT_IRTX6_INV_MIR_EN        _BIT(3)
+/* IR RX length, 3/16th pulse length with a 115Kbps clock */
+#define RT_RX_IRPULSE_3_16_115K    _BIT(2)
+/* IR TX length, 3/16th pulse length with a 115Kbps clock */
+#define RT_TX_IRPULSE_3_16_115K    _BIT(1)
+/* UART5 mirror route to the USB D+ and D- pins bit */
+#define UART_U5_ROUTE_TO_USB       _BIT(0)
+
+/*
+ * UART clkmode register definitions
+ */
+/* Macro return the UART clock enabled field, shifted */
+#define UART_ENABLED_CLOCKS(n)     (((n) >> 16) & 0x7F)
+/* Macro returning a selected enabled UART clock bit */
+#define UART_ENABLED_CLOCK(n, u)   (((n) >> (16 + (u))) & 0x1)
+/* Bit that indicates if any UARTS are being clocked */
+#define UART_ENABLED_CLKS_ANY      _BIT(14)
+/* Defnies for setting a IARTs clock mode */
+#define UART_CLKMODE_OFF           0x0    /* Clocks are off */
+#define UART_CLKMODE_ON            0x1    /* Clocks are on */
+#define UART_CLKMODE_AUTO          0x2    /* Clocks are automatic */
+/* Clock mode mask for a UART, for UARTs 6 to 3 only */
+#define UART_CLKMODE_MASK(u)      (0x3 << ((((u) - 3) * 2) + 4))
+/* Macro for loading a UARTs clock mode, for UARTs 6 to 3 only */
+#define UART_CLKMODE_LOAD(m, u)   ((m) << ((((u) - 3) * 2) + 4))
+
+/*
+ * Macros pointing to UART base and control registers
+ */
+#define UART3 ((UART_REGS_T *)(UART3_BASE))
+#define UART4 ((UART_REGS_T *)(UART4_BASE))
+#define UART5 ((UART_REGS_T *)(UART5_BASE))
+#define UART6 ((UART_REGS_T *)(UART6_BASE))
+#define UARTCNTL ((UART_CNTL_REGS_T *) (UART_CTRL_BASE))
+
+
+
+
+
+
+
+
+
+
+
+
+/**********************************************************************
+* Clock and Power control register structures
+**********************************************************************/
+
+/*
+ * Clock and Power control module register structure
+ */
+typedef struct
+{
+  volatile unsigned int reserved1 [5];
+  volatile unsigned int clkpwr_bootmap;
+  volatile unsigned int clkpwr_p01_er;
+  volatile unsigned int clkpwr_usbclk_pdiv;
+  volatile unsigned int clkpwr_int_er;
+  volatile unsigned int clkpwr_int_rs;
+  volatile unsigned int clkpwr_int_sr;
+  volatile unsigned int clkpwr_int_ap;
+  volatile unsigned int clkpwr_pin_er;
+  volatile unsigned int clkpwr_pin_rs;
+  volatile unsigned int clkpwr_pin_sr;
+  volatile unsigned int clkpwr_pin_ap;
+  volatile unsigned int clkpwr_hclk_div;
+  volatile unsigned int clkpwr_pwr_ctrl;
+  volatile unsigned int clkpwr_pll397_ctrl;
+  volatile unsigned int clkpwr_main_osc_ctrl;
+  volatile unsigned int clkpwr_sysclk_ctrl;
+  volatile unsigned int clkpwr_lcdclk_ctrl;
+  volatile unsigned int clkpwr_hclkpll_ctrl;
+  volatile unsigned int reserved2;
+  volatile unsigned int clkpwr_adc_clk_ctrl_1;
+  volatile unsigned int clkpwr_usb_ctrl;
+  volatile unsigned int clkpwr_sdramclk_ctrl;
+  volatile unsigned int clkpwr_ddr_lap_nom;
+  volatile unsigned int clkpwr_ddr_lap_count;
+  volatile unsigned int clkpwr_ddr_cal_delay;
+  volatile unsigned int clkpwr_ssp_blk_ctrl;
+  volatile unsigned int clkpwr_i2s_clk_ctrl;
+  volatile unsigned int clkpwr_ms_ctrl;
+  volatile unsigned int reserved4 [3];
+  volatile unsigned int clkpwr_macclk_ctrl;
+  volatile unsigned int reserved5 [4];
+  volatile unsigned int clkpwr_test_clk_sel;
+  volatile unsigned int clkpwr_sw_int;
+  volatile unsigned int clkpwr_i2c_clk_ctrl;
+  volatile unsigned int clkpwr_key_clk_ctrl;
+  volatile unsigned int clkpwr_adc_clk_ctrl;
+  volatile unsigned int clkpwr_pwm_clk_ctrl;
+  volatile unsigned int clkpwr_timer_clk_ctrl;
+  volatile unsigned int clkpwr_timers_pwms_clk_ctrl_1;
+  volatile unsigned int clkpwr_spi_clk_ctrl;
+  volatile unsigned int clkpwr_nand_clk_ctrl;
+  volatile unsigned int reserved7;
+  volatile unsigned int clkpwr_uart3_clk_ctrl;
+  volatile unsigned int clkpwr_uart4_clk_ctrl;
+  volatile unsigned int clkpwr_uart5_clk_ctrl;
+  volatile unsigned int clkpwr_uart6_clk_ctrl;
+  volatile unsigned int clkpwr_irda_clk_ctrl;
+  volatile unsigned int clkpwr_uart_clk_ctrl;
+  volatile unsigned int clkpwr_dmaclk_ctrl;
+  volatile unsigned int clkpwr_autoclock;
+} CLKPWR_REGS_T;
+
+
+/*
+ * clkpwr_hclk_div register definitions
+ */
+/* HCLK Divider DDRAM clock stop (used for SDRAM only) */
+#define CLKPWR_HCLKDIV_DDRCLK_STOP (0x0 << 7)
+/* HCLK Divider DDRAM clock is the same speed as the ARM */
+#define CLKPWR_HCLKDIV_DDRCLK_NORM (0x1 << 7)
+/* HCLK Divider DDRAM clock is half the speed as the ARM */
+#define CLKPWR_HCLKDIV_DDRCLK_HALF (0x2 << 7)
+/* HCLK Divider PERIPH_CLK divider, for a value of n, the divider is
+   (1+n), maximum value of n is 32 */
+#define CLKPWR_HCLKDIV_PCLK_DIV(n) (((n) & 0x1F) << 2)
+/* HCLK Divider, for a value of n, the divider is (2^n), maximum
+   value of n is 2 for a divider of 4 */
+#define CLKPWR_HCLKDIV_DIV_2POW(n) ((n) & 0x3)
+
+/*
+ * clkpwr_pwr_ctrl register definitions
+ */
+/* Force HCLK and ARMCLK to run from PERIPH_CLK to save power */
+#define CLKPWR_CTRL_FORCE_PCLK      _BIT(10)
+/* SDRAM self refresh request */
+#define CLKPWR_SDRAM_SELF_RFSH      _BIT(9)
+/* Update SDRAM self refresh request */
+#define CLKPWR_UPD_SDRAM_SELF_RFSH  _BIT(8)
+/* Enable auto exit SDRAM self refresh */
+#define CLKPWR_AUTO_SDRAM_SELF_RFSH _BIT(7)
+/* Highcore pin level (when CLKPWR_HIGHCORE_GPIO_EN is set) */
+#define CLKPWR_HIGHCORE_STATE_BIT   _BIT(5)
+/* SYSCLKEN pin level (when CLKPWR_SYSCLKEN_GPIO_EN is set) */
+#define CLKPWR_SYSCLKEN_STATE_BIT   _BIT(4)
+/* Enable SYSCLKEN pin as a GPIO bit */
+#define CLKPWR_SYSCLKEN_GPIO_EN     _BIT(3)
+/* Selects direct run mode (0) or run mode (1) */
+#define CLKPWR_SELECT_RUN_MODE      _BIT(2)
+/* Enable Highcore pin as a GPIO bit */
+#define CLKPWR_HIGHCORE_GPIO_EN     _BIT(1)
+/* Enable Highcore pin as a GPIO bit */
+#define CLKPWR_STOP_MODE_CTRL       _BIT(0)
+
+/*
+ * clkpwr_sysclk_ctrl register definitions
+ */
+/* Number used by the clock switching circuitry to decide how long a
+   bad phase must be present before clock switching is triggered */
+#define CLKPWR_SYSCTRL_BP_TRIG(n)   (((n) & 0x3FF) << 2)
+/* Mask for bad phase bits */
+#define CLKPWR_SYSCTRL_BP_MASK      (0x3FF << 2)
+/* (1) = Use main oscillator, (1) = use PLL397 oscillator */
+#define CLKPWR_SYSCTRL_USEPLL397    _BIT(1)
+/* Read only status mask bit of the select oscillator, (0) = main
+   oscillator, (1) = PLL397 oscillator */
+#define CLKPWR_SYSCTRL_SYSCLKMUX    _BIT(0)
+
+/*
+ * clkpwr_hclkpll_ctrl register definitions
+ */
+/* Bit to start (1) or stop (0) the main HCLK PLL */
+#define CLKPWR_HCLKPLL_POWER_UP    _BIT(16)
+/* Main HCLK PLL CCO bypass control (0) = CCO clock to post divider,
+   (1) = Bypass CCO and route PLL clock to post divider */
+#define CLKPWR_HCLKPLL_CCO_BYPASS  _BIT(15)
+/* Main HCLK PLL post divider bypass control (0) = use post divider,
+   (1) = Bypass post divider */
+#define CLKPWR_HCLKPLL_POSTDIV_BYPASS _BIT(14)
+/* Main HCLK PLL feedback divider path control, (0) = feedback
+   divider clocked by CCO, (1) = feedback divider clocked by FCLKOUT */
+#define CLKPWR_HCLKPLL_FDBK_SEL_FCLK _BIT(13)
+/* Main HCLK PLL post divider setting, for a value of n, the divider
+   is 2^n, maximum value of n is 3 */
+#define CLKPWR_HCLKPLL_POSTDIV_2POW(n) (((n) & 0x3) << 11)
+/* Main HCLK PLL pre divider setting, for a value of n, the divider
+   is (1+n), maximum value of n is 3 */
+#define CLKPWR_HCLKPLL_PREDIV_PLUS1(n) (((n) & 0x3) << 9)
+/* Main HCLK PLL feedback setting, for a value of n, the feedback
+   is (1+n), maximum value of n is 255 */
+#define CLKPWR_HCLKPLL_PLLM(n)     (((n) & 0xFF) << 1)
+/* Read only status mask bit of the PLL lock state, (0) = PLL is not
+   locked, (1) = PLL is locked */
+#define CLKPWR_HCLKPLL_PLL_STS     _BIT(0)
+
+/*
+ * clkpwr_sdramclk_ctrl register definitions
+ */
+/* SDRAM RAM_CLK fast slew rate control selection bit */
+#define CLKPWR_SDRCLK_FASTSLEW_CLK _BIT(22)
+/* SDRAM grouping fast slew rate control selection bit */
+#define CLKPWR_SDRCLK_FASTSLEW     _BIT(21)
+/* SDRAM data fast slew rate control selection bit */
+#define CLKPWR_SDRCLK_FASTSLEW_DAT _BIT(20)
+/* SDRAM/DDR controller reset bit */
+#define CLKPWR_SDRCLK_SW_DDR_RESET _BIT(19)
+/* Select HCLK delay calibration value, n = 0 to 31 at .25nS per tick */
+#define CLKPWR_SDRCLK_HCLK_DLY(n)  (((n) & 0x1F) << 14)
+/* SDRAM/DDR delay circuitry address status bit */
+#define CLKPWR_SDRCLK_DLY_ADDR_STS _BIT(13)
+/* Sensitivity factor for DDR SDRAM cal, n = 0 to 7 */
+#define CLKPWR_SDRCLK_SENS_FACT(n) (((n) & 0x7) << 10)
+/* Use calibrated settings for DDR SDRAM bit */
+#define CLKPWR_SDRCLK_USE_CAL      _BIT(9)
+/* Perform a DDR delay calibration bit */
+#define CLKPWR_SDRCLK_DO_CAL       _BIT(8)
+/* Enable auto DDR cal on RTC tick bit */
+#define CLKPWR_SDRCLK_CAL_ON_RTC   _BIT(7)
+/* Select DQS input delay value, n = 0 to 31 at .25nS per tick */
+#define CLKPWR_SDRCLK_DQS_DLY(n)   (((n) & 0x1F) << 2)
+/* Use DDR (1) or SDRAM (0) bit */
+#define CLKPWR_SDRCLK_USE_DDR      _BIT(1)
+/* SDRAM/DDR clock disable bit */
+#define CLKPWR_SDRCLK_CLK_DIS      _BIT(0)
+
+/**********************************************************************
+* clkpwr_timers_pwms_clk_ctrl_1 register definitions
+**********************************************************************/
+/* Timer 3 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_TIMER3_EN 0x20
+/* Timer 2 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_TIMER2_EN 0x10
+/* Timer 1 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_TIMER1_EN 0x08
+/* Timer 0 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_TIMER0_EN 0x04
+/* PWM 4 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_PWM4_EN   0x02
+/* PWM 3 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_PWM3_EN   0x01
+
+/*
+ * clkpwr_uart3_clk_ctrl, clkpwr_uart4_clk_ctrl, clkpwr_uart5_clk_ctrl
+ * and clkpwr_uart6_clk_ctrl register definitions
+ */
+/* Macro for loading UART 'Y' divider value */
+#define CLKPWR_UART_Y_DIV(y)       ((y) & 0xFF)
+/* Macro for loading UART 'X' divider value */
+#define CLKPWR_UART_X_DIV(x)       (((x) & 0xFF) << 8)
+/* Bit for using HCLK as the UART X/Y divider input, or PERIPH_CLK */
+#define CLKPWR_UART_USE_HCLK       _BIT(16)
+
+/*
+ * clkpwr_uart_clk_ctrl register definitions
+ */
+/* UART6 clock disable (0) / enable (1) bit */
+#define CLKPWR_UARTCLKCTRL_UART6_EN _BIT(3)
+/* UART5 clock disable (0) / enable (1) bit */
+#define CLKPWR_UARTCLKCTRL_UART5_EN _BIT(2)
+/* UART4 clock disable (0) / enable (1) bit */
+#define CLKPWR_UARTCLKCTRL_UART4_EN _BIT(1)
+/* UART3 clock disable (0) / enable (1) bit */
+#define CLKPWR_UARTCLKCTRL_UART3_EN _BIT(0)
+
+/**********************************************************************
+* clkpwr_ssp_blk_ctrl register definitions
+**********************************************************************/
+/* SSP1 RX DMA selection, (0) = SSP1RX not connected/SPI2 connected,
+   (1) = SSP1RX connected/SPI2 not connected */
+#define CLKPWR_SSPCTRL_DMA_SSP1RX  _BIT(5)
+/* SSP1 TX DMA selection, (0) = SSP1TX not connected/SPI1 connected,
+   (1) = SSP1TX connected/SPI1 not connected */
+#define CLKPWR_SSPCTRL_DMA_SSP1TX  _BIT(4)
+/* SSP0 RX DMA selection, (0) = SSP1RX not connected/SPI2 connected,
+   (1) = SSP1RX connected/SPI3 not connected */
+#define CLKPWR_SSPCTRL_DMA_SSP0RX  _BIT(3)
+/* SSP0 TX DMA selection, (0) = SSP1TX not connected/SPI1 connected,
+   (1) = SSP1TX connected/SPI4 not connected */
+#define CLKPWR_SSPCTRL_DMA_SSP0TX  _BIT(2)
+/* SSP0 clock disable (0) / enable (1) bit */
+#define CLKPWR_SSPCTRL_SSPCLK1_EN  _BIT(1)
+/* SSP0 clock disable (0) / enable (1) bit */
+#define CLKPWR_SSPCTRL_SSPCLK0_EN  _BIT(0)
+
+
+/**********************************************************************
+* clkpwr_timer_clk_ctrl register definitions
+**********************************************************************/
+/* High speed timer clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_PWMCLK_HSTIMER_EN   0x2
+/* Watchdog timer clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_PWMCLK_WDOG_EN      0x1
+
+
+/**********************************************************************
+* clkpwr_macclk_ctrl register definitions
+**********************************************************************/
+/* Disables ethernet MAC pins */
+#define CLKPWR_MACCTRL_NO_ENET_PIS 0x00
+/* Ethernet MAC pins setup for MII */
+#define CLKPWR_MACCTRL_USE_MII_PINS 0x08
+/* Ethernet MAC pins setup for RMII */
+#define CLKPWR_MACCTRL_USE_RMII_PINS 0x18
+/* Mask for MAC pins selection */
+#define CLKPWR_MACCTRL_PINS_MSK    0x18
+/* Ethernet MAC DMA clock disable (0) / enable (1) bit */
+#define CLKPWR_MACCTRL_DMACLK_EN   _BIT(2)
+/* Ethernet MAC MMIO clock disable (0) / enable (1) bit */
+#define CLKPWR_MACCTRL_MMIOCLK_EN  _BIT(1)
+/* Ethernet MAC host registers clock disable (0) / enable (1) bit */
+#define CLKPWR_MACCTRL_HRCCLK_EN   _BIT(0)
+
+
+/**********************************************************************
+* clkpwr_timers_pwms_clk_ctrl_1 register definitions
+**********************************************************************/
+/* Timer 3 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_TIMER3_EN 0x20
+/* Timer 2 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_TIMER2_EN 0x10
+/* Timer 1 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_TIMER1_EN 0x08
+/* Timer 0 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_TIMER0_EN 0x04
+/* PWM 4 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_PWM4_EN   0x02
+/* PWM 3 clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_TMRPWMCLK_PWM3_EN   0x01
+
+
+/*
+ * Macro pointing to Clock and Power control registers
+ */
+#define CLKPWR ((CLKPWR_REGS_T *)(CLK_PM_BASE))
+
+/*
+ * Main system clocks
+ */
+typedef enum
+{
+  /* Main oscillator clock */
+  CLKPWR_MAINOSC_CLK,
+  /* RTC clock */
+  CLKPWR_RTC_CLK,
+  /* System clock (Main oscillator or PLL397) */
+  CLKPWR_SYSCLK,
+  /* ARM clock, either HCLK(PLL), SYSCLK, or PERIPH_CLK */
+  CLKPWR_ARM_CLK,
+  /* HCLK (HCLKPLL divided, SYSCLK, or PERIPH_CLK) */
+  CLKPWR_HCLK,
+  /* Peripheral clock (HCLKPLL divided or SYSCLK) */
+  CLKPWR_PERIPH_CLK,
+  /* USB HCLK SYS*/
+  CLKPWR_USB_HCLK_SYS,
+  /* USB PLL clock */
+  CLKPWR_48M_CLK,
+  /* DDR clock (HCLKPLL divided or SYSCLK) */
+  CLKPWR_DDR_CLK,
+  /* Sd card controller */
+  CLKPWR_MSSD_CLK,
+  CLKPWR_BASE_INVALID
+} CLKPWR_BASE_CLOCK_T;
+
+/*
+ * Clock rate fetch function
+ */
+unsigned int sys_get_rate(CLKPWR_BASE_CLOCK_T clkid);
+
+
+
+
+
+/**********************************************************************
+* Timer/counter register structures
+**********************************************************************/
+
+/* Timer module register structures */
+typedef struct
+{
+  volatile unsigned int ir;          /* Timer interrupt status reg */
+  volatile unsigned int tcr;         /* Timer control register */
+  volatile unsigned int tc;          /* Timer counter value reg */
+  volatile unsigned int pr;          /* Timer prescale register */
+  volatile unsigned int pc;          /* Timer prescale counter reg */
+  volatile unsigned int mcr;         /* Timer Match control reg */
+  volatile unsigned int mr[4];       /* Timer Match registers */
+  volatile unsigned int ccr;         /* Timer Capture control reg */
+  volatile unsigned int cr[4];       /* Timer Capture registers */
+  volatile unsigned int emr;         /* Timer External match reg */
+  volatile unsigned int rsvd2[12];   /* Reserved */
+  volatile unsigned int ctcr;        /* Timer Count control reg */
+} TIMER_CNTR_REGS_T;
+
+/**********************************************************************
+* ir register definitions
+* Write a '1' to clear interrupt, reading a '1' indicates active int
+**********************************************************************/
+/* Macro for getting a timer match interrupt bit */
+#define TIMER_CNTR_MTCH_BIT(n)     (1 << ((n) & 0x3))
+
+/* Macro for getting a capture event interrupt bit */
+#define TIMER_CNTR_CAPT_BIT(n)     (1 << (4 + ((n) & 0x3)))
+
+/**********************************************************************
+* tcr register definitions
+**********************************************************************/
+/* Timer/counter enable bit */
+#define TIMER_CNTR_TCR_EN          0x1
+
+/* Timer/counter reset bit */
+#define TIMER_CNTR_TCR_RESET       0x2
+
+/**********************************************************************
+* mcr register definitions
+**********************************************************************/
+/* Bit location for interrupt on MRx match, n = 0 to 3 */
+#define TIMER_CNTR_MCR_MTCH(n)     (0x1 << ((n) * 3))
+
+/* Bit location for reset on MRx match, n = 0 to 3 */
+#define TIMER_CNTR_MCR_RESET(n)    (0x1 << (((n) * 3) + 1))
+
+/* Bit location for stop on MRx match, n = 0 to 3 */
+#define TIMER_CNTR_MCR_STOP(n)     (0x1 << (((n) * 3) + 2))
+
+/**********************************************************************
+* ccr register definitions
+**********************************************************************/
+/* Bit location for CAP.n on CRx rising edge, n = 0 to 3 */
+#define TIMER_CNTR_CCR_CAPNRE(n)   (0x1 << ((n) * 3))
+
+/* Bit location for CAP.n on CRx falling edge, n = 0 to 3 */
+#define TIMER_CNTR_CCR_CAPNFE(n)   (0x1 << (((n) * 3) + 1))
+
+/* Bit location for CAP.n on CRx interrupt enable, n = 0 to 3 */
+#define TIMER_CNTR_CCR_CAPNI(n)    (0x1 << (((n) * 3) + 2))
+
+/**********************************************************************
+* emr register definitions
+**********************************************************************/
+/* Bit location for output state change of MAT.n when external match
+   happens, n = 0 to 3 */
+#define TIMER_CNTR_EMR_DRIVE(n)    (1 << (n))
+
+/* Macro for setting MAT.n soutput state */
+#define TIMER_CNTR_EMR_DRIVE_SET(n, s) (((s) & 0x1) << (n))
+
+/* Output state change of MAT.n when external match happens */
+#define TIMER_CNTR_EMR_NOTHING     0x0
+#define TIMER_CNTR_EMR_LOW         0x1
+#define TIMER_CNTR_EMR_HIGH        0x2
+#define TIMER_CNTR_EMR_TOGGLE      0x3
+
+/* Macro for setting for the MAT.n change state bits */
+#define TIMER_CNTR_EMR_EMC_SET(n, s) (((s) & 0x3) << (4 + ((n) * 2)))
+
+/* Mask for the MAT.n change state bits */
+#define TIMER_CNTR_EMR_EMC_MASK(n) (0x3 << (4 + ((n) * 2)))
+
+/**********************************************************************
+* ctcr register definitions
+**********************************************************************/
+/* Mask to get the Counter/timer mode bits */
+#define TIMER_CNTR_CTCR_MODE_MASK  0x3
+
+/* Mask to get the count input select bits */
+#define TIMER_CNTR_CTCR_INPUT_MASK 0xC
+
+/* Counter/timer modes */
+#define TIMER_CNTR_CTCR_TIMER_MODE 0x0
+#define TIMER_CNTR_CTCR_TCINC_MODE 0x1
+#define TIMER_CNTR_CTCR_TCDEC_MODE 0x2
+#define TIMER_CNTR_CTCR_TCBOTH_MODE 0x3
+
+/* Count input selections */
+#define TIMER_CNTR_CTCR_INPUT_CAP0 0x0
+#define TIMER_CNTR_CTCR_INPUT_CAP1 0x1
+#define TIMER_CNTR_CTCR_INPUT_CAP2 0x2
+#define TIMER_CNTR_CTCR_INPUT_CAP3 0x3
+
+/* Macro for setting the counter/timer mode */
+#define TIMER_CNTR_SET_MODE(n)     ((n) & 0x3)
+
+/* Macro for setting the count input select */
+#define TIMER_CNTR_SET_INPUT(n)    (((n) & 0x3) << 2)
+
+/* Macros pointing to timer registers */
+#define TIMER_CNTR0 ((TIMER_CNTR_REGS_T *)(TIMER0_BASE))
+#define TIMER_CNTR1 ((TIMER_CNTR_REGS_T *)(TIMER1_BASE))
+#define TIMER_CNTR2 ((TIMER_CNTR_REGS_T *)(TIMER2_BASE))
+#define TIMER_CNTR3 ((TIMER_CNTR_REGS_T *)(TIMER3_BASE))
+
+
+
+
+
+/* WDT module register structures */
+typedef struct
+{
+  volatile unsigned int wdtim_int;      /* WDT interrupt status register */
+  volatile unsigned int wdtim_ctrl;     /* WDT control register */
+  volatile unsigned int wdtim_counter;  /* WDT counter value register */
+  volatile unsigned int wdtim_mctrl;    /* WDT match control register */
+  volatile unsigned int wdtim_match0;   /* WDT match 0 register */
+  volatile unsigned int wdtim_emr;      /* WDT external match control reg */
+  volatile unsigned int wdtim_pulse;    /* WDT reset pulse length register */
+  volatile unsigned int wdtim_res;      /* WDT reset source register */
+} WDT_REGS_T;
+
+/**********************************************************************
+* wdtim_int register definitions
+**********************************************************************/
+/* Interrupt flag for MATCH 0 interrupt */
+#define WDT_MATCH_INT           _BIT(0)
+
+/**********************************************************************
+* wdtim_ctrl register definitions
+**********************************************************************/
+#define WDT_COUNT_ENAB          _BIT(0) /* Timer Counter enable */
+#define WDT_RESET_COUNT         _BIT(1) /* Timer Counter reset */
+#define WDT_PAUSE_EN            _BIT(2) /* Timer Cntr stopped in debug*/
+
+/**********************************************************************
+* wdtim_mctrl register definitions
+**********************************************************************/
+#define WDT_MR0_INT             _BIT(0) /* Enable WDT int on MR0 */
+#define WDT_RESET_COUNT0        _BIT(1) /* Enable WDT reset on MR0 */
+#define WDT_STOP_COUNT0         _BIT(2) /* Enable WDT stop on MR0 */
+#define WDT_M_RES1              _BIT(3) /* M_RES1 control */
+#define WDT_M_RES2              _BIT(4) /* M_RES2 control */
+#define WDT_RESFRC1             _BIT(5) /* RESFRC1 control */
+#define WDT_RESFRC2             _BIT(6) /* RESFRC2 control */
+
+/* Macro pointing to WDT registers */
+#define WDT ((WDT_REGS_T *)(WDTIM_BASE))
+
+
+
+/* SLC NAND controller module register structures */
+typedef struct
+{
+  volatile unsigned int slc_data;      /* SLC NAND data reg */
+  volatile unsigned int slc_addr;      /* SLC NAND address register */
+  volatile unsigned int slc_cmd;       /* SLC NAND command reg */
+  volatile unsigned int slc_stop;      /* SLC NAND stop register */
+  volatile unsigned int slc_ctrl;      /* SLC NAND control reg */
+  volatile unsigned int slc_cfg;       /* SLC NAND config register */
+  volatile unsigned int slc_stat;      /* SLC NAND status register */
+  volatile unsigned int slc_int_stat;  /* SLC NAND int status register */
+  volatile unsigned int slc_ien;       /* SLC NAND int enable register */
+  volatile unsigned int slc_isr;       /* SLC NAND int set register */
+  volatile unsigned int slc_icr;       /* SLC NAND int clear register */
+  volatile unsigned int slc_tac;       /* SLC NAND timing register */
+  volatile unsigned int slc_tc;        /* SLC NAND transfer count reg */
+  volatile unsigned int slc_ecc;       /* SLC NAND parity register */
+  volatile unsigned int slc_dma_data;  /* SLC NAND DMA data register */
+} SLCNAND_REGS_T;
+
+/**********************************************************************
+* slc_ctrl register definitions
+**********************************************************************/
+#define SLCCTRL_SW_RESET    _BIT(2) /* Reset the NAND controller bit */
+#define SLCCTRL_ECC_CLEAR   _BIT(1) /* Reset ECC bit */
+#define SLCCTRL_DMA_START   _BIT(0) /* Start DMA channel bit */
+
+/**********************************************************************
+* slc_cfg register definitions
+**********************************************************************/
+#define SLCCFG_CE_LOW       _BIT(5) /* Force CE low bit */
+#define SLCCFG_DMA_ECC      _BIT(4) /* Enable DMA ECC bit */
+#define SLCCFG_ECC_EN       _BIT(3) /* ECC enable bit */
+#define SLCCFG_DMA_BURST    _BIT(2) /* DMA burst bit */
+#define SLCCFG_DMA_DIR      _BIT(1) /* DMA write(0)/read(1) bit */
+#define SLCCFG_WIDTH        _BIT(0) /* External device width, 0=8bit */
+
+/**********************************************************************
+* slc_stat register definitions
+**********************************************************************/
+#define SLCSTAT_DMA_FIFO    _BIT(2) /* DMA FIFO has data bit */
+#define SLCSTAT_SLC_FIFO    _BIT(1) /* SLC FIFO has data bit */
+#define SLCSTAT_NAND_READY  _BIT(0) /* NAND device is ready bit */
+
+/**********************************************************************
+* slc_int_stat, slc_ien, slc_isr, and slc_icr register definitions
+**********************************************************************/
+#define SLCSTAT_INT_TC      _BIT(1) /* Transfer count bit */
+#define SLCSTAT_INT_RDY_EN  _BIT(0) /* Ready interrupt bit */
+
+/**********************************************************************
+* slc_tac register definitions
+**********************************************************************/
+/* Clock setting for RDY write sample wait time in 2*n clocks */
+#define SLCTAC_WDR(n)       (((n) & 0xF) << 28)
+/* Write pulse width in clocks cycles, 1 to 16 clocks */
+#define SLCTAC_WWIDTH(n)    (((n) & 0xF) << 24)
+/* Write hold time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_WHOLD(n)     (((n) & 0xF) << 20)
+/* Write setup time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_WSETUP(n)    (((n) & 0xF) << 16)
+/* Clock setting for RDY read sample wait time in 2*n clocks */
+#define SLCTAC_RDR(n)       (((n) & 0xF) << 12)
+/* Read pulse width in clocks cycles, 1 to 16 clocks */
+#define SLCTAC_RWIDTH(n)    (((n) & 0xF) << 8)
+/* Read hold time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_RHOLD(n)     (((n) & 0xF) << 4)
+/* Read setup time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_RSETUP(n)    (((n) & 0xF) << 0)
+
+/* Macro pointing to SLC NAND controller registers */
+#define SLCNAND ((SLCNAND_REGS_T *)(SLC_BASE))
+
+
+
+
+
+
+
+
+
+
+
+/**********************************************************************
+* Ethernet MAC controller register structures
+**********************************************************************/
+
+/* Ethernet MAC controller module register structures */
+typedef struct
+{
+  /* MAC registers */
+  volatile unsigned long mac1;
+  volatile unsigned long mac2;
+  volatile unsigned long ipgt;
+  volatile unsigned long ipgr;
+  volatile unsigned long clrt;
+  volatile unsigned long maxf;
+  volatile unsigned long supp;
+  volatile unsigned long test;
+  volatile unsigned long mcfg;
+  volatile unsigned long mcmd;
+  volatile unsigned long madr;
+  volatile unsigned long mwtd;
+  volatile unsigned long mrdd;
+  volatile unsigned long mind;
+  volatile unsigned long reserved1 [2];
+  volatile unsigned long sa [3];
+  volatile unsigned long reserved2 [45];
+  /* Control registers */
+  volatile unsigned long command;
+  volatile unsigned long status;
+  volatile unsigned long rxdescriptor;
+  volatile unsigned long rxstatus;
+  volatile unsigned long rxdescriptornumber;
+  volatile unsigned long rxproduceindex;
+  volatile unsigned long rxconsumeindex;
+  volatile unsigned long txdescriptor;
+  volatile unsigned long txstatus;
+  volatile unsigned long txdescriptornumber;
+  volatile unsigned long txproduceindex;
+  volatile unsigned long txconsumeindex;
+  volatile unsigned long reserved3 [10];
+  volatile unsigned long tsv0;
+  volatile unsigned long tsv1;
+  volatile unsigned long rsv;
+  volatile unsigned long reserved4 [3];
+  volatile unsigned long flowcontrolcounter;
+  volatile unsigned long flowcontrolstatus;
+  volatile unsigned long reserved5 [34];
+  /* RX filter registers */
+  volatile unsigned long rxfliterctrl;
+  volatile unsigned long rxfilterwolstatus;
+  volatile unsigned long rxfilterwolclear;
+  volatile unsigned long reserved6;
+  volatile unsigned long hashfilterL;
+  volatile unsigned long hashfilterh;
+  volatile unsigned long reserved7 [882];
+  /* Module control registers */
+  volatile unsigned long intstatus;
+  volatile unsigned long intenable;
+  volatile unsigned long intclear;
+  volatile unsigned long Intset;
+  volatile unsigned long reserved8;
+  volatile unsigned long powerdown;
+  volatile unsigned long reserved9;
+} ETHERNET_REGS_T;
+
+/* Structure of a TX/RX descriptor */
+typedef struct
+{
+  volatile unsigned long packet;
+  volatile unsigned long control;
+} TXRX_DESC_T;
+
+/* Structure of a RX status entry */
+typedef struct
+{
+  volatile unsigned long statusinfo;
+  volatile unsigned long statushashcrc;
+} RX_STATUS_T;
+
+/**********************************************************************
+* mac1 register definitions
+**********************************************************************/
+/* Set this to allow receive frames to be received. Internally the
+   MAC synchronize this control bit to the incoming receive stream */
+#define MAC1_RECV_ENABLE               _BIT(0)
+/* When enabled (set to 1), the MAC will pass all frames regardless
+   of type (normal vs. Control). When disabled, the MAC does not pass
+   valid Control frames */
+#define MAC1_PASS_ALL_RX_FRAMES        _BIT(1)
+/* When enabled (set to 1), the MAC acts upon received PAUSE Flow
+   Control frames. When disabled, received PAUSE Flow Control frames
+   are ignored */
+#define MAC1_RX_FLOW_CONTROL           _BIT(2)
+/* When enabled (set to 1), PAUSE Flow Control frames are allowed
+   to be transmitted. When disabled, Flow Control frames are blocked */
+#define MAC1_TX_FLOW_CONTROL           _BIT(3)
+/* Setting this bit will cause the MAC Transmit interface to be
+   looped back to the MAC Receive interface. Clearing this bit
+   results in normal operation */
+#define MAC1_LOOPBACK                  _BIT(4)
+/* Setting this bit will put the Transmit Function logic in reset */
+#define MAC1_RESET_TX                  _BIT(8)
+/* Setting this bit resets the MAC Control Sublayer / Transmit logic.
+   The MCS logic implements flow control */
+#define MAC1_RESET_MCS_TX              _BIT(9)
+/* Setting this bit will put the Ethernet receive logic in reset */
+#define MAC1_RESET_RX                  _BIT(10)
+/* Setting this bit resets the MAC Control Sublayer / Receive logic.
+   The MCS logic implements flow control */
+#define MAC1_RESET_MCS_RX              _BIT(11)
+/* Setting this bit will cause a reset to the random number generator
+   within the Transmit Function */
+#define MAC1_SIMULATION_RESET          _BIT(14)
+/* Setting this bit will put all modules within the MAC in reset
+   except the Host Interface */
+#define MAC1_SOFT_RESET                _BIT(15)
+
+/**********************************************************************
+* mac2 register definitions
+**********************************************************************/
+/* When enabled (set to 1), the MAC operates in Full-Duplex mode.
+   When disabled the MAC operates in Half-Duplex mode */
+#define MAC2_FULL_DUPLEX               _BIT(0)
+/* When enabled (set to 1), both transmit and receive frame lengths
+   are compared to the Length/Type field. If the Length/Type field
+   represents a length then the check is performed. Mismatches are
+   reported in the StatusInfo word for each received frame */
+#define MAC2_FRAME_LENGTH_CHECKING     _BIT(1)
+/* When enabled (set to 1), frames of any length are transmitted
+   and received */
+#define MAC2_HUGH_LENGTH_CHECKING      _BIT(2)
+/* This bit determines the number of bytes, if any, of proprietary
+   header information that exist on the front of IEEE 802.3 frames.
+   When 1, four bytes of header (ignored by the CRC function) are
+   added. When 0, there is no proprietary header */
+#define MAC2_DELAYED_CRC               _BIT(3)
+/* Set this bit to append a CRC to every frame whether padding was
+   required or not. Must be set if PAD/CRC ENABLE is set. Clear this
+   bit if frames presented to the MAC contain a CRC */
+#define MAC2_CRC_ENABLE                _BIT(4)
+/* Set this bit to have the MAC pad all short frames. Clear this bit
+   if frames presented to the MAC have a valid length. This bit is used
+   in conjunction with AUTO PAD ENABLE and VLAN PAD ENABLE */
+#define MAC2_PAD_CRC_ENABLE            _BIT(5)
+/* Set this bit to cause the MAC to pad all short frames to 64 bytes
+   and append a valid CRC. Note: This bit is ignored if
+   MAC2_PAD_CRC_ENABLE is cleared */
+#define MAC2_VLAN_PAD_ENABLE           _BIT(6)
+/* Set this bit to cause the MAC to automatically detect the type of
+   frame, either tagged or un-tagged, by comparing the two octets
+   following the source address with 0x8100 (VLAN Protocol ID) and
+   pad accordingly. Table 14273 - Pad Operation provides a description
+   of the pad function based on the configuration of this register.
+   Note: This bit is ignored if PAD / CRC ENABLE is cleared */
+#define MAC2_AUTO_DETECT_PAD_ENABLE    _BIT(7)
+/* When enabled (set to 1), the MAC will verify the content of the
+   preamble to ensure it contains 0x55 and is error-free. A packet
+   with an incorrect preamble is discarded. When disabled, no preamble
+   checking is performed */
+#define MAC2_PURE_PREAMBLE_ENFORCEMENT _BIT(8)
+/* When enabled (set to 1), the MAC only allows receive packets
+   which contain preamble fields less than 12 bytes in length. When
+   disabled, the MAC allows any length preamble as per the Standard */
+#define MAC2_LONG_PREAMBLE_ENFORCEMENT _BIT(9)
+/* When enabled (set to 1), the MAC will immediately retransmit
+   following a collision rather than using the Binary Exponential
+   Backoff algorithm as specified in the Standard */
+#define MAC2_NO_BACKOFF                _BIT(12)
+/* When enabled (set to 1), after the MAC incidentally causes a
+   collision during back pressure, it will immediately retransmit
+   without backoff, reducing the chance of further collisions and
+   ensuring transmit packets get sent */
+#define MAC2_BACK_PRESSURE             _BIT(13)
+/* When enabled (set to 1) the MAC will defer to carrier indefinitely
+   as per the Standard. When disabled, the MAC will abort when the
+   excessive deferral limit is reached */
+#define MAC2_EXCESS_DEFER              _BIT(14)
+
+/**********************************************************************
+* ipgt register definitions
+**********************************************************************/
+/* This is a programmable field representing the nibble time offset
+   of the minimum possible period between the end of any transmitted
+   packet to the beginning of the next. In Full-Duplex mode, the
+   register value should be the desired period in nibble times minus 3.
+   In Half-Duplex mode, the register value should be the desired
+   period in nibble times minus 6. In Full-Duplex the recommended
+   setting is 0x15 (21d), which represents the minimum IPG of 960 ns
+   (in 100 Mbps mode) or 9.6 ?s (in 10 Mbps mode). In Half-Duplex the
+   recommended setting is 0x12 (18d), which also represents the minimum
+   IPG of 960 ns (in 100 Mbps mode) or 9.6 ?s (in 10 Mbps mode) */
+#define IPGT_LOAD(n)                   ((n) & 0x7F)
+
+/**********************************************************************
+* ipgr register definitions
+**********************************************************************/
+/* This is a programmable field representing the Non-Back-to-Back
+   Inter-Packet-Gap. The recommended value is 0x12 (18d), which
+   represents the minimum IPG of 960 ns (in 100 Mbps mode) or 9.6 ?s
+   (in 10 Mbps mode) */
+#define IPGR_LOAD_PART2(n)             ((n) & 0x7F)
+/* This is a programmable field representing the optional carrierSense
+   window referenced in IEEE 802.3/4.2.3.2.1 'Carrier Deference'. If
+   carrier is detected during the timing of IPGR1, the MAC defers to
+   carrier. If, however, carrier becomes active after IPGR1, the MAC
+   continues timing IPGR2 and transmits, knowingly causing a collision,
+   thus ensuring fair access to medium. Its range of values is 0x0 to
+   IPGR2. The recommended value is 0xC (12d) */
+#define IPGR_LOAD_PART1(n)             (((n) & 0x7F) << 8)
+
+/**********************************************************************
+* clrt register definitions
+**********************************************************************/
+/* This is a programmable field specifying the number of
+   retransmission attempts following a collision before aborting the
+   packet due to excessive collisions. The Standard specifies the
+   attemptLimit to be 0xF (15d). See IEEE 802.3/4.2.3.2.5. */
+#define CLRT_LOAD_RETRY_MAX(n)         ((n) & 0xF)
+/* This is a programmable field representing the slot time or
+   collision window during which collisions occur in properly
+   configured networks. The default value of 0x37 (55d) represents a
+   56 byte window following the preamble and SFD. */
+#define CLRT_LOAD_COLLISION_WINDOW(n)  (((n) & 0x3F) << 8)
+
+/**********************************************************************
+* maxf register definitions
+**********************************************************************/
+/* This field resets to the value 0x0600, which represents a maximum
+   receive frame of 1536 octets. An untagged maximum size Ethernet
+   frame is 1518 octets. A tagged frame adds four octets for a total
+   of 1522 octets. If a shorter maximum length restriction is desired,
+   program this 16 bit field. */
+#define MAXF_LOAD_MAX_FRAME_LEN(n)     ((n) & 0xFFFF)
+
+/**********************************************************************
+* supp register definitions
+**********************************************************************/
+/* This bit configures the Reduced MII logic for the current operating
+   speed. When set, 100 Mbps mode is selected. When cleared, 10 Mbps
+   mode is selected */
+#define SUPP_SPEED                     _BIT(8)
+/* Reset Reduced MII Logic */
+#define SUPP_RESET_RMII                _BIT(11)
+
+/**********************************************************************
+* test register definitions
+**********************************************************************/
+/* This bit reduces the effective PAUSE quanta from 64 byte-times to
+   1 byte-time. */
+#define TEST_SHORTCUT_PAUSE_QUANTA     _BIT(0)
+/* This bit causes the MAC Control sublayer to inhibit transmissions,
+   just as if a PAUSE Receive Control frame with a nonzero pause time
+   parameter was received. */
+#define TEST_PAUSE                     _BIT(1)
+/* Setting this bit will cause the MAC to assert backpressure on the
+   link. Backpressure causes preamble to be transmitted, raising
+   carrier sense. A transmit packet from the system will be sent
+   during backpressure. */
+#define TEST_BACKPRESSURE              _BIT(2)
+
+/**********************************************************************
+* mcfg register definitions
+**********************************************************************/
+/* Set this bit to cause the MII Management hardware to perform read
+   cycles across a range of PHYs. When set, the MII Management
+   hardware will perform read cycles from address 1 through the value
+   set in PHY ADDRESS[4:0]. Clear this bit to allow continuous reads
+   of the same PHY. */
+#define MCFG_SCAN_INCREMENT            _BIT(0)
+/* Set this bit to cause the MII Management hardware to perform
+   read/write cycles without the 32 bit preamble field. Clear this bit
+   to cause normal cycles to be performed. Some PHYs support
+   suppressed preamble. */
+#define MCFG_SUPPRESS_PREAMBLE         _BIT(1)
+/* This field is used by the clock divide logic in creating the MII
+   Management Clock (MDC) which IEEE 802.3u defines to be no faster
+   than 2.5 MHz. Some PHYs support clock rates up to 12.5 MHz,
+   however. Refer to Table 14280 below for the definition of values
+   for this field. */
+#define MCFG_CLOCK_SELECT(n)           (((n) & 0x7) << 2)
+/* MCFG_CLOCK_SELECT macro load values */
+#define MCFG_CLOCK_HOST_DIV_4          0
+#define MCFG_CLOCK_HOST_DIV_6          2
+#define MCFG_CLOCK_HOST_DIV_8          3
+#define MCFG_CLOCK_HOST_DIV_10         4
+#define MCFG_CLOCK_HOST_DIV_14         5
+#define MCFG_CLOCK_HOST_DIV_20         6
+#define MCFG_CLOCK_HOST_DIV_28         7
+/* This bit resets the MII Management hardware */
+#define MCFG_RESET_MII_MGMT            _BIT(15)
+
+/**********************************************************************
+* mcmd register definitions
+**********************************************************************/
+/* This bit causes the MII Management hardware to perform a single
+   Read cycle. The Read data is returned in Register MRDD (MII Mgmt
+   Read Data). */
+#define MCMD_READ                      _BIT(0)
+/* This bit causes the MII Management hardware to perform Read cycles
+   continuously. This is useful for monitoring Link Fail for example */
+#define MCMD_SCAN                      _BIT(1)
+
+/**********************************************************************
+* madr register definitions
+**********************************************************************/
+/* This field represents the 5 bit Register Address field of Mgmt
+   cycles. Up to 32 registers can be accessed. */
+#define MADR_REGISTER_ADDRESS(n)       ((n) & 0x1F)
+/* This field represents the 5 bit PHY Address field of Mgmt
+   cycles. Up to 31 PHYs can be addressed (0 is reserved). */
+#define MADR_PHY_0ADDRESS(n)           (((n) & 0x1F) << 8)
+
+/**********************************************************************
+* mwtd register definitions
+**********************************************************************/
+/* When written, an MII Mgmt write cycle is performed using the 16 bit
+   data and the pre-configured PHY and Register addresses from the
+   MII Mgmt Address register (MADR). */
+#define MWDT_WRITE(n)                  ((n) & 0xFFFF)
+
+/**********************************************************************
+* mrdd register definitions
+**********************************************************************/
+/* Read mask for MUU read */
+#define MRDD_READ_MASK                 0xFFFF
+
+/**********************************************************************
+* mind register definitions
+**********************************************************************/
+/* When 1 is returned - indicates MII Mgmt is currently performing
+   an MII Mgmt Read or Write cycle. */
+#define MIND_BUSY                      _BIT(0)
+/* When 1 is returned - indicates a scan operation (continuous MII
+   Mgmt Read cycles) is in progress. */
+#define MIND_SCANNING                  _BIT(1)
+/* When 1 is returned - indicates MII Mgmt Read cycle has not
+   completed and the Read Data is not yet valid. */
+#define MIND_NOT_VALID                 _BIT(2)
+/* When 1 is returned - indicates that an MII Mgmt link fail has
+   occurred.*/
+#define MIND_MII_LINK_FAIL             _BIT(3)
+
+/**********************************************************************
+* command register definitions
+**********************************************************************/
+/* Enable receive */
+#define COMMAND_RXENABLE               _BIT(0)
+/* Enable transmit */
+#define COMMAND_TXENABLE               _BIT(1)
+/* When a 1 is written, all datapaths and the host registers are
+   reset. The MAC needs to be reset separately. */
+#define COMMAND_REG_RESET              _BIT(3)
+/* When a 1 is written, the transmit datapath is reset. */
+#define COMMAND_TXRESET                _BIT(4)
+/* When a 1 is written, the receive datapath is reset. */
+#define COMMAND_RXRESET                _BIT(5)
+/* When set to 1, passes runt frames smaller than 64 bytes to
+   memory unless they have a CRC error. If 0 runt frames are
+   filtered out. */
+#define COMMAND_PASSRUNTFRAME          _BIT(6)
+/* When set to 1, disables receive filtering i.e. all frames
+   received are written to memory. */
+#define COMMAND_PASSRXFILTER           _BIT(7)
+/* Enable IEEE 802.3 / clause 31 flow control sending pause
+   frames in full duplex and continuous preamble in half duplex. */
+#define COMMAND_TXFLOWCONTROL          _BIT(8)
+/* When set to 1, RMII mode is selected; if 0, MII mode is
+   selected. */
+#define COMMAND_RMII                   _BIT(9)
+/* When set to 1, indicates full duplex operation. */
+#define COMMAND_FULLDUPLEX             _BIT(10)
+
+/**********************************************************************
+* status register definitions
+**********************************************************************/
+/* If 1, the receive channel is active. If 0, the receive channel is
+   inactive. */
+#define STATUS_RXACTIVE                _BIT(0)
+/* If 1, the transmit channel is active. If 0, the transmit channel is
+   inactive. */
+#define STATUS_TXACTIVE                _BIT(1)
+
+/**********************************************************************
+* tsv0 register definitions
+**********************************************************************/
+/* The attached CRC in the packet did not match the internally
+   generated CRC. */
+#define TSV0_CRC_ERROR                 _BIT(0)
+/* Indicates the frame length field does not match the actual
+   number of data items and is not a type field. */
+#define TSV0_LENGTH_CHECK_ERROR        _BIT(1)
+/* Indicates that frame type/length field was larger tha 1500 bytes. */
+#define TSV0_LENGTH_OUT_OF_RANGE       _BIT(2)
+/* Transmission of packet was completed. */
+#define TSV0_DONE                      _BIT(3)
+/* Packets destination was a multicast address. */
+#define TSV0_MULTICAST                 _BIT(4)
+/* Packets destination was a broadcast address. */
+#define TSV0_BROADCAST                 _BIT(5)
+/* Packet was deferred for at least one attempt, but less than
+   an excessive defer. */
+#define TSV0_PACKET_DEFER              _BIT(6)
+/* Packet was deferred in excess of 6071 nibble times in
+   100 Mbps or 24287 bit times in 10 Mbps mode. */
+#define TSV0_ESCESSIVE_DEFER           _BIT(7)
+/* Packet was aborted due to exceeding of maximum allowed
+   number of collisions. */
+#define TSV0_ESCESSIVE_COLLISION       _BIT(8)
+/* Collision occurred beyond collision window, 512 bit times. */
+#define TSV0_LATE_COLLISION            _BIT(9)
+/* Byte count in frame was greater than can be represented
+   in the transmit byte count field in TSV1. */
+#define TSV0_GIANT                     _BIT(10)
+/* Host side caused buffer underrun. */
+#define TSV0_UNDERRUN                  _BIT(11)
+/* Macro: The total number of bytes transferred including
+   collided attempts. */
+#define TSV0_TOTAL_BYTES(n)            (((n) >> 12) & 0xFFFF)
+/* The frame was a control frame. */
+#define TSV0_CONTROL_FRAME             _BIT(28)
+/* The frame was a control frame with a valid PAUSE opcode. */
+#define TSV0_PAUSE                     _BIT(29)
+/* Carrier-sense method backpressure was previously applied. */
+#define TSV0_BACKPRESSURE              _BIT(30)
+/* Frames length/type field contained 0x8100 which is the
+   VLAN protocol identifier. */
+#define TSV0_VLAN                      _BIT(31)
+
+/**********************************************************************
+* tsv1 register definitions
+**********************************************************************/
+/* Macro: The total number of bytes in the frame, not counting the
+   collided bytes. */
+#define TSV1_TRANSMIT_BYTE_COUNT(n)    ((n) & 0xFFFF)
+/* Macro: Number of collisions the current packet incurred during
+   transmission attempts. The maximum number of collisions
+   (16) cannot be represented. */
+#define TSV1_COLLISION_COUNT(n)        (((n) >> 16) & 0xF)
+
+/**********************************************************************
+* rsv register definitions
+**********************************************************************/
+/* Macro: Indicates length of received frame. */
+#define RSV_RECEIVED_BYTE_COUNT(n)     ((n) & 0xFFFF)
+/* Indicates that a packet was dropped. */
+#define RSV_RXDV_EVENT_IGNORED         _BIT(16)
+/* Indicates that the last receive event seen was not long
+   enough to be a valid packet. */
+#define RSV_RXDV_EVENT_PREVIOUSLY_SEEN _BIT(17)
+/* Indicates that at some time since the last receive statistics,
+   a carrier event was detected. */
+#define RSV_CARRIER_EVNT_PREVIOUS_SEEN _BIT(18)
+/* Indicates that MII data does not represent a valid receive
+   code. */
+#define RSV_RECEIVE_CODE_VIOLATION     _BIT(19)
+/* The attached CRC in the packet did not match the internally
+   generated CRC. */
+#define RSV_CRC_ERROR                  _BIT(20)
+/* Indicates the frame length field does not match the actual
+   number of data items and is not a type field. */
+#define RSV_LENGTH_CHECK_ERROR         _BIT(21)
+/* Indicates that frame type/length field was larger than 1518 bytes */
+#define RSV_LENGTH_OUT_OF_RANGE        _BIT(22)
+/* The packet had valid CRC and no symbol errors. */
+#define RSV_RECEIVE_OK                 _BIT(23)
+/* The packet destination was a multicast address. */
+#define RSV_MULTICAST                  _BIT(24)
+/* The packet destination was a boardcase address. */
+#define RSV_BROADCAST                  _BIT(25)
+/* Indicates that after the end of packet another 1-7 bits were
+   received. A single nibble, called dribble nibble, is formed
+   but not sent out. */
+#define RSV_DRIBBLE_NIBBLE             _BIT(26)
+/* The frame was a control frame. */
+#define RSV_CONTROL_FRAME              _BIT(27)
+/* The frame was a control frame with a valid PAUSE opcode. */
+#define RSV_PAUSE                      _BIT(28)
+/* The current frame was recognized as a Control Frame but
+   contains an unknown opcode. */
+#define RSV_UNSUPPORTED_OPCODE         _BIT(29)
+/* Frames length/type field contained 0x8100 which is the
+   VLAN protocol identifier. */
+#define RSV_VLAN                       _BIT(30)
+
+/**********************************************************************
+* flowcontrolcounter register definitions
+**********************************************************************/
+/* Macro: In full duplex mode the MirrorCounter specifies the number
+   of cycles before re-issuing the Pause control frame. */
+#define FCCR_MIRRORCOUNTER(n)          ((n) & 0xFFFF)
+/* Macro: In full-duplex mode the PauseTimer specifies the value
+   that is inserted into the pause timer field of a pause flow
+   control frame. In half duplex mode the PauseTimer
+   specifies the number of backpressure cycles. */
+#define FCCR_PAUSETIMER(n)             (((n) >> 16) & 0xFFFF)
+
+/**********************************************************************
+* flowcontrolstatus register definitions
+**********************************************************************/
+/* Macro: In full duplex mode this register represents the current
+   value of the datapaths mirror counter which counts up to
+   the value specified by the MirrorCounter field in the
+   FlowControlCounter register. In half duplex mode the
+   register counts until it reaches the value of the PauseTimer
+   bits in the FlowControlCounter register. */
+#define FCCR_MIRRORCOUNTERCURRENT(n)   ((n) & 0xFFFF)
+
+/**********************************************************************
+* rxfliterctrl, rxfilterwolstatus, and rxfilterwolclear shared
+* register definitions
+**********************************************************************/
+/* Unicast frame control */
+#define RXFLTRW_ACCEPTUNICAST          _BIT(0)
+/* Broadcase frame control. */
+#define RXFLTRW_ACCEPTUBROADCAST       _BIT(1)
+/* Multicast frame control */
+#define RXFLTRW_ACCEPTUMULTICAST       _BIT(2)
+/* Imperfect unicast frame control */
+#define RXFLTRW_ACCEPTUNICASTHASH      _BIT(3)
+/* Imperfect multicast frame control */
+#define RXFLTRW_ACCEPTUMULTICASTHASH   _BIT(4)
+/* Perfect frame control */
+#define RXFLTRW_ACCEPTPERFECT          _BIT(5)
+
+/**********************************************************************
+* rxfliterctrl register definitions
+**********************************************************************/
+/* When set to 1, the result of the magic packet filter will
+   generate a WoL interrupt when there is a match. */
+#define RXFLTRWSTS_MAGICPACKETENWOL    _BIT(12)
+/* When set to 1, the result of the perfect address
+   matching filter and the imperfect hash filter will
+   generate a WoL interrupt when there is a match. */
+#define RXFLTRWSTS_RXFILTERENWOL       _BIT(13)
+
+/**********************************************************************
+* rxfilterwolstatus register definitions
+**********************************************************************/
+/* When the value is 1, the receive filter caused WoL. */
+#define RXFLTRWSTS_RXFILTERWOL         _BIT(7)
+/* When the value is 1, the magic packet filter caused WoL. */
+#define RXFLTRWSTS_MAGICPACKETWOL      _BIT(8)
+
+/**********************************************************************
+* rxfilterwolclear register definitions
+**********************************************************************/
+/* When a 1 is written to one of these bits (7 and/or 8),
+   the corresponding status bit in the rxfilterwolstatus
+   register is cleared. */
+#define RXFLTRWCLR_RXFILTERWOL         RXFLTRWSTS_RXFILTERWOL
+#define RXFLTRWCLR_MAGICPACKETWOL      RXFLTRWSTS_MAGICPACKETWOL
+
+/**********************************************************************
+* intstatus, intenable, intclear, and Intset shared register
+* definitions
+**********************************************************************/
+/* Interrupt trigger on receive buffer overrun or descriptor underrun
+   situations. */
+#define MACINT_RXOVERRUNINTEN          _BIT(0)
+/* Enable for interrupt trigger on receive errors. */
+#define MACINT_RXERRORONINT            _BIT(1)
+/* Enable for interrupt triggered when all receive descriptors have
+   been processed i.e. on the transition to the situation where
+   ProduceIndex == ConsumeIndex. */
+#define MACINT_RXFINISHEDINTEN         _BIT(2)
+/* Enable for interrupt triggered when a receive descriptor has
+   been processed while the Interrupt bit in the Control field of the
+   descriptor was set. */
+#define MACINT_RXDONEINTEN             _BIT(3)
+/* Enable for interrupt trigger on transmit buffer or descriptor
+   underrun situations. */
+#define MACINT_TXUNDERRUNINTEN         _BIT(4)
+/* Enable for interrupt trigger on transmit errors. */
+#define MACINT_TXERRORINTEN            _BIT(5)
+/* Enable for interrupt triggered when all transmit descriptors
+   have been processed i.e. on the transition to the situation
+   where ProduceIndex == ConsumeIndex. */
+#define MACINT_TXFINISHEDINTEN         _BIT(6)
+/* Enable for interrupt triggered when a descriptor has been
+   transmitted while the Interrupt bit in the Control field of the
+   descriptor was set. */
+#define MACINT_TXDONEINTEN             _BIT(7)
+/* Enable for interrupt triggered by the SoftInt bit in the IntStatus
+   register, caused by software writing a 1 to the SoftIntSet bit in
+   the IntSet register. */
+#define MACINT_SOFTINTEN               _BIT(12)
+/* Enable for interrupt triggered by a Wakeup event detected by
+   the receive filter. */
+#define MACINT_WAKEUPINTEN             _BIT(13)
+
+/**********************************************************************
+* powerdown register definitions
+**********************************************************************/
+/* If true, all AHB accesses will return a read/write error,
+   except accesses to the PowerDown register. */
+#define POWERDOWN_MACAHB               _BIT(31)
+
+/* Macro pointing to ethernet MAC controller registers */
+#define ENETMAC ((ETHERNET_REGS_T *)(ETHERNET_BASE))
+
+
+
+
+
+
+
+
+
+
+/***********************************************************************
+ * SSP Module Register Structure
+ **********************************************************************/
+
+/* SSP Module Register Structure */
+typedef struct
+{
+  volatile unsigned long cr0;     /* SSP control register 0 */
+  volatile unsigned long cr1;     /* SSP control register 1 */
+  volatile unsigned long data;    /* SSP data register */
+  volatile unsigned long sr;      /* SSP status register */
+  volatile unsigned long cpsr;    /* SSP clock prescale register */
+  volatile unsigned long imsc;    /* SSP interrupt mask register */
+  volatile unsigned long ris;     /* SSP raw interrupt status register */
+  volatile unsigned long mis;     /* SSP masked interrupt status register */
+  volatile unsigned long icr;     /* SSP interrupt clear register */
+  volatile unsigned long dmacr;   /* SSP DMA enable register */
+} SSP_REGS_T;
+
+/***********************************************************************
+ * cr0 register definitions
+ **********************************************************************/
+/* SSP data size load macro, must be 4 bits to 16 bits */
+#define SSP_CR0_DSS(n)   _SBF(0, (((n) - 1) & 0xF)) // Data Size Select
+/* SSP control 0 Motorola SPI mode */
+#define SSP_CR0_FRF_SPI  0x00000000
+/* SSP control 0 TI synchronous serial mode */
+#define SSP_CR0_FRF_TI   0x00000010
+/* SSP control 0 National Microwire mode */
+#define SSP_CR0_FRF_NS   0x00000020
+/* SSP control 0 protocol mask */
+#define SSP_CR0_PRT_MSK  0x00000030
+/* SPI clock polarity bit (used in SPI mode only), (1) = maintains the
+   bus clock high between frames, (0) = low */
+#define SSP_CR0_CPOL(n)  _SBF(6, ((n) & 0x01))
+/* SPI clock out phase bit (used in SPI mode only), (1) = captures data
+   on the second clock transition of the frame, (0) = first */
+#define SSP_CR0_CPHA(n)  _SBF(7, ((n) & 0x01))
+/* SSP serial clock rate value load macro, divider rate is
+   PERIPH_CLK / (cpsr * (SCR + 1)) */
+#define SSP_CR0_SCR(n)   _SBF(8, ((n) & 0xFF))
+
+/***********************************************************************
+ * cr1 register definitions
+ **********************************************************************/
+/* SSP control 1 loopback mode enable bit */
+#define SSP_CR1_LBM         _BIT(0)
+/* SSP control 1 enable bit */
+#define SSP_CR1_SSE(n)      _SBF(1, ((n) & 0x01))
+#define SSP_CR1_SSP_ENABLE  _BIT(1)
+#define SSP_CR1_SSP_DISABLE 0
+/* SSP control 1 master/slave bit, (1) = master, (0) = slave */
+#define SSP_CR1_MS       _BIT(2)
+#define SSP_CR1_MASTER   0
+#define SSP_CR1_SLAVE    _BIT(2)
+/* SSP control 1 slave out disable bit, disables transmit line in slave
+   mode */
+#define SSP_CR1_SOD      _BIT(3)
+
+/***********************************************************************
+ * data register definitions
+ **********************************************************************/
+/* SSP data load macro */
+#define SSP_DATAMASK(n)   ((n) & 0xFFFF)
+
+/***********************************************************************
+ * SSP status register (sr) definitions
+ **********************************************************************/
+/* SSP status TX FIFO Empty bit */
+#define SSP_SR_TFE      _BIT(0)
+/* SSP status TX FIFO not full bit */
+#define SSP_SR_TNF      _BIT(1)
+/* SSP status RX FIFO not empty bit */
+#define SSP_SR_RNE      _BIT(2)
+/* SSP status RX FIFO full bit */
+#define SSP_SR_RFF      _BIT(3)
+/* SSP status SSP Busy bit */
+#define SSP_SR_BSY      _BIT(4)
+
+/***********************************************************************
+ * SSP clock prescaler register (cpsr) definitions
+ **********************************************************************/
+/* SSP clock prescaler load macro */
+#define SSP_CPSR_CPDVSR(n) _SBF(0, (n) & 0xFE)
+
+/***********************************************************************
+ * SSP interrupt registers (imsc, ris, mis, icr) definitions
+ **********************************************************************/
+/* SSP interrupt bit for RX FIFO overflow */
+#define SSP_IMSC_RORIM   _BIT(0)
+#define SSP_RIS_RORRIS   _BIT(0)
+#define SSP_MIS_RORMIS   _BIT(0)
+#define SSP_ICR_RORIC    _BIT(0)
+/* SSP interrupt bit for RX FIFO not empty and has a data timeout */
+#define SSP_IMSC_RTIM    _BIT(1)
+#define SSP_RIS_RTRIS    _BIT(1)
+#define SSP_MIS_RTMIS    _BIT(1)
+#define SSP_ICR_RTIC     _BIT(1)
+/* SSP interrupt bit for RX FIFO half full */
+#define SSP_IMSC_RXIM    _BIT(2)
+#define SSP_RIS_RXRIS    _BIT(2)
+#define SSP_MIS_RXMIS    _BIT(2)
+/* SSP interrupt bit for TX FIFO half empty */
+#define SSP_IMSC_TXIM    _BIT(3)
+#define SSP_RIS_TXRIS    _BIT(3)
+#define SSP_MIS_TXMIS    _BIT(3)
+
+/***********************************************************************
+ * SSP DMA enable register (dmacr) definitions
+ **********************************************************************/
+/* SSP bit for enabling RX DMA */
+#define SSP_DMA_RXDMAEN  _BIT(0)
+/* SSP bit for enabling TX DMA */
+#define SSP_DMA_TXDMAEN  _BIT(1)
+
+/* Macros pointing to SSP registers */
+#define SSP0  ((SSP_REGS_T *)(SSP0_BASE))
+
+
+
+/***********************************************************************
+* GPIO Module Register Structure
+**********************************************************************/
+
+/* GPIO Module Register Structure */
+typedef struct
+{
+  volatile unsigned long p3_inp_state;   /* Input pin state register */
+  volatile unsigned long p3_outp_set;    /* Output pin set register */
+  volatile unsigned long p3_outp_clr;    /* Output pin clear register */
+  volatile unsigned long p3_outp_state;  /* Output pin state register */
+  volatile unsigned long p2_dir_set;     /* GPIO direction set register */
+  volatile unsigned long p2_dir_clr;     /* GPIO direction clear register */
+  volatile unsigned long p2_dir_state;   /* GPIO direction state register */
+  volatile unsigned long p2_inp_state; /* SDRAM-Input pin state register*/
+  volatile unsigned long p2_outp_set;  /* SDRAM-Output pin set register */
+  volatile unsigned long p2_outp_clr;  /* SDRAM-Output pin clear register*/
+  volatile unsigned long p2_mux_set;     /* PIO mux control set register*/
+  volatile unsigned long p2_mux_clr;     /* PIO mux control clear register*/
+  volatile unsigned long p2_mux_state;   /* PIO mux state register */
+  volatile unsigned long reserved1 [3];
+  volatile unsigned long p0_inp_state;    /* P0 GPIOs pin read register */
+  volatile unsigned long p0_outp_set;    /* P0 GPIOs output set register */
+  volatile unsigned long p0_outp_clr;    /* P0 GPIOs output clear register */
+  volatile unsigned long p0_outp_state;  /* P0 GPIOs output state register */
+  volatile unsigned long p0_dir_set;     /* P0 GPIOs direction set reg */
+  volatile unsigned long p0_dir_clr;     /* P0 GPIOs direction clear reg */
+  volatile unsigned long p0_dir_state;   /* P0 GPIOs direction state reg */
+  volatile unsigned long reserved2;
+  volatile unsigned long p1_inp_state;    /* P1 GPIOs pin read register */
+  volatile unsigned long p1_outp_set;    /* P1 GPIOs output set register */
+  volatile unsigned long p1_outp_clr;    /* P1 GPIOs output clear register */
+  volatile unsigned long p1_outp_state;  /* P1 GPIOs output state register */
+  volatile unsigned long p1_dir_set;     /* P1 GPIOs direction set reg */
+  volatile unsigned long p1_dir_clr;     /* P1 GPIOs direction clear reg */
+  volatile unsigned long p1_dir_state;   /* P1 GPIOs direction state reg */
+  volatile unsigned long reserved3;
+  volatile unsigned long reserved4 [32];
+  volatile unsigned long p_mux_set;     /* PIO mux2 control set register*/
+  volatile unsigned long p_mux_clr;     /* PIO mux2 control clear register*/
+  volatile unsigned long p_mux_state;   /* PIO mux2 state register */
+  volatile unsigned long reserved5;
+  volatile unsigned long p3_mux_set;     /* PIO mux3 control set register*/
+  volatile unsigned long p3_mux_clr;     /* PIO mux3 control clear register*/
+  volatile unsigned long p3_mux_state;   /* PIO mux3 state register */
+  volatile unsigned long reserved6;
+  volatile unsigned long p0_mux_set;       /* P0 mux control set register*/
+  volatile unsigned long p0_mux_clr;       /* P0 mux control clear register*/
+  volatile unsigned long p0_mux_state;     /* P0 mux state register */
+  volatile unsigned long reserved7;
+  volatile unsigned long p1_mux_set;       /* P1 mux control set register*/
+  volatile unsigned long p1_mux_clr;       /* P1 mux control clear register*/
+  volatile unsigned long p1_mux_state;     /* P1 mux state register */
+} GPIO_REGS_T;
+
+/* For direction registers, a '1' is an output */
+#define GPIO_DIR_OUT          0x1
+
+/***********************************************************************
+* Input Pin State Register defines
+**********************************************************************/
+/* Input state of GPI_pin. Where pin = 0-9 */
+#define INP_STATE_GPI_00	  _BIT(0)
+#define INP_STATE_GPI_01	  _BIT(1)
+#define INP_STATE_GPI_02	  _BIT(2)
+#define INP_STATE_GPI_03	  _BIT(3)
+#define INP_STATE_GPI_04	  _BIT(4)
+#define INP_STATE_GPI_05	  _BIT(5)
+#define INP_STATE_GPI_06	  _BIT(6)
+#define INP_STATE_GPI_07	  _BIT(7)
+#define INP_STATE_GPI_08	  _BIT(8)
+#define INP_STATE_GPI_09	  _BIT(9)
+#define INP_STATE_GPIO_00	  _BIT(10)
+#define INP_STATE_GPIO_01	  _BIT(11)
+#define INP_STATE_GPIO_02	  _BIT(12)
+#define INP_STATE_GPIO_03	  _BIT(13)
+#define INP_STATE_GPIO_04	  _BIT(14)
+#define INP_STATE_U1_RX		  _BIT(15)
+#define INP_STATE_U2_HCTS	  _BIT(16)
+#define INP_STATE_U2_RX		  _BIT(17)
+#define INP_STATE_U3_RX		  _BIT(18)
+#define INP_STATE_GPI_19_U4RX _BIT(19)
+#define INP_STATE_U5_RX		  _BIT(20)
+#define INP_STATE_U6_IRRX	  _BIT(21)
+#define INP_STATE_U7_HCTS	  _BIT(22)
+#define INP_STATE_U7_RX		  _BIT(23)
+#define INP_STATE_GPIO_05	  _BIT(24)
+#define INP_STATE_SPI1_DATIN  _BIT(25)
+#define INP_STATE_SPI2_DATIN  _BIT(27)
+#define INP_STATE_GPI_28_U3RI _BIT(28)
+
+/***********************************************************************
+* p3_outp_set, p3_outp_clr, and p3_outp_state register defines
+**********************************************************************/
+/* Following macro is used to determine bit position for GPO pin in
+*  P3_OUTP_SET, P3_OUTP_CLR & P3_OUTP_STATE registers.
+*  Where pin = {0-23}
+*/
+#define OUTP_STATE_GPO(pin)	  _BIT((pin))
+
+/* Following macro is used to determine bit position for GPIO pin in
+*  PIO_OUTP_SET, P3_OUTP_CLR & P3_OUTP_STATE registers.
+*  Where pin = {0-5}
+*/
+#define OUTP_STATE_GPIO(pin)  _BIT(((pin) + 25))
+
+/***********************************************************************
+* GPIO Direction Register defines
+**********************************************************************/
+/* Following macro is used to determine bit position for GPIO pin in
+*  P2_DIR_SET, P2_DIR_STATE & P2_DIR_CLR registers.
+*  Where pin = {0-5}
+*/
+#define PIO_DIR_GPIO(pin)	 _BIT(((pin) + 25))
+
+/* Following macro is used to determine bit position for RAM_D pin in
+*  P2_DIR_SET, P2_DIR_CLR, P2_DIR_STATE, P2_INP_STATE,
+*  P2_OUTP_SET, & P2_OUTP_CLR.
+*  Where pin = {19-31}
+*/
+#define PIO_SDRAM_DIR_PIN(pin) _BIT(((pin) - 19))
+
+/* Macro for GPIO direction muxed with the high 16 bits of the SDRAM
+   data related bit locations (when configured as a GPIO) */
+#define PIO_SDRAM_PIN_ALL    0x00001FFF
+
+/***********************************************************************
+* p_mux_set, p_mux_clr, p_mux_state register defines
+**********************************************************************/
+/* Muxed PIO#0 pin state defines */
+#define P_I2STXSDA1_MAT31     _BIT(2)
+#define P_I2STXCLK1_MAT30     _BIT(3)
+#define P_I2STXWS1_CAP30      _BIT(4)
+#define P_SPI2DATAIO_MOSI1    _BIT(5)
+#define P_SPI2DATAIN_MISO1    _BIT(6)
+#define P_SPI2CLK_SCK1        _BIT(8)
+#define P_SPI1DATAIO_SSP0_MOSI _BIT(9)
+#define P_SPI1DATAIN_SSP0_MISO _BIT(10)
+#define P_SPI1CLK_SCK0        _BIT(12)
+#define P_MAT21_PWM36         _BIT(13)
+#define P_MAT20_PWM35         _BIT(14)
+#define P_U7TX_MAT11          _BIT(15)
+#define P_MAT03_PWM34         _BIT(17)
+#define P_MAT02_PWM33         _BIT(18)
+#define P_MAT01_PWM32         _BIT(19)
+#define P_MAT00_PWM31         _BIT(20)
+
+/***********************************************************************
+* p0_mux_set, p0_mux_clr, p0_mux_state register defines
+**********************************************************************/
+
+/* Following macro is used to determine bit position for a P0 GPIO pin
+   used with the p0_xxx registers for pins P0_0 to P0_7*/
+#define OUTP_STATE_GPIO_P0(pin)	  _BIT((pin))
+
+/* P0 pin mux defines (0 = GPIO, 1 = alternate function) */
+#define P0_GPOP0_I2SRXCLK1		  _BIT(0)
+#define P0_GPOP1_I2SRXWS1	      _BIT(1)
+#define P0_GPOP2_I2SRXSDA0	      _BIT(2)
+#define P0_GPOP3_I2SRXCLK0	      _BIT(3)
+#define P0_GPOP4_I2SRXWS0	      _BIT(4)
+#define P0_GPOP5_I2STXSDA0	      _BIT(5)
+#define P0_GPOP6_I2STXCLK0	      _BIT(6)
+#define P0_GPOP7_I2STXWS0	      _BIT(7)
+#define P0_ALL						0xFF
+
+/***********************************************************************
+* p1_mux_set, p1_mux_clr, p1_mux_state register defines
+**********************************************************************/
+
+/* Following macro is used to determine bit position for a P1 GPIO pin
+   used with the p1_xxx registers for pins P1_0 to P1_23*/
+#define OUTP_STATE_GPIO_P1(pin)	  _BIT((pin))
+
+/* Mask for all GPIO P1 bits */
+#define P1_ALL                    0x00FFFFFF
+
+/* Macro pointing to GPIO registers */
+#define GPIO  ((GPIO_REGS_T *)(GPIO_BASE))
+
+/***********************************************************************
+* p2_mux_set, p2_mux_clr, p2_mux_state register defines
+**********************************************************************/
+/* Muxed PIO#2 pin state defines */
+#define P2_GPIO05_SSEL0			_BIT(5)
+#define P2_GPIO04_SSEL1			_BIT(4)
+#define P2_SDRAMD19D31_GPIO		_BIT(3)
+#define P2_GPO21_U4TX	        _BIT(2)
+#define P2_GPIO03_KEYROW7		_BIT(1)
+#define P2_GPIO02_KEYROW6		_BIT(0)
+
+/***********************************************************************
+* p3_mux_set, p3_mux_clr, p3_mux_state register defines
+**********************************************************************/
+/* Muxed PIO#3 pin states, first column is '0' state, second is '1' */
+#define P3_GPO2_MAT10          _BIT(2)
+#define P3_GPO6_PWM43          _BIT(6)
+#define P3_GPO8_PWM42          _BIT(8)
+#define P3_GPO9_PWM41          _BIT(9)
+#define P3_GPO10_PWM36         _BIT(10)
+#define P3_GPO12_PWM35         _BIT(12)
+#define P3_GPO13_PWM34         _BIT(13)
+#define P3_GPO15_PWM33         _BIT(15)
+#define P3_GPO16_PWM32         _BIT(16)
+#define P3_GPO18_PWM31         _BIT(18)
+
+
+#endif /* __LPC3250_H */
+
-- 
1.7.0.4


From bf7aaeb0c1b2c9732c0ad313315ae4d6b1d24b3b Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:46:41 -0700
Subject: [PATCH 02/28] Added EA3250 board support

---
 Makefile                        |    3 +
 board/ea3250/Makefile           |   52 ++++
 board/ea3250/config.mk          |   37 +++
 board/ea3250/ea3250.c           |  424 +++++++++++++++++++++++++++++
 board/ea3250/ea3250_prv.h       |   68 +++++
 board/ea3250/lowlevel_init.S    |   63 +++++
 board/ea3250/lowlevelsys_init.c |   45 +++
 board/ea3250/nand.c             |  188 +++++++++++++
 board/ea3250/net.c              |  562 +++++++++++++++++++++++++++++++++++++++
 board/ea3250/u-boot.lds         |   56 ++++
 include/configs/ea3250.h        |  322 ++++++++++++++++++++++
 include/lpc3250.h               |  212 +++++++++++++++-
 12 files changed, 2031 insertions(+), 1 deletions(-)
 create mode 100644 board/ea3250/Makefile
 create mode 100644 board/ea3250/config.mk
 create mode 100644 board/ea3250/ea3250.c
 create mode 100644 board/ea3250/ea3250_prv.h
 create mode 100644 board/ea3250/lowlevel_init.S
 create mode 100644 board/ea3250/lowlevelsys_init.c
 create mode 100644 board/ea3250/nand.c
 create mode 100644 board/ea3250/net.c
 create mode 100644 board/ea3250/u-boot.lds
 create mode 100644 include/configs/ea3250.h

diff --git a/Makefile b/Makefile
index 7b6ae40..a79ef66 100644
--- a/Makefile
+++ b/Makefile
@@ -2715,6 +2715,9 @@ at91sam9rlek_config	:	unconfig
 phy3250_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm926ejs phy3250 NULL lpc3250
 
+ea3250_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs ea3250 NULL lpc3250
+
 ########################################################################
 ## ARM Integrator boards - see doc/README-integrator for more info.
 integratorap_config	\
diff --git a/board/ea3250/Makefile b/board/ea3250/Makefile
new file mode 100644
index 0000000..55b71e5
--- /dev/null
+++ b/board/ea3250/Makefile
@@ -0,0 +1,52 @@
+#
+# Copyright (C) 2008 by NXP Semiconductors
+# All rights reserved.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= ea3250.o nand.o net.o
+COBJS	+= lowlevelsys_init.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/ea3250/config.mk b/board/ea3250/config.mk
new file mode 100644
index 0000000..ea29fb3
--- /dev/null
+++ b/board/ea3250/config.mk
@@ -0,0 +1,37 @@
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# Embedded Artists LPC3250 OEM Board with or without S1L
+#
+
+#
+# 64 MB SDRAM @ 0x80000000
+#
+# Linux-Kernel is @ 0x80008000, entry 0x80008000
+# params @ 0x80000100
+# optionally with a ramdisk at 0x80300000
+#
+# we load ourself to 0x00000000 or 0x83FC0000
+#
+# download area is 0x80f00000
+#
+
+TEXT_BASE = 0x83FA0000
+
diff --git a/board/ea3250/ea3250.c b/board/ea3250/ea3250.c
new file mode 100644
index 0000000..f27c229
--- /dev/null
+++ b/board/ea3250/ea3250.c
@@ -0,0 +1,424 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Based on code by Kevin Wells
+ * @Descr: Embedded Artists LPC3250 OEM Board support functions
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <configs/ea3250.h>
+#include <asm/mach-types.h>
+#include <lpc3250.h>
+#include <net.h>
+#include "ea3250_prv.h"
+		
+DECLARE_GLOBAL_DATA_PTR;
+extern int dcache_kill(void);
+
+/* ISP1301 USB transceiver I2C registers */
+#define	ISP1301_MODE_CONTROL_1		0x04	/* u8 read, set, +1 clear */
+
+#define	MC1_SPEED_REG		(1 << 0)
+#define	MC1_SUSPEND_REG		(1 << 1)
+#define	MC1_DAT_SE0		(1 << 2)
+#define	MC1_TRANSPARENT		(1 << 3)
+#define	MC1_BDIS_ACON_EN	(1 << 4)
+#define	MC1_OE_INT_EN		(1 << 5)
+#define	MC1_UART_EN		(1 << 6)
+#define	MC1_MASK		0x7f
+
+#define	ISP1301_MODE_CONTROL_2		0x12	/* u8 read, set, +1 clear */
+
+#define	MC2_GLOBAL_PWR_DN	(1 << 0)
+#define	MC2_SPD_SUSP_CTRL	(1 << 1)
+#define	MC2_BI_DI		(1 << 2)
+#define	MC2_TRANSP_BDIR0	(1 << 3)
+#define	MC2_TRANSP_BDIR1	(1 << 4)
+#define	MC2_AUDIO_EN		(1 << 5)
+#define	MC2_PSW_EN		(1 << 6)
+#define	MC2_EN2V7		(1 << 7)
+
+#define	ISP1301_OTG_CONTROL_1		0x06	/* u8 read, set, +1 clear */
+#	define	OTG1_DP_PULLUP		(1 << 0)
+#	define	OTG1_DM_PULLUP		(1 << 1)
+#	define	OTG1_DP_PULLDOWN	(1 << 2)
+#	define	OTG1_DM_PULLDOWN	(1 << 3)
+#	define	OTG1_ID_PULLDOWN	(1 << 4)
+#	define	OTG1_VBUS_DRV		(1 << 5)
+#	define	OTG1_VBUS_DISCHRG	(1 << 6)
+#	define	OTG1_VBUS_CHRG		(1 << 7)
+#define	ISP1301_OTG_STATUS		0x10	/* u8 readonly */
+#	define	OTG_B_SESS_END		(1 << 6)
+#	define	OTG_B_SESS_VLD		(1 << 7)
+
+#define ISP1301_I2C_ADDR 0x2D
+
+#define ISP1301_I2C_MODE_CONTROL_1 0x4
+#define ISP1301_I2C_MODE_CONTROL_2 0x12
+#define ISP1301_I2C_OTG_CONTROL_1 0x6
+#define ISP1301_I2C_OTG_CONTROL_2 0x10
+#define ISP1301_I2C_INTERRUPT_SOURCE 0x8
+#define ISP1301_I2C_INTERRUPT_LATCH 0xA
+#define ISP1301_I2C_INTERRUPT_FALLING 0xC
+#define ISP1301_I2C_INTERRUPT_RISING 0xE
+#define ISP1301_I2C_REG_CLEAR_ADDR 1
+
+
+#define I2C_START_BIT (1 << 8)
+#define I2C_STOP_BIT  (1 << 9)
+
+#define I2C_READ      0x01
+#define I2C_WRITE     0x00
+#define DUMMY_BYTE    0x55
+
+void reset_timer (void)
+{
+	unsigned int clkdlycnt, tbaseclk;
+
+	/* Reset timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR0->tcr = 0;
+	TIMER_CNTR0->tc = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR0->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR0->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
+	/* Set prescale counter value for a 1mS tick */
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	clkdlycnt = (tbaseclk / CONFIG_SYS_HZ);
+	TIMER_CNTR0->pr = clkdlycnt - 1;
+
+	/* Enable the timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_EN;
+}
+
+ulong get_timer (ulong base)
+{
+	ulong tcr = TIMER_CNTR0->tc;
+	return tcr;
+}
+
+void timer_init(void)
+{
+	/* Enable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
+		CLKPWR_TMRPWMCLK_TIMER0_EN;
+
+	reset_timer();
+}
+
+/*
+ * Use the watchdog timer to reset the system
+ */
+void reset_cpu(ulong addr)
+{
+	/* Enable the WDT clock */
+	CLKPWR->clkpwr_timer_clk_ctrl |= CLKPWR_PWMCLK_WDOG_EN;
+
+	/* Force RESETOUT_N active */
+	WDT->wdtim_mctrl = WDT_RESFRC1;
+	WDT->wdtim_ctrl = WDT_COUNT_ENAB;
+
+	/* Wait forever */
+	while (1);
+}
+
+void udelay(unsigned long usec)
+{
+	unsigned long tbaseclk;
+
+	/* Enable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
+		CLKPWR_TMRPWMCLK_TIMER1_EN;
+
+	/* Reset timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR1->tcr = 0;
+	TIMER_CNTR1->tc = 0;
+	TIMER_CNTR1->pr = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR1->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR1->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
+	/* Set prescale counter value for a 1uS tick */
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	tbaseclk = (tbaseclk / 1000000) - 1;
+	TIMER_CNTR1->pr = tbaseclk;
+
+	/* Set match for number of usecs */
+	TIMER_CNTR1->mr[0] = usec;
+
+	/* Interrupt on match 0 */
+	TIMER_CNTR1->mcr = TIMER_CNTR_MCR_MTCH(0);
+
+	/* Enable the timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_EN;
+
+	/* Loop until match occurs */
+	while ((TIMER_CNTR1->ir & TIMER_CNTR_MTCH_BIT(0)) == 0);
+
+	/* Stop timer */
+	TIMER_CNTR1->tcr = 0;
+
+	/* Disable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 &=
+		~CLKPWR_TMRPWMCLK_TIMER1_EN;
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+int board_init (void)
+{
+	/* Kill data cache */
+	dcache_kill();
+
+	/* arch number of Logic-Board - MACH_TYPE_LPC3XXX */
+	gd->bd->bi_arch_number = MACH_TYPE_UBOOTSYS;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_ENV_ADDR;
+
+	return 0;
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+
+	/* 64M */
+	gd->bd->bi_dram[0].size = 0x04000000; /* 64M */
+
+	return 0;
+}
+
+
+static int i2c_wait_reset(int timeout)
+{
+	while(timeout > 0 && (OTG->otg_i2c.otg_i2c_ctrl & I2C_RESET))
+	{
+		udelay(1000);
+		timeout--;
+	}
+
+	return (timeout <= 0);	
+}
+
+
+static int isp1301_get_value(int reg)
+{
+	int n = 0;
+
+	/* send isp1301 address */
+	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT);   
+
+	/* register (offset) to read from */
+	OTG->otg_i2c.otg_i2c_txrx = reg;   
+
+	/* repeat start */
+	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT | I2C_READ);
+	OTG->otg_i2c.otg_i2c_txrx = (I2C_STOP_BIT | DUMMY_BYTE);
+
+	while (((OTG->otg_i2c.otg_i2c_stat & I2C_TDI) != I2C_TDI) && n++ < 100000);
+
+	if (n>= 100000)
+	{
+		printf("isp1301_get_value: ERROR TDI not set\n");
+	}
+
+	/* clear TDI */
+	OTG->otg_i2c.otg_i2c_stat |= I2C_TDI;
+
+	return (OTG->otg_i2c.otg_i2c_txrx & 0xff);
+}
+
+static int isp1301_set_value(int reg, int value)
+{
+	int n = 0;
+
+	/* send isp1301 address */
+	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT);   
+
+	/* offset to write to */
+	OTG->otg_i2c.otg_i2c_txrx = (reg | I2C_WRITE);   
+	/* value to write */
+	OTG->otg_i2c.otg_i2c_txrx = (value | I2C_STOP_BIT);  
+  
+	/* wait for transmit done (TDI) */
+	while (((OTG->otg_i2c.otg_i2c_stat & I2C_TDI) != I2C_TDI) && n++ < 100000);
+
+	if (n>= 100000)
+	{
+		printf("isp1301_set_value: ERROR TDI not set\n");
+		return -1;		
+	}
+  
+	/* clear TDI */
+	OTG->otg_i2c.otg_i2c_stat |= I2C_TDI;     
+
+	return 0;
+}
+
+static void isp1301_configure(void)
+{
+	OTG->otg_i2c.otg_i2c_clk_hi = 0x3f;
+	OTG->otg_i2c.otg_i2c_clk_lo = 0x3f; 
+
+	OTG->otg_i2c.otg_i2c_ctrl |= I2C_RESET;	
+	i2c_wait_reset(100);
+
+	/* LPC32XX only supports DAT_SE0 USB mode */
+	/* This sequence is important */
+
+	/* Disable transparent UART mode first */
+	isp1301_set_value((ISP1301_I2C_MODE_CONTROL_1 |
+		ISP1301_I2C_REG_CLEAR_ADDR), MC1_UART_EN);
+
+	isp1301_set_value((ISP1301_I2C_MODE_CONTROL_1 |
+		ISP1301_I2C_REG_CLEAR_ADDR), ~MC1_SPEED_REG);
+	isp1301_set_value(ISP1301_I2C_MODE_CONTROL_1, MC1_SPEED_REG);
+	isp1301_set_value((ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);
+	isp1301_set_value(ISP1301_I2C_MODE_CONTROL_2, 
+		(MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL));
+
+	isp1301_set_value((ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);
+	isp1301_set_value(ISP1301_I2C_MODE_CONTROL_1, MC1_DAT_SE0);
+	isp1301_set_value(ISP1301_I2C_OTG_CONTROL_1, 
+		(OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN));
+	isp1301_set_value((ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),
+		(OTG1_DM_PULLUP | OTG1_DP_PULLUP));
+	isp1301_set_value((ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR), ~0);
+	isp1301_set_value((ISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR), ~0);
+	isp1301_set_value((ISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR), ~0);
+
+	/* Enable usb_need_clk clock after transceiver is initialized */
+	CLKPWR->clkpwr_usb_ctrl |= (CLKPWR_USBCTRL_USBDVND_EN);
+
+
+	printf("\nISP1301 Vendor ID  : 0x%04x\n", 
+		(isp1301_get_value(0x00) | (isp1301_get_value(0x01) << 8)));
+	printf("ISP1301 Product ID : 0x%04x\n", 
+		(isp1301_get_value(0x02) | (isp1301_get_value(0x03) << 8)));
+	printf("ISP1301 Version ID : 0x%04x\n", 
+		(isp1301_get_value(0x14) | (isp1301_get_value(0x15) << 8)));
+	
+}
+
+static void usbpll_setup(void)
+{
+	int n = 0;
+
+	/* make sure clocks are disabled */
+	CLKPWR->clkpwr_usb_ctrl &= ~(CLKPWR_USBCTRL_CLK_EN1 | CLKPWR_USBCTRL_CLK_EN2);
+
+
+	/* start PLL clock input */
+	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_CLK_EN1;
+
+
+	/* 
+         * Setup PLL.  
+         *
+         */
+	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_FDBK_PLUS1(192-1);
+	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_POSTDIV_2POW(0x01);
+	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_PLL_PWRUP;
+ 
+	
+	while ((CLKPWR->clkpwr_usb_ctrl & CLKPWR_USBCTRL_PLL_STS) == 0)
+	{
+		if (n++ >= 100000)
+		{
+			printf("usbpll_setup: ERROR PLL doesn't lock\n");
+			break;
+		}
+	}
+
+	/* enable PLL output */
+	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_CLK_EN2;		
+}
+
+
+int usb_board_init(void)
+{
+	/* enable AHB slave USB clock */
+	CLKPWR->clkpwr_usb_ctrl |= 
+		(CLKPWR_USBCTRL_HCLK_EN | CLKPWR_USBCTRL_BUS_KEEPER);
+
+	/* enable I2C clock in OTG block if it isn't */
+	if ((OTG->otg_clk_sts & OTG_CLK_I2C_EN) != OTG_CLK_I2C_EN)
+	{
+		OTG->otg_clk_ctrl = OTG_CLK_I2C_EN;
+
+		while (OTG->otg_clk_sts != OTG_CLK_I2C_EN);
+	}
+
+	/* Configure ISP1301 */
+	isp1301_configure();
+
+	/* setup USB clocks and PLL */
+	usbpll_setup();
+
+	/* enable usb_host_need_clk */
+	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_USBHSTND_EN;
+
+	/* enable all needed USB clocks */
+	OTG->otg_clk_ctrl = (OTG_CLK_AHB_EN|OTG_CLK_OTG_EN
+		|OTG_CLK_I2C_EN|OTG_CLK_HOST_EN);
+
+	while ((OTG->otg_clk_ctrl & (OTG_CLK_AHB_EN|OTG_CLK_OTG_EN
+		|OTG_CLK_I2C_EN|OTG_CLK_HOST_EN)) !=
+	       (OTG_CLK_AHB_EN|OTG_CLK_OTG_EN
+		|OTG_CLK_I2C_EN|OTG_CLK_HOST_EN)) ;
+	
+	OTG->otg_sts_ctrl |= OTG_HOST_EN;
+	isp1301_set_value(ISP1301_I2C_OTG_CONTROL_1, OTG1_VBUS_DRV);
+
+	return 0;
+}
+
+int usb_board_stop(void)
+{
+	/* vbus off */
+	isp1301_set_value(
+		(ISP1301_I2C_OTG_CONTROL_1| ISP1301_I2C_REG_CLEAR_ADDR), 
+		OTG1_VBUS_DRV);
+
+	OTG->otg_sts_ctrl &= ~OTG_HOST_EN;
+
+	CLKPWR->clkpwr_usb_ctrl &= ~CLKPWR_USBCTRL_HCLK_EN;
+
+	return 0;
+}
+
+int usb_board_init_fail(void)
+{
+	usb_board_stop();
+
+	return 0;
+}
diff --git a/board/ea3250/ea3250_prv.h b/board/ea3250/ea3250_prv.h
new file mode 100644
index 0000000..2cae978
--- /dev/null
+++ b/board/ea3250/ea3250_prv.h
@@ -0,0 +1,68 @@
+/***********************************************************************
+ * $Id::$
+ *
+ * Project: Embedded Artists LPC3250 OEM Board definitions
+ *
+ * Description:
+ *     This file contains board specific information such as the
+ *     chip select wait states, and other board specific information.
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+#ifndef EA3250_PRV_H
+#define EA3250_PRV_H
+
+
+// Enable the following define to setup for RMII mode
+#define USE_PHY_RMII
+
+// PHY address (configured via PHY ADRx pins)
+#define PHYDEF_PHYADDR           0x0001
+
+//------------------------------------------------------------------------------
+// PHY register and bitfield data
+//------------------------------------------------------------------------------
+
+// PHY Register indices
+#define PHY_REG_BMCR             0x00        // Basic Mode Control Register
+#define PHY_REG_BMSR             0x01        // Basic Mode Status Register
+#define PHY_REG_IDR1             0x02        // PHY Identifier 1
+#define PHY_REG_IDR2             0x03        // PHY Identifier 2
+#define PHY_REG_ANAR             0x04        // Auto-Negotiation Advertisement
+#define PHY_REG_ANLPAR           0x05        // Auto-Neg. Link Partner Abitily
+#define PHY_REG_ANER             0x06        // Auto-Neg. Expansion Register
+#define PHY_REG_ANNPTR           0x07        // Auto-Neg. Next Page TX
+
+// BMCR register specific control bits
+#define PHY_BMCR_RESET_BIT         0x8000    // Reset bit
+#define PHY_BMCR_SPEED_BIT         0x2000    // 100M speed enable bit
+#define PHY_BMCR_AUTON_BIT         0x1000    // Auto-negotiation rate bit
+
+// BMSR register specific control bits
+#define PHY_BMSR_LINKUP_STATUS     0x0004    // Link up status bit
+#define PHY_BMSR_AUTON_COMPLETE    0x0020    // Auto-negotiation complete bit
+#define PHY_BMSR_10M_HALF          0x0800    // 10MBase with half duplex support
+#define PHY_BMSR_10M_FULL          0x1000    // 10MBase with full duplex support
+#define PHY_BMSR_TX_HALF           0x2000    // TX with half duplex support
+#define PHY_BMSR_TX_FULL           0x4000    // TX with full duplex support
+#define PHY_BMSR_T4_ABLE           0x8000    // T4 able
+
+// Maximum ethernet frame size, maximum RX and TX packets
+#define ENET_MAXF_SIZE             1536
+#define ENET_MAX_TX_PACKETS        16
+#define ENET_MAX_RX_PACKETS        16
+
+
+
+#endif /* EA3250_PRV_H */
diff --git a/board/ea3250/lowlevel_init.S b/board/ea3250/lowlevel_init.S
new file mode 100644
index 0000000..feed40a
--- /dev/null
+++ b/board/ea3250/lowlevel_init.S
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Based on code by Kevin Wells
+ * @Descr: Embedded Artists LPC3250 OEM Board low level init code
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+#define IRAM_STK_TEMP 0x0003C000
+.globl ea3250_sys_init
+.globl dcache_kill
+
+.globl lowlevel_init
+lowlevel_init:
+	/*
+	 * Setup basic stack and save return address
+	 */
+	ldr	sp, =IRAM_STK_TEMP
+	stmia	sp, {lr}
+
+	/*
+	 * Initialize EA3250 board
+	 */
+	bl	ea3250_sys_init
+
+	ldmia	sp, {r0}
+	mov	pc, r0
+
+dcache_kill:
+	/*
+	 * The data cache may have been enabled when booting from
+	 * S1l, so disable it now to prevent problems.
+	 */
+flush1:
+	mrc	p15, 0, r15, c7, c10, 3
+	bne	flush1
+	mcr	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #4
+	mrc	p15, 0, r0, c1, c0, 0
+	mov	pc, lr
+
diff --git a/board/ea3250/lowlevelsys_init.c b/board/ea3250/lowlevelsys_init.c
new file mode 100644
index 0000000..11e4e4a
--- /dev/null
+++ b/board/ea3250/lowlevelsys_init.c
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Based on code by Kevin Wells
+ * @Descr: Embedded Artists LPC3250 OEM Board support functions
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <configs/ea3250.h>
+#include <asm/mach-types.h>
+#include <lpc3250.h>
+#include <net.h>
+#include "ea3250_prv.h"
+
+/*
+ * Miscellaneous platform dependent initializations
+ */
+void ea3250_sys_init(void)
+{
+
+#ifndef CFG_BOOT_USES1L
+	/* Initialize system including clocking, SDRAM, muxing, MMU, etc. */
+	/* TBD stubbed - NOT SUPPORTED */
+#endif
+}
+
diff --git a/board/ea3250/nand.c b/board/ea3250/nand.c
new file mode 100644
index 0000000..d7f8c04
--- /dev/null
+++ b/board/ea3250/nand.c
@@ -0,0 +1,188 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include "lpc3250.h"
+#include <nand.h>
+#include <asm/errno.h>
+
+#define	NAND_ALE_OFFS   4
+#define	NAND_CLE_OFFS   8
+
+static void ea3250_nand_init(void)
+{
+	/* Enable clocks to the SLC NAND controller */
+	CLKPWR->clkpwr_nand_clk_ctrl = 0x05;
+
+        /* Reset SLC NAND controller & clear ECC */
+        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
+
+        /* 8-bit bus, no DMA, CE normal */
+        SLCNAND->slc_cfg = 0;
+
+        /* Interrupts disabled and cleared */
+        SLCNAND->slc_ien = 0;
+        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
+
+        SLCNAND->slc_tac = (SLCTAC_WDR(14) |
+                    SLCTAC_WWIDTH(5) |
+                    SLCTAC_WHOLD(2) |
+                    SLCTAC_WSETUP(1) |
+                    SLCTAC_RDR(14) |
+                    SLCTAC_RWIDTH(4) |
+                    SLCTAC_RHOLD(2) |
+                    SLCTAC_RSETUP(1));
+}
+
+static void ea3250_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+	ulong *pCMD, IO_ADDR_W;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		IO_ADDR_W = (ulong) this->IO_ADDR_W;
+		IO_ADDR_W &= ~(NAND_CLE_OFFS | NAND_ALE_OFFS);
+
+		if ( ctrl & NAND_CLE ) {
+			IO_ADDR_W |= NAND_CLE_OFFS;
+		}
+		else if ( ctrl & NAND_ALE ) {
+			IO_ADDR_W |= NAND_ALE_OFFS;
+		}
+
+		if ( ctrl & NAND_NCE ) {
+			SLCNAND->slc_cfg |= SLCCFG_CE_LOW;
+		}
+		else {
+			SLCNAND->slc_cfg &= ~SLCCFG_CE_LOW;
+		}
+
+		this->IO_ADDR_W = (void *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		pCMD = (ulong *) this->IO_ADDR_W;
+		*pCMD = cmd;
+	}
+}
+
+static int ea3250_nand_ready(struct mtd_info *mtd)
+{
+	/* Check the SLC NAND controller status */
+	return (SLCNAND->slc_stat & SLCSTAT_NAND_READY);
+}
+
+static u_char ea3250_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+	tmp32 = *pReg;
+	return (u_char) tmp32;
+}
+
+/**
+ * ea3250_write_buf - [DEFAULT] write buffer to chip
+ * @mtd:	MTD device structure
+ * @buf:	data buffer
+ * @len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ */
+static void ea3250_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_W;
+
+	for (i=0; i<len; i++)
+		*pReg = (unsigned long) buf[i];
+}
+
+/**
+ * ea3250_read_buf - [DEFAULT] read chip data into buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer to store date
+ * @len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ */
+static void ea3250_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+
+	for (i=0; i<len; i++)
+	{
+		tmp32 = *pReg;
+		buf[i] = (u_char) tmp32;
+	}
+}
+
+/**
+ * nand_verify_buf - [DEFAULT] Verify chip data against buffer
+ * @mtd:	MTD device structure
+ * @buf:	buffer containing the data to compare
+ * @len:	number of bytes to compare
+ *
+ * Default verify function for 8bit buswith
+ */
+static int ea3250_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+
+	for (i=0; i<len; i++)
+	{
+		tmp32 = *pReg;
+		if (buf[i] != (u_char) tmp32)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	/* Initial NAND interface */
+	ea3250_nand_init();
+
+	nand->ecc.mode = NAND_ECC_SOFT;
+	nand->cmd_ctrl = ea3250_nand_hwcontrol;
+	nand->dev_ready = ea3250_nand_ready;
+	nand->chip_delay = 2000;
+
+	nand->read_byte = ea3250_read_byte;
+	nand->write_buf = ea3250_write_buf;
+	nand->read_buf = ea3250_read_buf;
+	nand->verify_buf = ea3250_verify_buf;
+
+	return 0;
+}
diff --git a/board/ea3250/net.c b/board/ea3250/net.c
new file mode 100644
index 0000000..e17700b
--- /dev/null
+++ b/board/ea3250/net.c
@@ -0,0 +1,562 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Based on code by Kevin Wells
+ * @Descr: Embedded Artists LPC3250 OEM Board net interface support functions
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <lpc3250.h>
+#include <configs/ea3250.h>
+#include "ea3250_prv.h"
+
+static unsigned long g_dmabase;
+static unsigned long gdma_size;
+static TXRX_DESC_T *pTXDesc;
+static unsigned long *pTXStatus;
+static unsigned long pTXVBuffs [ENET_MAX_TX_PACKETS];
+static TXRX_DESC_T *pRXDesc;
+static RX_STATUS_T *pRXStatus;
+static unsigned long pRXVBuffs [ENET_MAX_RX_PACKETS];
+#ifndef USE_IRAM_FOR_ETH_BUFFERS
+static unsigned long ethbuffs[4096];
+#endif
+
+
+static void msDelay(unsigned long ms)
+{
+	udelay(ms * 1000);
+}
+
+//------------------------------------------------------------------------------
+static int RMII_Write (unsigned long PhyReg, unsigned long Value)
+{
+	unsigned long mst = 250;
+	int sts = 0;
+
+	// Write value at PHY address and register
+	ENETMAC->madr = (PHYDEF_PHYADDR << 8) | PhyReg;
+	ENETMAC->mwtd = Value;
+
+	// Wait for unbusy status
+	while (mst > 0)
+	{
+		if ((ENETMAC->mind & MIND_BUSY) == 0)
+		{
+			mst = 0;
+			sts = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	return sts;
+}
+
+//------------------------------------------------------------------------------
+int RMII_Read(unsigned long PhyReg, unsigned long *data) 
+{
+	unsigned long mst = 250;
+	int sts = 0;
+
+	// Read value at PHY address and register
+	ENETMAC->madr = (PHYDEF_PHYADDR << 8) | PhyReg;
+	ENETMAC->mcmd = MCMD_READ;
+
+	// Wait for unbusy status
+	while (mst > 0)
+	{
+		if ((ENETMAC->mind & MIND_BUSY) == 0)
+		{
+			mst = 0;
+			*data = ENETMAC->mrdd;
+			sts = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	ENETMAC->mcmd = 0;
+
+	return sts;
+}
+
+//------------------------------------------------------------------------------
+int HYPHYReset(void)
+{
+	int goodacc;
+	unsigned long tmp1, mst;
+
+	// Reset the PHY and wait for reset to complete
+	goodacc = RMII_Write(PHY_REG_BMCR, PHY_BMCR_RESET_BIT);
+	if (goodacc == 0)
+	{
+		return 0;
+	}
+	mst = 400;
+	goodacc = 0;
+	while (mst > 0)
+	{
+		RMII_Read(PHY_REG_BMCR, &tmp1);
+		if ((tmp1 & PHY_BMCR_RESET_BIT) == 0)
+		{
+			mst = 0;
+			goodacc = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	return goodacc;
+}
+
+//------------------------------------------------------------------------------
+int txrx_setup(void)
+{
+	int idx;
+	unsigned long *pTXStatusL, pbase1, pbase2, pbase3;
+	TXRX_DESC_T *pTXRXDesc;
+	RX_STATUS_T *pRXStatusL;
+
+	// Get physical address and size of DMA buffers
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+	g_dmabase = (unsigned long) IRAM_ETH_BUFF_BASE;
+	gdma_size = IRAM_ETH_BUFF_SIZE;
+#else
+	g_dmabase = (unsigned long) &ethbuffs;
+	gdma_size = sizeof(ethbuffs);
+#endif
+
+	// Setup base pointers
+	pbase1 = g_dmabase;     // Start of descriptors
+	pbase2 = pbase1 + 256;  // Start of statuses
+	pbase3 = pbase1 + 1024; // Start of buffers
+
+	// Setup pointers to TX structures
+	ENETMAC->txdescriptor =  pbase1;
+	ENETMAC->txstatus = pbase2;
+	ENETMAC->txdescriptornumber = (ENET_MAX_TX_PACKETS - 1);
+
+	// Save base address of TX descriptor table and TX status
+	pTXRXDesc = (TXRX_DESC_T *) pbase1;
+	pTXStatusL = (unsigned long *) pbase2;
+	pTXDesc = pTXRXDesc;
+	pTXStatus = pTXStatusL;
+
+	// Build TX descriptors
+	for (idx = 0; idx < ENET_MAX_TX_PACKETS; idx++)
+	{
+		pTXRXDesc->packet = pbase3;
+		pTXRXDesc->control = 0;
+		*pTXStatusL = 0;
+
+		// Save virtual address of buffer
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+		pTXVBuffs [idx] = (unsigned long) pbase3;
+#else
+#pragma error "NOT supported"
+#endif
+
+		// Next descriptor and status
+		pTXRXDesc++;
+		pTXStatusL++;
+		pbase1 += sizeof (TXRX_DESC_T);
+		pbase2 += sizeof (unsigned long);
+		pbase3 += ENET_MAXF_SIZE;
+	}
+
+	// Setup pointers to RX structures
+	ENETMAC->rxdescriptor = pbase1;
+	ENETMAC->rxstatus = pbase2;
+	ENETMAC->rxdescriptornumber = (ENET_MAX_RX_PACKETS - 1);
+
+	// Save base address of RX descriptor table and RX status
+	pRXDesc = pTXRXDesc;
+	pRXStatus = pRXStatusL = (RX_STATUS_T *) pTXStatusL;
+
+	// Build RX descriptors
+	for (idx = 0; idx < ENET_MAX_TX_PACKETS; idx++)
+	{
+		pTXRXDesc->packet = pbase3;
+		pTXRXDesc->control = 0x80000000 | (ENET_MAXF_SIZE - 1);
+		pRXStatusL->statusinfo = 0;
+		pRXStatusL->statushashcrc = 0;
+
+		// Save virtual address of buffer
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+		pRXVBuffs [idx] = (unsigned long) pbase3;
+#else
+#pragma error "NOT supported"
+#endif
+
+		// Next descriptor and status
+		pTXRXDesc++;
+		pRXStatusL++;
+		pbase1 += sizeof (TXRX_DESC_T);
+		pbase2 += sizeof (unsigned long);
+		pbase3 += ENET_MAXF_SIZE;
+	}
+
+    return 1;
+}
+
+//------------------------------------------------------------------------------
+int HWInit(bd_t * bd)
+{
+	int btemp, goodacc;
+	unsigned long tmp1, mst = 250;
+
+	// Enable MAC interface
+	CLKPWR->clkpwr_macclk_ctrl = (CLKPWR_MACCTRL_HRCCLK_EN |
+		CLKPWR_MACCTRL_MMIOCLK_EN | CLKPWR_MACCTRL_DMACLK_EN |
+#ifdef USE_PHY_RMII
+		CLKPWR_MACCTRL_USE_RMII_PINS);
+#else
+		CLKPWR_MACCTRL_USE_MII_PINS);
+#endif
+
+	// Set RMII management clock rate. This clock should be slower
+	// than 12.5MHz (for NXP PHYs only). For a divider of 28, the
+	// clock rate when HCLK is 150MHz will be 5.4MHz
+	ENETMAC->mcfg = MCFG_CLOCK_SELECT(MCFG_CLOCK_HOST_DIV_28);
+
+	// Reset all MAC logic
+	ENETMAC->mac1 = (MAC1_SOFT_RESET | MAC1_SIMULATION_RESET |
+		MAC1_RESET_MCS_TX | MAC1_RESET_TX | MAC1_RESET_MCS_RX |
+		MAC1_RESET_RX);
+	ENETMAC->command = (COMMAND_REG_RESET | COMMAND_TXRESET |
+		COMMAND_RXRESET);
+	msDelay(10);
+
+	// Initial MAC initialization
+	ENETMAC->mac1 = MAC1_PASS_ALL_RX_FRAMES;
+	ENETMAC->mac2 = (MAC2_PAD_CRC_ENABLE | MAC2_CRC_ENABLE);
+	ENETMAC->maxf = ENET_MAXF_SIZE;
+
+	// Maximum number of retries, 0x37 collision window, gap */
+	ENETMAC->clrt = (CLRT_LOAD_RETRY_MAX(0xF) |
+		CLRT_LOAD_COLLISION_WINDOW(0x37));
+	ENETMAC->ipgr = IPGR_LOAD_PART2(0x12);
+
+#ifdef USE_PHY_RMII
+	// RMII setup
+	ENETMAC->command = (COMMAND_RMII | COMMAND_PASSRUNTFRAME);
+	ENETMAC->supp = SUPP_RESET_RMII;
+	msDelay(10);
+#else
+	// MII setup
+	ENETMAC->command = COMMAND_PASSRUNTFRAME;
+#endif
+
+	// Reset PHY
+	goodacc = HYPHYReset();
+	if (goodacc == 0)
+	{
+		printf("ENET:Reset of PHY timed out\n");
+		return 0;
+	}
+
+	// Enable rate auto-negotiation for the link
+	if (RMII_Write(PHY_REG_BMCR,
+		(PHY_BMCR_SPEED_BIT | PHY_BMCR_AUTON_BIT)) == 0)
+	{
+		return 0;
+	}
+
+	// Wait up to 5 seconds for auto-negotiation to finish
+	mst = 5000;
+	goodacc = 1;
+	btemp = 0;
+	while (mst > 0)
+	{
+		goodacc &= RMII_Read(PHY_REG_BMSR, &tmp1);
+		if ((tmp1 & PHY_BMSR_AUTON_COMPLETE) != 0)
+		{
+			mst = 0;
+			btemp = 1;
+			printf("ENET:auto-negotiation complete\n");
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+	if ((goodacc == 0) || (btemp == 0))
+	{
+		printf("ENET:auto-negotiation failed\n");
+		return 0;
+	}
+
+	// Check link status
+	mst = 1000;
+	goodacc = 1;
+	btemp = 0;
+	while (mst > 0)
+	{
+		goodacc &= RMII_Read(PHY_REG_BMSR, &tmp1);
+		if ((tmp1 & PHY_BMSR_LINKUP_STATUS) != 0)
+		{
+			mst = 0;
+			btemp = 1;
+			printf("ENET:Link status up\n");
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+	if ((goodacc == 0) || (btemp == 0))
+	{
+		printf("ENET:Link status failure\n");
+		return 0;
+	}
+
+	// Try 100MBase/full duplex
+	goodacc = btemp = 0;
+	if ((tmp1 & PHY_BMSR_TX_FULL) != 0)
+	{
+		// Setup for full duplex and 100MBase
+		goodacc = btemp = 1;
+	}
+	else if ((tmp1 & PHY_BMSR_TX_HALF) != 0)
+	{
+		// Setup for half duplex and 100MBase
+		goodacc = 1;
+	}
+	else if ((tmp1 & PHY_BMSR_TX_HALF) != 0)
+	{
+		// Setup for full duplex and 10MBase
+		btemp = 1;
+	}
+
+	// Configure Full/Half Duplex mode
+	if (btemp == 1)
+	{
+		// 10MBase full duplex is supported
+		ENETMAC->mac2 |= MAC2_FULL_DUPLEX;
+		ENETMAC->command |= COMMAND_FULLDUPLEX;
+		ENETMAC->ipgt = IPGT_LOAD(0x15);
+		printf("ENET:FULL DUPLEX\n");
+	}
+	else
+	{
+		ENETMAC->ipgt = IPGT_LOAD(0x12);
+		printf("ENET:HALF DUPLEX\n");
+	}
+
+	// Configure 100MBit/10MBit mode
+	if (goodacc == 1)
+	{
+		// 100MBase mode
+		ENETMAC->supp = SUPP_SPEED;
+		printf("ENET:100MBase\n");
+	}
+	else
+	{
+		// 10MBase mode
+		ENETMAC->supp = 0;
+		printf("ENET:10Base\n");
+	}
+
+	// Save station address
+	ENETMAC->sa [2] = (unsigned long) (bd->bi_enetaddr[0] | (bd->bi_enetaddr[1] << 8));
+	ENETMAC->sa [1] = (unsigned long) (bd->bi_enetaddr[2] | (bd->bi_enetaddr[3] << 8));
+	ENETMAC->sa [0] = (unsigned long) (bd->bi_enetaddr[4] | (bd->bi_enetaddr[5] << 8));
+
+	// Setup TX and RX descriptors
+	txrx_setup();
+
+	// Enable broadcast and matching address packets
+	ENETMAC->rxfliterctrl = (RXFLTRW_ACCEPTUBROADCAST |
+		RXFLTRW_ACCEPTPERFECT);
+
+	// Clear and enable interrupts
+	ENETMAC->intclear = 0xFFFF;
+	ENETMAC->intenable = 0;
+
+	// Enable receive and transmit mode of MAC ethernet core
+	ENETMAC->command |= (COMMAND_RXENABLE | COMMAND_TXENABLE);
+	ENETMAC->mac1 |= MAC1_RECV_ENABLE;
+
+	// Perform a 'dummy' send of the first ethernet frame with a size of 0
+	// to 'prime' the MAC. The first packet after a reset seems to wait
+	// until at least 2 packets are ready to go.
+	goodacc = 0;
+	eth_send(&goodacc, 4);
+
+	return 1;
+}
+
+//------------------------------------------------------------------------------
+int HWDeInit(void)
+{
+	// Reset PHY
+	(void) HYPHYReset();
+
+	// Reset all MAC logic
+	ENETMAC->mac1 = (MAC1_SOFT_RESET | MAC1_SIMULATION_RESET |
+		MAC1_RESET_MCS_TX | MAC1_RESET_TX | MAC1_RESET_MCS_RX |
+		MAC1_RESET_RX);
+	ENETMAC->command = (COMMAND_REG_RESET | COMMAND_TXRESET |
+		COMMAND_RXRESET);
+	msDelay(2);
+
+	// Disable MAC clocks, but keep MAC interface active
+#ifdef USE_PHY_RMII
+	CLKPWR->clkpwr_macclk_ctrl = CLKPWR_MACCTRL_USE_RMII_PINS;
+#else
+	CLKPWR->clkpwr_macclk_ctrl = CLKPWR_MACCTRL_USE_MII_PINS;
+#endif
+
+	return 1;
+}
+
+void eth_halt (void)
+{
+	HWDeInit();
+}
+
+int eth_init (bd_t * bd)
+{
+	int rc;
+
+	char *s, *e;
+	int i;
+
+	s = getenv ("ethaddr");
+	for (i = 0; i < 6; ++i) {
+		bd->bi_enetaddr[i] = s ? simple_strtoul (s, &e, 16) : 0;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+
+	printf ("\tHW MAC address:  "
+		"%02X:%02X:%02X:%02X:%02X:%02X\n",
+		bd->bi_enetaddr[0], bd->bi_enetaddr[1],
+		bd->bi_enetaddr[2], bd->bi_enetaddr[3],
+		bd->bi_enetaddr[4], bd->bi_enetaddr[5] );
+
+	rc = HWInit(bd);
+
+	// De-init if an error occurred
+	if (rc == 0)
+	{
+		printf ("ENET init failure\n");
+		HWDeInit();
+	}
+
+	return 0;
+}
+
+/* Get a data block via Ethernet */
+int eth_rx (void)
+{
+	unsigned long idx, length;
+
+	// Determine if a frame has been received
+	length = 0;
+	idx = ENETMAC->rxconsumeindex;
+	if (ENETMAC->rxproduceindex != idx)
+	{
+		// Clear interrupt
+		ENETMAC->intclear = MACINT_RXDONEINTEN;
+
+		// Frame received, get size of RX packet
+		length = (pRXStatus[idx].statusinfo & 0x7FF);
+
+		/* Pass the packet up to the protocol layer */
+		if (length > 0)
+		{
+		        memcpy((void *) NetRxPackets[0], (void *) pRXVBuffs [idx], length);
+			NetReceive (NetRxPackets[0], (unsigned short) length);
+		}
+
+		// Return DMA buffer
+		idx++;
+		if (idx >= ENET_MAX_TX_PACKETS)
+		{
+			idx = 0;
+		}
+		ENETMAC->rxconsumeindex = (unsigned long) idx;
+	}
+
+	return (int) length;
+}
+
+/* Send a data block via Ethernet. */
+int eth_send (volatile void *packet, int length)
+{
+	unsigned long idx, cidx, fb;
+
+	// Determine number of free buffers and wait for a buffer if needed
+	fb = 0;
+	while (fb == 0)
+	{
+		idx = ENETMAC->txproduceindex;
+		cidx = ENETMAC->txconsumeindex;
+
+		if (idx == cidx)
+		{
+			// Producer and consumer are the same, all buffers are free
+			fb = ENET_MAX_TX_PACKETS;
+		}
+		else if (cidx > idx)
+		{
+			fb = (ENET_MAX_TX_PACKETS - 1) -
+				((idx + ENET_MAX_TX_PACKETS) - cidx);
+		}
+		else
+		{
+			fb = (ENET_MAX_TX_PACKETS - 1) - (cidx - idx);
+		}
+	}
+
+	// Update descriptor with new frame size
+	pTXDesc[idx].control = (length | 0x40000000);
+
+	// Move data to buffer
+	memcpy((void *) pTXVBuffs [idx], (void *)packet, length);
+
+	// Get next index for transmit data DMA buffer and descriptor
+	idx++;
+	if (idx >= ENET_MAX_TX_PACKETS)
+	{
+		idx = 0;
+	}
+	ENETMAC->txproduceindex = idx;
+
+	return 0;
+}
+
diff --git a/board/ea3250/u-boot.lds b/board/ea3250/u-boot.lds
new file mode 100644
index 0000000..66c3945
--- /dev/null
+++ b/board/ea3250/u-boot.lds
@@ -0,0 +1,56 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x83FA0000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) }
+	_end = .;
+}
diff --git a/include/configs/ea3250.h b/include/configs/ea3250.h
new file mode 100644
index 0000000..93dcbb4
--- /dev/null
+++ b/include/configs/ea3250.h
@@ -0,0 +1,322 @@
+/*
+ * Copyright (C) 2009 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * @Author: Kevin Wells
+ * @Descr: Phytec 3250 board configuration file
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Embedded Artists  LPC3250 OEM Board configuation data
+ */
+
+#ifndef __EA3250_H__
+#define __EA3250_H__
+
+/*
+ *
+ * Chip speific options
+ *
+ */
+
+/*
+ * Ethernet buffer support in uncached IRAM and buffer size
+ */
+#define USE_IRAM_FOR_ETH_BUFFERS
+#define IRAM_ETH_BUFF_BASE 0x08010000 /* Uncached IRAM */
+#define IRAM_ETH_BUFF_SIZE 0x00010000
+
+/*
+ * There are 2 boot options for u-boot on the LPC3250 board. Option 1
+ * or option 2. In either cases, u-boot does not need to be relocated.
+ *
+ * Option 1 - define CFG_BOOT_USES1L
+ * With this option, the S1L loader present in the board initializes the
+ * system (including SDRAM, MMUs, some MUX states, etc.). U-boot is loaded
+ * into an already initialized system in SDRAM at address 0x83FC0000 (the
+ * end of SDRAM in a 64M system). Because most of the system is already
+ * initialized, system init is not performed again.
+ *
+ * Option 2 - undefine CFG_BOOT_USES1L [NOT SUPPORTED]
+ * With this option, u-boot is the primary boot loader that is loaded and
+ * started from the kickstart loader (see documentation with the
+ * LPC3250 board for the kickstart loader). In this configuration, u-boot
+ * loads and runs from RAM at address 0x00000000 and requires complete
+ * system initialization. The kickstart loader will copy the u-boot image
+ * from FLASH starting at block 1 into IRAM and start it at address 0x0.
+ */
+#define CFG_BOOT_USES1L
+
+#ifdef CFG_BOOT_USES1L
+/*
+ * Skip low level init of MMU, SDRAM, muxing, etc. if u-boot is loaded
+ * and executed from S1L
+ */
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+/*
+ * Linux machine type
+ */
+#define MACH_TYPE_UBOOTSYS MACH_TYPE_LPC3XXX
+
+/*
+ * System UART selection, valid selections include UART3, UART4,
+ * UART5, and UART6
+ */
+#define CFG_UART_SEL UART5
+
+/*
+ * SDRAM physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS    1
+#define PHYS_SDRAM_1		0x80000000 /* SDRAM Bank #1 */
+
+/*
+ * NOR FLASH not supported
+ */
+#define CONFIG_SYS_NO_FLASH
+#undef CONFIG_ENV_IS_IN_FLASH
+
+/*
+ * 1KHz clock tick
+ */
+#define CONFIG_SYS_HZ		1000
+
+/*
+ * ARM926ejs options
+ */
+#define CONFIG_ARM926EJS	   1 /* This is an arm926ejs CPU core  */
+
+/*
+ *
+ * u-boot specific options
+ *
+ */
+
+/*
+ * Address and size of Environment Data
+ */
+#define CONFIG_ENV_IS_IN_NAND	1
+#define CONFIG_ENV_SIZE		0x20000    /* 1 block */
+#define CONFIG_ENV_OFFSET	0xE0000    /* Block 7 */
+#define CONFIG_ENV_ADDR		0x80000100 /* Passed to kernel here */
+
+/*
+ * Area and size for malloc
+ */
+#define CONFIG_SYS_MALLOC_LEN (CONFIG_ENV_SIZE + 128 * 1024)
+#define CONFIG_SYS_GBL_DATA_SIZE 128
+
+/*
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE (32*1024) /* 32K stack */
+
+/*
+ * ATAG support
+ */
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+/*
+ * Default baud rate and baud rate table, console config
+ */
+#define CONFIG_CONS_INDEX	   1
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * Default load address for programs
+ */
+#define CONFIG_SYS_LOAD_ADDR	0x80100000 /* default load address */
+
+/*
+ * Default boot delay is 3 seconds
+ */
+#define CONFIG_BOOTDELAY 3
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+/*
+ * Interrupts are not supported in this boot loader
+ */
+#undef CONFIG_USE_IRQ
+
+/*
+ * Use verbose help
+ */
+#define CONFIG_SYS_LONGHELP
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_ECHO /* ECHO command */
+#define CONFIG_CMD_CACHE /* Cache support */
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_LOADB
+#define CONFIG_CMD_LOADS
+#define CONFIG_CMD_SAVES
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_FAT
+#undef CONFIG_CMD_MISC
+
+/*
+ * USB Host (OHCI) Support
+ */
+#define CONFIG_CMD_USB
+#define CONFIG_USB_OHCI_NEW 1
+#define LITTLEENDIAN
+#define CONFIG_SYS_USB_OHCI_REGS_BASE 0x31020000
+#define CONFIG_SYS_USB_OHCI_SLOT_NAME "lpc3250"
+#define CONFIG_SYS_USB_OHCI_MAX_ROOT_PORTS 15
+#define CONFIG_USB_STORAGE 1
+#define CONFIG_SYS_USB_OHCI_BOARD_INIT
+
+#define CONFIG_DOS_PARTITION 1
+#define CONFIG_MAC_PARTITION 1
+
+
+/*
+ * Prompt, command buffer
+ */
+#define	CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CONFIG_SYS_PROMPT	"uboot> "	/* Monitor Command Prompt	*/
+#define	CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+/*
+ * Default range for the memory tests
+ */
+#define CONFIG_SYS_MEMTEST_START 0x80010000
+#define CONFIG_SYS_MEMTEST_END 0x81000000
+
+/*
+ * Support for NAND FLASH, environment store in NAND at block 100
+ */
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_MAX_NAND_DEVICE 1
+#define CONFIG_SYS_NAND_BASE 0x20020000 /* SLC NAND controller */
+#define CFG_ENV_IS_IN_NAND
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Support for various capabilities
+ */
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_LOADS_BAUD_CHANGE
+
+/*
+ * Network setup
+ */
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_IPADDR		192.168.5.234
+#define CONFIG_SERVERIP		192.168.5.88
+#define CONFIG_ETHADDR		00:1a:f1:00:00:00
+
+#define CONFIG_BOOTFILE		"uImage"  /* File to load */
+#define CONFIG_LOADADDR		0x80100000	   
+#define CONFIG_ROOTPATH		/home/user/ltib/rootfs
+#define CONFIG_BOOTARGS		
+
+#define CONFIG_BOOTCOMMAND	"run mtdboot"
+
+#define CONFIG_NFSBOOTCOMMAND					\
+ "setenv bootargs root=/dev/nfs rw "				\
+	"nfsroot=$(serverip):$(rootpath) "			\
+	"ip=$(ipaddr) ea_ethaddr=$(ethaddr) "			\
+	"console=ttyS0,115200n8;"				\
+	"run loadkernel;"					\
+	"bootm $(loadaddr)"
+
+#define MTDBOOTCOMMAND "mtdboot="				\
+ "setenv bootargs root=/dev/mtdblock3 rw rootfstype=jffs2 "	\
+	"ip=$(ipaddr) ea_ethaddr=$(ethaddr) "			\
+	"console=ttyS0,115200n8; "				\
+	"run loadkernel;"					\
+	"bootm $(loadaddr)\0"
+
+#define UPDATEKERNEL "update_kernel="				\
+	"run loadkernel; "					\
+	"nand erase $(nand_kernel_off) $(nand_kernel_sz); "	\
+	"nand write.jffs2 $(loadaddr) $(nand_kernel_off) $(nand_kernel_sz)\0"
+
+#define UPDATEROOTFS "update_fs="				\
+	"run loadrootfs; "					\
+	"nand erase $(nand_rootfs_off) $(nand_rootfs_sz); "	\
+	"nand write.jffs2 $(loadaddr) $(nand_rootfs_off) $(nand_rootfs_sz)\0"
+
+#define UPDATEUBOOT_TFTP "update_uboot_tftp="		\
+	"tftpboot $(loadaddr) u-boot.bin; "		\
+	"nand erase 0x60000 0x40000; "			\
+	"nand write $(loadaddr) 0x60000 0x40000\0"
+
+/*
+ * Other preset environment variables and example bootargs string
+ */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"nand_kernel_off=0x100000\0" \
+	"nand_kernel_sz=0x1a0000\0" \
+	"nand_rootfs_off=0x500000\0" \
+	"nand_rootfs_sz=0x500000\0" \
+	"loadkernel=usb start;fatload usb 0 $(loadaddr) uImage;usb stop\0" \
+	"loadkernel_nand=nboot.jffs2 $(loadaddr) 0x0 $(nand_kernel_off)\0" \
+	"loadkernel_tftp=tftpboot $(loadaddr) uImage\0" \
+	"loadkernel_usb=usb start;fatload usb 0 $(loadaddr) uImage;usb stop\0" \
+	"loadrootfs=usb start;fatload usb 0 $(loadaddr) rootfs.jffs2;usb stop\0" \
+	"loadrootfs_tftp=tftpboot $(loadaddr) rootfs.jffs2\0" \
+	"loadrootfs_usb=usb start;fatload usb 0 $(loadaddr) rootfs.jffs2;usb stop\0" \
+	"erase_env=nand erase 0xe0000 0x20000\0" \
+	MTDBOOTCOMMAND \
+	UPDATEKERNEL \
+	UPDATEROOTFS \
+	UPDATEUBOOT_TFTP
+
+
+ 
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+
+#endif  /* __EA3250_H__*/
+
diff --git a/include/lpc3250.h b/include/lpc3250.h
index 785b1be..cf7dcde 100644
--- a/include/lpc3250.h
+++ b/include/lpc3250.h
@@ -36,7 +36,9 @@
 #define EMC_BASE        0x31080000 	/* EMC registers base*/
 #define SLC_BASE	0x20020000	/* SLC NAND Flash registers base*/
 #define SD_BASE		0x20098000	/* SD card interface registers base*/
-#define DMA_BASE	0x31000000	/* DMA controller registers base*/
+#define DMA_BASE	0x31000000	/* DMA controller registers base*/
+#define USB_OTG_BASE	0x31020000	/*USB OTG registers base*/
+#define OTG_I2C_BASE	0x31020300	/*USB I2C registers base*/
 
 /*
  * FAB physical address bases used in u-boot
@@ -453,6 +455,56 @@ typedef struct
    locked, (1) = PLL is locked */
 #define CLKPWR_HCLKPLL_PLL_STS     _BIT(0)
 
+
+/**********************************************************************
+* clkpwr_usb_ctrl register definitions
+**********************************************************************/
+/* USB slave HCLK clock disable (0) / enable (1) bit */
+#define CLKPWR_USBCTRL_HCLK_EN     _BIT(24)
+/* USB I2C enable, (0) = automatic USB I2C enable, (1) = disable (by
+   driving '0' to the OE_TP_N pad */
+#define CLKPWR_USBCTRL_USBI2C_EN   _BIT(23)
+/* USB_DEV_NEED_CLK enable, (0) = USB_DEV_NEED_CLK not let into clock
+   switch, (1) = USB_DEV_NEED_CLK let into clock switch */
+#define CLKPWR_USBCTRL_USBDVND_EN  _BIT(22)
+/* USB_HOST_NEED_CLK enable, (0) = USB_HOST_NEED_CLK not let into clock
+   switch, (1) = USB_HOST_NEED_CLK let into clock switch */
+#define CLKPWR_USBCTRL_USBHSTND_EN _BIT(21)
+/* USB_DAT_VP and USB_SE0_VM pull-up added to pad */
+#define CLKPWR_USBCTRL_PU_ADD      (0x0 << 19)
+/* USB_DAT_VP and USB_SE0_VM bus keeper mode */
+#define CLKPWR_USBCTRL_BUS_KEEPER  (0x1 << 19)
+/* USB_DAT_VP and USB_SE0_VM pull-down added to pad */
+#define CLKPWR_USBCTRL_PD_ADD      (0x3 << 19)
+/* USB (CLKEN2) clock disable (0) / enable (1) bit */
+#define CLKPWR_USBCTRL_CLK_EN2     _BIT(18)
+/* USB (CLKEN1) clock disable (0) / enable (1) bit */
+#define CLKPWR_USBCTRL_CLK_EN1     _BIT(17)
+/* USB PLL Power up (1) / power down (0) bit */
+#define CLKPWR_USBCTRL_PLL_PWRUP   _BIT(16)
+/* USB PLL CCO bypass bit, (0) = use post divider, (1) = bypass */
+#define CLKPWR_USBCTRL_CCO_BYPASS  _BIT(15)
+/* USB PLL direct output bit, (0) = use post divider as PLL output,
+   (1) = bypass post divider */
+#define CLKPWR_USBCTRL_POSTDIV_BYPASS _BIT(14)
+/* USB PLL feedback divider path control, (0) = feedback
+   divider clocked by CCO, (1) = feedback divider clocked by FCLKOUT */
+#define CLKPWR_USBCTRL_FDBK_SEL_FCLK _BIT(13)
+/* USB PLL post divider setting, for a value of n, the divider is 2^n,
+   maximum value of n is 3 */
+#define CLKPWR_USBCTRL_POSTDIV_2POW(n) (((n) & 0x3) << 11)
+/* USB PLL pre divider setting, for a value of n, the divider
+   is (1+n), maximum value of n is 3 */
+#define CLKPWR_USBCTRL_PREDIV_PLUS1(n) (((n) & 0x3) << 9)
+/* USB PLL feedback setting, for a value of n, the feedback
+   is (1+n), maximum value of n is 255 */
+#define CLKPWR_USBCTRL_FDBK_PLUS1(n) (((n) & 0xFF) << 1)
+/* Read only status mask bit of the USB PLL lock state, (0) = PLL is
+   not locked, (1) = PLL is locked */
+#define CLKPWR_USBCTRL_PLL_STS     _BIT(0)
+
+
+
 /*
  * clkpwr_sdramclk_ctrl register definitions
  */
@@ -1812,6 +1864,164 @@ typedef struct
 #define P3_GPO16_PWM32         _BIT(16)
 #define P3_GPO18_PWM31         _BIT(18)
 
+typedef struct
+{
+  volatile unsigned int baud_rate;
+  volatile unsigned int cts_en;
+  volatile unsigned int cts_inv;
+  volatile unsigned int rts_en;
+  volatile unsigned int rts_inv;
+} HSUART_CONTROL_T;
+
+typedef struct
+{
+  volatile unsigned int txrx_fifo;
+  volatile unsigned int level;
+  volatile unsigned int iir;
+  volatile unsigned int ctrl;
+  volatile unsigned int rate;
+} HSUART_REGS_T;
+
+typedef struct
+{
+  volatile unsigned int ctrl;
+  volatile unsigned int clkmode;
+  volatile unsigned int loop;
+} HSUART_CNTL_REGS_T;
+
+#define UART1 ((HSUART_REGS_T *)(HS_UART1_BASE))
+#define UART2 ((HSUART_REGS_T *)(HS_UART2_BASE))
+#define UART7 ((HSUART_REGS_T *)(HS_UART7_BASE))
+
+#define HS_UART1_BASE 0x40014000
+#define HS_UART2_BASE 0x40018000
+#define HS_UART7_BASE 0x4001C000
+
+/**********************************************************************
+* OTG I2C controller register structures
+**********************************************************************/
+
+/* OTG I2C controller module register structures */
+typedef struct
+{
+  volatile unsigned long otg_i2c_txrx;      /* OTG I2C Tx/Rx Data FIFO */
+  volatile unsigned long otg_i2c_stat;      /* OTG I2C Status Register */
+  volatile unsigned long otg_i2c_ctrl;      /* OTG I2C Control Register */
+  volatile unsigned long otg_i2c_clk_hi;    /* OTG I2C Clock Divider high */
+  volatile unsigned long otg_i2c_clk_lo;    /* OTG I2C Clock Divider low */
+} OTGI2C_REGS_T;
+
+/**********************************************************************
+* OTG controller register structures
+**********************************************************************/
+
+/* OTG controller module register structures */
+typedef struct
+{
+  volatile unsigned long reserved1[64];
+  volatile unsigned long otg_int_sts;      /* OTG int status register */
+  volatile unsigned long otg_int_enab;     /* OTG int enable register */
+  volatile unsigned long otg_int_set;      /* OTG int set register */
+  volatile unsigned long otg_int_clr;      /* OTG int clear register */
+  volatile unsigned long otg_sts_ctrl;     /* OTG status/control register */
+  volatile unsigned long otg_timer;        /* OTG timer register */
+  volatile unsigned long reserved2[122];
+  OTGI2C_REGS_T otg_i2c;
+  volatile unsigned long reserved3[824];
+  volatile unsigned long otg_clk_ctrl;      /* OTG clock control reg */
+  volatile unsigned long otg_clk_sts;       /* OTG clock status reg */
+} OTG_REGS_T;
+
+/**********************************************************************
+* otg_int_sts, otg_int_enab, otg_int_set, and otg_int_clr register
+* definitions
+**********************************************************************/
+#define OTG_INT_HNP_SUCC _BIT(3)       /* HNP success */
+#define OTG_INT_HNP_FAIL _BIT(2)       /* HNP failure */
+#define OTG_INT_REM_PLLUP _BIT(1)      /* Remove pullup interrupt */
+#define OTG_INT_TIMER _BIT(0)          /* Timer interrupt */
+
+/**********************************************************************
+* otg_sts_ctrl register definitions
+**********************************************************************/
+#define OTG_PLLUP_REMD _BIT(10)        /* Pullup removed */
+#define OTG_AB_HNP_TRK _BIT(9)         /* A to B HNP track */
+#define OTG_BA_HNP_TRK _BIT(8)         /* B to A HNP track */
+#define OTGTRAN_I2C_EN _BIT(7)         /* Enable transparent I2C */
+#define OTG_TIMER_RST _BIT(6)          /* Reset the timer */
+#define OTG_TIMER_EN _BIT(5)           /* Enable the timer */
+#define OTG_TIMER_MODE_FREE _BIT(4)    /* Enable freerun timer mode */
+#define OTG_TIMER_GRAN_10US 0x0        /* 10uS timer granularity */
+#define OTG_TIMER_GRAN_100US 0x4       /* 100uS timer granularity */
+#define OTG_TIMER_GRAN_1000US 0x8      /* 1000uS timer granularity */
+#define OTG_HOST_EN _BIT(0)            /* Enable host mode */
+
+/**********************************************************************
+* OTG I2C register definitions
+* The register definitions are exactly the same as "master only" base
+* I2C register settings. See the I2C header file for the register
+* bit descriptions for this peripheral.
+**********************************************************************/
+
+/**********************************************************************
+* otg_clk_ctrl and otg_clk_sts register definitions
+**********************************************************************/
+#define OTG_CLK_AHB_EN _BIT(4)         /* Enable AHB clock */
+#define OTG_CLK_OTG_EN _BIT(3)         /* Enable OTG clock */
+#define OTG_CLK_I2C_EN _BIT(2)         /* Enable I2C clock */
+#define OTG_CLK_DEV_EN _BIT(1)         /* Enable device clock */
+#define OTG_CLK_HOST_EN _BIT(0)        /* Enable host clock */
+
+/* Macro pointing to I2C controller registers */
+#define OTG     ((OTG_REGS_T  *)(USB_OTG_BASE))
+/* Macro pointing to I2C controller registers */
+#define OTGI2C  ((OTGI2C_REGS_T  *)(OTG_I2C_BASE))
+
+
+/**********************************************************************
+* I2C controller register structures
+**********************************************************************/
+
+
+/**********************************************************************
+* i2c_txrx register definitions
+**********************************************************************/
+#define I2C_START    _BIT(8)		/* generate a START before this B*/
+#define I2C_STOP     _BIT(9)		/* generate a STOP after this B */
+
+/**********************************************************************
+* i2c_stat register definitions
+**********************************************************************/
+#define I2C_TDI     _BIT(0)         /* Transaction Done Interrupt */
+#define I2C_AFI     _BIT(1)         /* Arbitration Failure Interrupt */
+#define I2C_NAI     _BIT(2)         /* No Acknowledge Interrupt */
+#define I2C_DRMI    _BIT(3)         /* Master Data Request Interrupt */
+#define I2C_DRSI    _BIT(4)         /* Slave Data Request Interrupt */
+#define I2C_ACTIVE  _BIT(5)         /* Busy bus indicator */
+#define I2C_SCL     _BIT(6)         /* The current SCL signal value */
+#define I2C_SDA     _BIT(7)         /* The current SDA signal value */
+#define I2C_RFF     _BIT(8)         /* Receive FIFO Full */
+#define I2C_RFE     _BIT(9)         /* Receive FIFO Empty */
+#define I2C_TFF     _BIT(10)        /* Transmit FIFO Full */
+#define I2C_TFE     _BIT(11)        /* Transmit FIFO Empty */
+#define I2C_TFFS    _BIT(12)        /* Slave Transmit FIFO Full */
+#define I2C_TFES    _BIT(13)        /* Slave Transmit FIFO Empty */
+
+/**********************************************************************
+* i2c_ctrl register definitions
+**********************************************************************/
+#define I2C_TDIE    _BIT(0)         /* Transaction Done Int Enable */
+#define I2C_AFIE    _BIT(1)         /* Arbitration Failure Int Ena */
+#define I2C_NAIE    _BIT(2)         /* No Acknowledge Int Enable */
+#define I2C_DRMIE   _BIT(3)         /* Master Data Request Int Ena */
+#define I2C_DRSIE   _BIT(4)         /* Slave Data Request Int Ena */
+#define I2C_RFFIE   _BIT(5)         /* Receive FIFO Full Int Ena */
+#define I2C_RFDAIE  _BIT(6)         /* Rcv Data Available Int Ena */
+#define I2C_TFFIE   _BIT(7)         /* Trnsmt FIFO Not Full Int Ena */
+#define I2C_RESET   _BIT(8)         /* Soft Reset */
+#define I2C_SEVEN   _BIT(9)         /* Seven-bit slave address */
+#define I2C_TFFSIE  _BIT(10)        /* Slave Trnsmt FIFO Not Full IE */
+
 
 #endif /* __LPC3250_H */
 
-- 
1.7.0.4


From f31d5e8022fa11c34760dab18929c55760961678 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:48:26 -0700
Subject: [PATCH 03/28] Updated 1 for the LPC3250 version of u-boot

---
 cpu/arm926ejs/lpc3250/serial.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/cpu/arm926ejs/lpc3250/serial.c b/cpu/arm926ejs/lpc3250/serial.c
index 7739d8e..5183c02 100644
--- a/cpu/arm926ejs/lpc3250/serial.c
+++ b/cpu/arm926ejs/lpc3250/serial.c
@@ -138,7 +138,7 @@ int serial_init (void)
 	}
 
 	/* Place UART in autoclock mode */
-	tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum);
+	tmp32 = UARTCNTL->clkmode & ~UART_CLKMODE_MASK(unum);
 	UARTCNTL->clkmode = (tmp32 |
 		UART_CLKMODE_LOAD(UART_CLKMODE_AUTO, (unum)));
 
-- 
1.7.0.4


From ebc191b00ed53f19cfc4946c54ba4813e3a41849 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:49:11 -0700
Subject: [PATCH 04/28] Fixed issues with GCC when using EABI support

---
 Makefile                        |    2 +-
 board/ea3250/ea3250.c           |   14 ++++++++++++++
 board/ea3250/u-boot.lds         |    5 +++++
 board/phy3250/phy3250.c         |   15 +++++++++++++++
 board/phy3250/u-boot.lds        |    5 +++++
 cpu/arm926ejs/config.mk         |    2 +-
 cpu/arm926ejs/lpc3250/config.mk |    2 ++
 7 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/Makefile b/Makefile
index a79ef66..cdc2b66 100644
--- a/Makefile
+++ b/Makefile
@@ -274,7 +274,7 @@ LIBBOARD = board/$(BOARDDIR)/lib$(BOARD).a
 LIBBOARD := $(addprefix $(obj),$(LIBBOARD))
 
 # Add GCC lib
-PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc
+PLATFORM_LIBS += -L $(shell dirname `$(CC) $(CFLAGS) -print-libgcc-file-name`) -lgcc -lgcov -lgcc_eh
 
 # The "tools" are needed early, so put this first
 # Don't include stuff already done in $(LIBS)
diff --git a/board/ea3250/ea3250.c b/board/ea3250/ea3250.c
index f27c229..56e31c8 100644
--- a/board/ea3250/ea3250.c
+++ b/board/ea3250/ea3250.c
@@ -90,6 +90,20 @@ extern int dcache_kill(void);
 #define I2C_WRITE     0x00
 #define DUMMY_BYTE    0x55
 
+/*
+ * Dummy function to handle errors for EABI incompatibility
+ */
+void raise(void)
+{
+}
+
+/*
+ * Dummy function to handle errors for EABI incompatibility
+ */
+void abort(void)
+{
+}
+
 void reset_timer (void)
 {
 	unsigned int clkdlycnt, tbaseclk;
diff --git a/board/ea3250/u-boot.lds b/board/ea3250/u-boot.lds
index 66c3945..35df6f7 100644
--- a/board/ea3250/u-boot.lds
+++ b/board/ea3250/u-boot.lds
@@ -37,6 +37,11 @@ SECTIONS
 
 	. = ALIGN(4);
 	.rodata : { *(.rodata) }
+ 
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
 
 	. = ALIGN(4);
 	.data : { *(.data) }
diff --git a/board/phy3250/phy3250.c b/board/phy3250/phy3250.c
index b1a7143..1869934 100644
--- a/board/phy3250/phy3250.c
+++ b/board/phy3250/phy3250.c
@@ -36,6 +36,20 @@ extern PHY_HW_T phyhwdesc;
 extern void phy3250_get_board_info(void);
 extern int dcache_kill(void);
 
+/*
+ * Dummy function to handle errors for EABI incompatibility
+ */
+void raise(void)
+{
+}
+
+/*
+ * Dummy function to handle errors for EABI incompatibility
+ */
+void abort(void)
+{
+}
+
 void reset_timer (void)
 {
 	unsigned int clkdlycnt, tbaseclk;
@@ -218,3 +232,4 @@ int dram_init (void)
 	return 0;
 }
 
+
diff --git a/board/phy3250/u-boot.lds b/board/phy3250/u-boot.lds
index 6d768b3..497036d 100644
--- a/board/phy3250/u-boot.lds
+++ b/board/phy3250/u-boot.lds
@@ -38,6 +38,11 @@ SECTIONS
 	. = ALIGN(4);
 	.rodata : { *(.rodata) }
 
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
 	. = ALIGN(4);
 	.data : { *(.data) }
 
diff --git a/cpu/arm926ejs/config.mk b/cpu/arm926ejs/config.mk
index a57d03a..3882d89 100644
--- a/cpu/arm926ejs/config.mk
+++ b/cpu/arm926ejs/config.mk
@@ -30,6 +30,6 @@ PLATFORM_CPPFLAGS += -march=armv5te
 # Supply options according to compiler version
 #
 # =========================================================================
-PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=apcs-gnu)
+PLATFORM_CPPFLAGS +=$(call cc-option,-mapcs-32,-mabi=aapcs-linux)
 PLATFORM_CPPFLAGS +=$(call cc-option,-mno-thumb-interwork,)
 PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
diff --git a/cpu/arm926ejs/lpc3250/config.mk b/cpu/arm926ejs/lpc3250/config.mk
index 56e20a1..da754f4 100644
--- a/cpu/arm926ejs/lpc3250/config.mk
+++ b/cpu/arm926ejs/lpc3250/config.mk
@@ -4,3 +4,5 @@ PLATFORM_CPPFLAGS += $(call cc-option,-mtune=arm926ejs,)
 PLATFORM_RELFLAGS += -fno-strict-aliasing  -fno-common -ffixed-r8
 
 PLATFORM_RELFLAGS +=$(call cc-option,-mshort-load-bytes,$(call cc-option,-malignment-traps,))
+
+
-- 
1.7.0.4


From 1c52547ea2819836276ef804637129d8cfe90dca Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:49:46 -0700
Subject: [PATCH 05/28] Fixed an issue with 64 bit clock division in the 3250 clock driver

---
 cpu/arm926ejs/lpc3250/clkpwr.c |   45 ++++++++++++++++++++++++++++++---------
 1 files changed, 34 insertions(+), 11 deletions(-)

diff --git a/cpu/arm926ejs/lpc3250/clkpwr.c b/cpu/arm926ejs/lpc3250/clkpwr.c
index dcb88f6..cec6a3d 100644
--- a/cpu/arm926ejs/lpc3250/clkpwr.c
+++ b/cpu/arm926ejs/lpc3250/clkpwr.c
@@ -23,6 +23,7 @@
 
 #include <common.h>
 #include <lpc3250.h>
+#include <div64.h>
 
 //DECLARE_GLOBAL_DATA_PTR;
 
@@ -68,7 +69,8 @@ typedef struct
 static unsigned int clkpwr_check_pll_setup(unsigned int ifreq,
 						CLKPWR_HCLK_PLL_SETUP_T *pllsetup)
 {
-  unsigned long long i64freq, p, m, n, fcco, fref, cfreq;
+  unsigned long long i64freq, p, m, n, fcco, fref,
+		cfreq, div_cfreq, div_fcco, div_fref;
   int mode;
 
   /* PLL requirements */
@@ -78,6 +80,7 @@ static unsigned int clkpwr_check_pll_setup(unsigned int ifreq,
   /* Assume the passed input data is not valid */
 
 	fcco = fref = cfreq = 0;
+  	div_cfreq = div_fcco = div_fref = 0;
 
   /* Work with 64-bit values to prevent overflow */
   i64freq = (unsigned long long) ifreq;
@@ -89,30 +92,41 @@ static unsigned int clkpwr_check_pll_setup(unsigned int ifreq,
   mode = (pllsetup->cco_bypass_b15 << 2) |
          (pllsetup->direct_output_b14 << 1) |
          pllsetup->fdbk_div_ctrl_b13;
+
   switch (mode)
   {
     case 0x0: /* Non-integer mode */
-      cfreq = (m * i64freq) / (2 * p * n);
-      fcco = (m * i64freq) / n;
-      fref = i64freq / n;
+      cfreq = m * i64freq;
+      div_cfreq = 2 * p * n;
+      fcco = m * i64freq;
+      div_fcco = n;
+      fref = i64freq;
+      div_fref = n;
       break;
 
     case 0x1: /* integer mode */
-      cfreq = (m * i64freq) / n;
-      fcco = (m * i64freq) / (n * 2 * p);
-      fref = i64freq / n;
+      cfreq = m * i64freq;
+      div_cfreq = n;
+      fcco = m * i64freq;
+      div_fcco = 2 * p * n;
+      fref = i64freq;
+      div_fref = n;
       break;
 
     case 0x2:
     case 0x3: /* Direct mode */
-      cfreq = (m * i64freq) / n;
-      fcco = cfreq;
-      fref = i64freq / n;
+      cfreq = m * i64freq;
+      div_cfreq = n;
+      fcco = m * i64freq;
+      div_fcco = n;
+      fref = i64freq;
+      div_fref = n;
       break;
 
     case 0x4:
     case 0x5: /* Bypass mode */
-      cfreq = i64freq / (2 * p);
+      cfreq = i64freq;
+      div_cfreq = 2 * p;
       fcco = 156000000;
       fref = 1000000;
       break;
@@ -125,6 +139,15 @@ static unsigned int clkpwr_check_pll_setup(unsigned int ifreq,
       break;
   }
 
+  if (div_cfreq != 0)
+	  do_div(cfreq, div_cfreq);
+  
+  if (div_fcco != 0)
+	  do_div(fcco, div_fcco);
+
+  if (div_fref != 0)
+	  do_div(fref, div_fref);
+
   if ((fcco < 156000000) || (fcco > 320000000))
   {
     /* not a valid range */
-- 
1.7.0.4


From 2c1a7177be58ae5ff7b0e5ee0c9720a9c4994516 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:50:29 -0700
Subject: [PATCH 06/28] Added support for the ethaddr kernel command line parameter

---
 board/phy3250/phy3250.c   |   19 ++++++++++++++++++-
 include/configs/ea3250.h  |    7 ++++---
 include/configs/phy3250.h |   11 +++++++----
 3 files changed, 29 insertions(+), 8 deletions(-)

diff --git a/board/phy3250/phy3250.c b/board/phy3250/phy3250.c
index 1869934..2c48408 100644
--- a/board/phy3250/phy3250.c
+++ b/board/phy3250/phy3250.c
@@ -153,9 +153,26 @@ void udelay(unsigned long usec)
 /*
  * Miscellaneous platform dependent initialisations
  */
+int misc_init_r(void)
+{
+	char enetaddr[18];
+	char *addr;
+	int i = 0;
+
+	sprintf(enetaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
+			phyhwdesc.mac[0],
+			phyhwdesc.mac[1],
+			phyhwdesc.mac[2],
+			phyhwdesc.mac[3],
+			phyhwdesc.mac[4],
+			phyhwdesc.mac[5]);
+	setenv("ethaddr",enetaddr);
+
+	return 1;
+}
 
 int board_init (void)
-{
+{	
 	/* Kill data cache */
 	dcache_kill();
 
diff --git a/include/configs/ea3250.h b/include/configs/ea3250.h
index 93dcbb4..d617619 100644
--- a/include/configs/ea3250.h
+++ b/include/configs/ea3250.h
@@ -76,7 +76,8 @@
 /*
  * Linux machine type
  */
-#define MACH_TYPE_UBOOTSYS MACH_TYPE_LPC3XXX
+#define MACH_TYPE_EA3250 (2512)
+#define MACH_TYPE_UBOOTSYS MACH_TYPE_EA3250
 
 /*
  * System UART selection, valid selections include UART3, UART4,
@@ -257,14 +258,14 @@
 #define CONFIG_NFSBOOTCOMMAND					\
  "setenv bootargs root=/dev/nfs rw "				\
 	"nfsroot=$(serverip):$(rootpath) "			\
-	"ip=$(ipaddr) ea_ethaddr=$(ethaddr) "			\
+	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
 	"console=ttyS0,115200n8;"				\
 	"run loadkernel;"					\
 	"bootm $(loadaddr)"
 
 #define MTDBOOTCOMMAND "mtdboot="				\
  "setenv bootargs root=/dev/mtdblock3 rw rootfstype=jffs2 "	\
-	"ip=$(ipaddr) ea_ethaddr=$(ethaddr) "			\
+	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
 	"console=ttyS0,115200n8; "				\
 	"run loadkernel;"					\
 	"bootm $(loadaddr)\0"
diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
index 1bef2dc..e474613 100644
--- a/include/configs/phy3250.h
+++ b/include/configs/phy3250.h
@@ -76,7 +76,8 @@
 /*
  * Linux machine type
  */
-#define MACH_TYPE_UBOOTSYS MACH_TYPE_LPC3XXX
+#define MACH_TYPE_PHY3250 (2511)
+#define MACH_TYPE_UBOOTSYS MACH_TYPE_PHY3250
 
 /*
  * System UART selection, valid selections include UART3, UART4,
@@ -187,6 +188,7 @@
 #define CONFIG_CMD_BDI
 #define CONFIG_CMD_SAVEENV
 #define CONFIG_CMD_ELF
+#define CONFIG_MISC_INIT_R
 #undef CONFIG_CMD_MISC
 
 /*
@@ -227,10 +229,11 @@
  */
 #define CONFIG_NETMASK		   255.255.255.0
 #define CONFIG_IPADDR		   192.168.1.193
-#define CONFIG_SERVERIP		   192.168.1.51
+#define CONFIG_SERVERIP		   192.168.1.45
+#define CONFIG_GATEWAYIP	   192.168.1.1
+#define CONFIG_NETMASK		   255.255.255.0
 #define CONFIG_BOOTFILE		   "uImage"  /* File to load */
-#define CONFIG_BOOTARGS		   "console=ttyS0,115200n8 root=/dev/nfs rw nfsroot=192.168.1.51:/home/user/ltib/rootfs ip=192.168.1.193"
-
+#define CONFIG_BOOTARGS		   "console=ttyS0,115200n8 root=/dev/nfs rw nfsroot=192.168.1.51:/home/user/ltib/rootfs ethaddr=${ethaddr} ip=192.168.1.193"
 /*
  * BOOTP options
  */
-- 
1.7.0.4


From bb83996a16e14873f8744c7590a05d4f190ad7fd Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:51:22 -0700
Subject: [PATCH 07/28] Improved Phytec and EA ethernet autonegotiation

---
 board/ea3250/ea3250.c       |    2 +-
 board/ea3250/ea3250_prv.h   |   31 +------
 board/ea3250/net.c          |  165 +++++++++++++++-----------------
 board/phy3250/net.c         |  226 +++++++++++++++++++------------------------
 board/phy3250/phy3250.c     |    2 +-
 board/phy3250/phy3250_prv.h |   33 +------
 6 files changed, 187 insertions(+), 272 deletions(-)

diff --git a/board/ea3250/ea3250.c b/board/ea3250/ea3250.c
index 56e31c8..e2d5069 100644
--- a/board/ea3250/ea3250.c
+++ b/board/ea3250/ea3250.c
@@ -131,7 +131,7 @@ void reset_timer (void)
 ulong get_timer (ulong base)
 {
 	ulong tcr = TIMER_CNTR0->tc;
-	return tcr;
+	return tcr - base;
 }
 
 void timer_init(void)
diff --git a/board/ea3250/ea3250_prv.h b/board/ea3250/ea3250_prv.h
index 2cae978..5370a37 100644
--- a/board/ea3250/ea3250_prv.h
+++ b/board/ea3250/ea3250_prv.h
@@ -30,34 +30,9 @@
 // PHY address (configured via PHY ADRx pins)
 #define PHYDEF_PHYADDR           0x0001
 
-//------------------------------------------------------------------------------
-// PHY register and bitfield data
-//------------------------------------------------------------------------------
-
-// PHY Register indices
-#define PHY_REG_BMCR             0x00        // Basic Mode Control Register
-#define PHY_REG_BMSR             0x01        // Basic Mode Status Register
-#define PHY_REG_IDR1             0x02        // PHY Identifier 1
-#define PHY_REG_IDR2             0x03        // PHY Identifier 2
-#define PHY_REG_ANAR             0x04        // Auto-Negotiation Advertisement
-#define PHY_REG_ANLPAR           0x05        // Auto-Neg. Link Partner Abitily
-#define PHY_REG_ANER             0x06        // Auto-Neg. Expansion Register
-#define PHY_REG_ANNPTR           0x07        // Auto-Neg. Next Page TX
-
-// BMCR register specific control bits
-#define PHY_BMCR_RESET_BIT         0x8000    // Reset bit
-#define PHY_BMCR_SPEED_BIT         0x2000    // 100M speed enable bit
-#define PHY_BMCR_AUTON_BIT         0x1000    // Auto-negotiation rate bit
-
-// BMSR register specific control bits
-#define PHY_BMSR_LINKUP_STATUS     0x0004    // Link up status bit
-#define PHY_BMSR_AUTON_COMPLETE    0x0020    // Auto-negotiation complete bit
-#define PHY_BMSR_10M_HALF          0x0800    // 10MBase with half duplex support
-#define PHY_BMSR_10M_FULL          0x1000    // 10MBase with full duplex support
-#define PHY_BMSR_TX_HALF           0x2000    // TX with half duplex support
-#define PHY_BMSR_TX_FULL           0x4000    // TX with full duplex support
-#define PHY_BMSR_T4_ABLE           0x8000    // T4 able
-
+// DP83848 Ethernet Phy Extended Register
+#define DP83848_PHY_STATUS	0x10
+
 // Maximum ethernet frame size, maximum RX and TX packets
 #define ENET_MAXF_SIZE             1536
 #define ENET_MAX_TX_PACKETS        16
diff --git a/board/ea3250/net.c b/board/ea3250/net.c
index e17700b..29f3bd3 100644
--- a/board/ea3250/net.c
+++ b/board/ea3250/net.c
@@ -29,6 +29,7 @@
 #include <lpc3250.h>
 #include <configs/ea3250.h>
 #include "ea3250_prv.h"
+#include "miiphy.h"
 
 static unsigned long g_dmabase;
 static unsigned long gdma_size;
@@ -114,7 +115,7 @@ int HYPHYReset(void)
 	unsigned long tmp1, mst;
 
 	// Reset the PHY and wait for reset to complete
-	goodacc = RMII_Write(PHY_REG_BMCR, PHY_BMCR_RESET_BIT);
+	goodacc = RMII_Write(PHY_BMCR, PHY_BMCR_RESET);
 	if (goodacc == 0)
 	{
 		return 0;
@@ -123,8 +124,8 @@ int HYPHYReset(void)
 	goodacc = 0;
 	while (mst > 0)
 	{
-		RMII_Read(PHY_REG_BMCR, &tmp1);
-		if ((tmp1 & PHY_BMCR_RESET_BIT) == 0)
+		RMII_Read(PHY_BMCR, &tmp1);
+		if ((tmp1 & PHY_BMCR_RESET) == 0)
 		{
 			mst = 0;
 			goodacc = 1;
@@ -139,6 +140,43 @@ int HYPHYReset(void)
 	return goodacc;
 }
 
+static int phy_get_link_status (void)
+{
+        unsigned long status;
+
+        /* Status is read once to clear old link state */
+        RMII_Read(PHY_BMSR,&status);
+
+        /*
+	 * Wait if the link is up, and autonegotiation is in progress
+	 * (ie - we're capable and it's not done)
+	 */
+        status = 0;
+        RMII_Read(PHY_BMSR,&status);
+        if ((status & PHY_BMSR_LS) && (status & PHY_BMSR_AUTN_ABLE)
+            && !(status & PHY_BMSR_AUTN_COMP)) {
+                int i = 0;
+
+                while (!(status & PHY_BMSR_AUTN_COMP)) {
+                        /* Timeout reached */
+                        if (i > 1000) {
+                                printf("Timeout\n");
+                                return 1;
+                        }
+                        i++;
+                        msDelay(1);   /* 1 ms */
+                        RMII_Read(PHY_BMSR,&status);
+                }
+                return 0;
+        } else {
+                if (status & PHY_BMSR_LS)
+                        return 0;
+                else
+                        return 1;
+        }
+        return 1;
+}
+
 //------------------------------------------------------------------------------
 int txrx_setup(void)
 {
@@ -232,7 +270,8 @@ int txrx_setup(void)
 //------------------------------------------------------------------------------
 int HWInit(bd_t * bd)
 {
-	int btemp, goodacc;
+	int btemp;
+	unsigned int duplex, speed;
 	unsigned long tmp1, mst = 250;
 
 	// Enable MAC interface
@@ -276,92 +315,41 @@ int HWInit(bd_t * bd)
 	// MII setup
 	ENETMAC->command = COMMAND_PASSRUNTFRAME;
 #endif
-
-	// Reset PHY
-	goodacc = HYPHYReset();
-	if (goodacc == 0)
-	{
-		printf("ENET:Reset of PHY timed out\n");
-		return 0;
-	}
-
 	// Enable rate auto-negotiation for the link
-	if (RMII_Write(PHY_REG_BMCR,
-		(PHY_BMCR_SPEED_BIT | PHY_BMCR_AUTON_BIT)) == 0)
-	{
-		return 0;
-	}
-
-	// Wait up to 5 seconds for auto-negotiation to finish
-	mst = 5000;
-	goodacc = 1;
-	btemp = 0;
-	while (mst > 0)
-	{
-		goodacc &= RMII_Read(PHY_REG_BMSR, &tmp1);
-		if ((tmp1 & PHY_BMSR_AUTON_COMPLETE) != 0)
-		{
-			mst = 0;
-			btemp = 1;
-			printf("ENET:auto-negotiation complete\n");
-		}
-		else
-		{
-			mst--;
-			msDelay(1);
-		}
-	}
-	if ((goodacc == 0) || (btemp == 0))
+	if (RMII_Write(PHY_BMCR,
+		(PHY_BMCR_100MB | PHY_BMCR_AUTON)) == 0)
 	{
-		printf("ENET:auto-negotiation failed\n");
 		return 0;
 	}
-
-	// Check link status
-	mst = 1000;
-	goodacc = 1;
-	btemp = 0;
-	while (mst > 0)
-	{
-		goodacc &= RMII_Read(PHY_REG_BMSR, &tmp1);
-		if ((tmp1 & PHY_BMSR_LINKUP_STATUS) != 0)
-		{
-			mst = 0;
-			btemp = 1;
-			printf("ENET:Link status up\n");
-		}
-		else
-		{
-			mst--;
-			msDelay(1);
-		}
-	}
-	if ((goodacc == 0) || (btemp == 0))
-	{
-		printf("ENET:Link status failure\n");
-		return 0;
-	}
-
-	// Try 100MBase/full duplex
-	goodacc = btemp = 0;
-	if ((tmp1 & PHY_BMSR_TX_FULL) != 0)
-	{
-		// Setup for full duplex and 100MBase
-		goodacc = btemp = 1;
-	}
-	else if ((tmp1 & PHY_BMSR_TX_HALF) != 0)
-	{
-		// Setup for half duplex and 100MBase
-		goodacc = 1;
-	}
-	else if ((tmp1 & PHY_BMSR_TX_HALF) != 0)
-	{
-		// Setup for full duplex and 10MBase
-		btemp = 1;
-	}
-
+        
+	mst = 1000;
+        btemp = 1;
+        while(mst > 0)
+        {
+                /* Wait for Link status to set UP or Timeout */
+                if(phy_get_link_status() == 0) {
+                        mst = 0;
+                        btemp = 0;
+                        printf("ENET:auto-negotiation complete#$\n");
+                }
+                else {
+                        mst--;
+                        msDelay(1);
+                }
+        }
+        if(btemp) {
+                printf("ENET:auto-negotiation failed#$\n");
+                return 0;
+        }
+
+        /* Read PHY Status Register to determine Ethernet Configuration */
+        tmp1 = 0;
+        RMII_Read (DP83848_PHY_STATUS,&tmp1);
+        duplex = (tmp1 & 0x0004) >> 2;
+        speed = (tmp1 & 0x0002) >> 1;
+
 	// Configure Full/Half Duplex mode
-	if (btemp == 1)
+	if (duplex == 1)
 	{
 		// 10MBase full duplex is supported
 		ENETMAC->mac2 |= MAC2_FULL_DUPLEX;
@@ -376,7 +364,7 @@ int HWInit(bd_t * bd)
 	}
 
 	// Configure 100MBit/10MBit mode
-	if (goodacc == 1)
+	if (speed == 0)
 	{
 		// 100MBase mode
 		ENETMAC->supp = SUPP_SPEED;
@@ -412,8 +400,8 @@ int HWInit(bd_t * bd)
 	// Perform a 'dummy' send of the first ethernet frame with a size of 0
 	// to 'prime' the MAC. The first packet after a reset seems to wait
 	// until at least 2 packets are ready to go.
-	goodacc = 0;
-	eth_send(&goodacc, 4);
+	tmp1 = 0;
+	eth_send(&tmp1, 4);
 
 	return 1;
 }
@@ -475,6 +463,7 @@ int eth_init (bd_t * bd)
 	{
 		printf ("ENET init failure\n");
 		HWDeInit();
+		return -1;
 	}
 
 	return 0;
diff --git a/board/phy3250/net.c b/board/phy3250/net.c
index e1c1eeb..a96d3e8 100644
--- a/board/phy3250/net.c
+++ b/board/phy3250/net.c
@@ -29,6 +29,7 @@
 #include <lpc3250.h>
 #include <configs/phy3250.h>
 #include "phy3250_prv.h"
+#include "miiphy.h"
 
 static unsigned long g_dmabase;
 static unsigned long gdma_size;
@@ -106,39 +107,47 @@ int RMII_Read(unsigned long PhyReg, unsigned long *data)
 
 	return sts;
 }
-
-//------------------------------------------------------------------------------
-int HYPHYReset(void)
-{
-	int goodacc;
-	unsigned long tmp1, mst;
-
-	// Reset the PHY and wait for reset to complete
-	goodacc = RMII_Write(PHY_REG_BMCR, PHY_BMCR_RESET_BIT);
-	if (goodacc == 0)
-	{
-		return 0;
-	}
-	mst = 400;
-	goodacc = 0;
-	while (mst > 0)
-	{
-		RMII_Read(PHY_REG_BMCR, &tmp1);
-		if ((tmp1 & PHY_BMCR_RESET_BIT) == 0)
-		{
-			mst = 0;
-			goodacc = 1;
-		}
-		else
-		{
-			mst--;
-			msDelay(1);
-		}
-	}
-
-	return goodacc;
-}
-
+
+static int phy_get_link_status (void)
+{
+	unsigned long status;
+
+	/* Status is read once to clear old link state */
+	RMII_Read(PHY_BMSR,&status);
+
+	/*
+	 * Wait if the link is up, and autonegotiation is in progress
+	 * (ie - we're capable and it's not done)
+	 */
+	status = 0;
+	RMII_Read(PHY_BMSR,&status);
+	if ((status & PHY_BMSR_LS) && (status & PHY_BMSR_AUTN_ABLE)
+			&& !(status & PHY_BMSR_AUTN_COMP)) {
+		int i = 0;
+
+		while (!(status & PHY_BMSR_AUTN_COMP)) {
+			/*
+			 * Timeout reached ?
+			 */
+			if (i > 1000) {
+				/* Time Out Occur */
+				printf("Timeout\n");
+				return 1;
+			}
+			i++;
+			msDelay(1);   /* 1 ms */
+			RMII_Read(PHY_BMSR,&status);
+		}
+		return 0;
+	} else {
+		if (status & PHY_BMSR_LS)
+			return 0;
+		else
+			return 1;
+	}
+	return 1;
+}
+
 //------------------------------------------------------------------------------
 int txrx_setup(void)
 {
@@ -232,8 +241,10 @@ int txrx_setup(void)
 //------------------------------------------------------------------------------
 int HWInit(bd_t * bd)
 {
-	int btemp, goodacc;
-	unsigned long tmp1, mst = 250;
+	int btemp;
+	unsigned int duplex, speed;
+	unsigned long tmp1, mst = 250;
+	int val = 0;
 
 	// Enable MAC interface
 	CLKPWR->clkpwr_macclk_ctrl = (CLKPWR_MACCTRL_HRCCLK_EN |
@@ -276,92 +287,59 @@ int HWInit(bd_t * bd)
 	// MII setup
 	ENETMAC->command = COMMAND_PASSRUNTFRAME;
 #endif
-
-	// Reset PHY
-	goodacc = HYPHYReset();
-	if (goodacc == 0)
-	{
-		printf("ENET:Reset of PHY timed out\n");
-		return 0;
-	}
-
-	// Enable rate auto-negotiation for the link
-	if (RMII_Write(PHY_REG_BMCR,
-		(PHY_BMCR_SPEED_BIT | PHY_BMCR_AUTON_BIT)) == 0)
-	{
-		return 0;
-	}
-
-	// Wait up to 5 seconds for auto-negotiation to finish
-	mst = 5000;
-	goodacc = 1;
-	btemp = 0;
-	while (mst > 0)
-	{
-		goodacc &= RMII_Read(PHY_REG_BMSR, &tmp1);
-		if ((tmp1 & PHY_BMSR_AUTON_COMPLETE) != 0)
-		{
-			mst = 0;
-			btemp = 1;
-			printf("ENET:auto-negotiation complete\n");
-		}
-		else
-		{
-			mst--;
-			msDelay(1);
-		}
-	}
-	if ((goodacc == 0) || (btemp == 0))
-	{
-		printf("ENET:auto-negotiation failed\n");
-		return 0;
-	}
-
-	// Check link status
-	mst = 1000;
-	goodacc = 1;
-	btemp = 0;
-	while (mst > 0)
-	{
-		goodacc &= RMII_Read(PHY_REG_BMSR, &tmp1);
-		if ((tmp1 & PHY_BMSR_LINKUP_STATUS) != 0)
-		{
-			mst = 0;
-			btemp = 1;
-			printf("ENET:Link status up\n");
-		}
-		else
-		{
-			mst--;
-			msDelay(1);
-		}
-	}
-	if ((goodacc == 0) || (btemp == 0))
+
+	mst = 1000;
+	btemp = 1;
+	while(mst > 0)
 	{
-		printf("ENET:Link status failure\n");
-		return 0;
-	}
-
-	// Try 100MBase/full duplex
-	goodacc = btemp = 0;
-	if ((tmp1 & PHY_BMSR_TX_FULL) != 0)
-	{
-		// Setup for full duplex and 100MBase
-		goodacc = btemp = 1;
-	}
-	else if ((tmp1 & PHY_BMSR_TX_HALF) != 0)
-	{
-		// Setup for half duplex and 100MBase
-		goodacc = 1;
-	}
-	else if ((tmp1 & PHY_BMSR_TX_HALF) != 0)
-	{
-		// Setup for full duplex and 10MBase
-		btemp = 1;
-	}
-
+		/* Wait for Link status to set UP or Timeout */
+		if(phy_get_link_status() == 0) {
+			mst = 0;
+			btemp = 0;
+			printf("ENET:auto-negotiation complete\n");
+		}
+		else {
+			mst--;
+			msDelay(1);
+		}
+	}
+	if(btemp) {
+		printf("ENET:auto-negotiation failed.\n");
+		return 0;
+	}
+
+	/*
+	 *  Read Vendor specific PHY Ctrl/Status Register to determine
+	 *  Ethernet Configuration
+	 */
+	tmp1 = 0;
+	RMII_Read (LAN8700_PHY_STATUS,&tmp1);
+	val = (tmp1 & 0x1c) >> 2;
+	switch (val) {
+		case 1:
+			/* 10Mbps Half Duplex */
+			duplex = 0;
+			speed = 0;
+			break;
+		case 5:
+			/* 10Mbps Full Duplex */
+			duplex = 1;
+			speed = 0;
+			break;
+		case 2:
+			/* 100Mbps Half Duplex */
+			duplex = 0;
+			speed = 1;
+			break;
+		case 6:
+			/* 100Mbps Full Duplex */
+			duplex = 1;
+			speed = 1;
+			break;
+	}
+
 	// Configure Full/Half Duplex mode
-	if (btemp == 1)
+	if (duplex == 1)
 	{
 		// 10MBase full duplex is supported
 		ENETMAC->mac2 |= MAC2_FULL_DUPLEX;
@@ -376,7 +354,7 @@ int HWInit(bd_t * bd)
 	}
 
 	// Configure 100MBit/10MBit mode
-	if (goodacc == 1)
+	if (speed == 1)
 	{
 		// 100MBase mode
 		ENETMAC->supp = SUPP_SPEED;
@@ -412,8 +390,8 @@ int HWInit(bd_t * bd)
 	// Perform a 'dummy' send of the first ethernet frame with a size of 0
 	// to 'prime' the MAC. The first packet after a reset seems to wait
 	// until at least 2 packets are ready to go.
-	goodacc = 0;
-	eth_send(&goodacc, 4);
+	tmp1 = 0;
+	eth_send(&tmp1, 4);
 
 	return 1;
 }
@@ -421,9 +399,6 @@ int HWInit(bd_t * bd)
 //------------------------------------------------------------------------------
 int HWDeInit(void)
 {
-	// Reset PHY
-	(void) HYPHYReset();
-
 	// Reset all MAC logic
 	ENETMAC->mac1 = (MAC1_SOFT_RESET | MAC1_SIMULATION_RESET |
 		MAC1_RESET_MCS_TX | MAC1_RESET_TX | MAC1_RESET_MCS_RX |
@@ -466,6 +441,7 @@ int eth_init (bd_t * bd)
 	{
 		printf ("ENET init failure\n");
 		HWDeInit();
+		return -1;
 	}
 
 	return 0;
diff --git a/board/phy3250/phy3250.c b/board/phy3250/phy3250.c
index 2c48408..ac4c010 100644
--- a/board/phy3250/phy3250.c
+++ b/board/phy3250/phy3250.c
@@ -77,7 +77,7 @@ void reset_timer (void)
 ulong get_timer (ulong base)
 {
 	ulong tcr = TIMER_CNTR0->tc;
-	return tcr;
+	return tcr - base;
 }
 
 void timer_init(void)
diff --git a/board/phy3250/phy3250_prv.h b/board/phy3250/phy3250_prv.h
index 6b040f8..d955bb2 100644
--- a/board/phy3250/phy3250_prv.h
+++ b/board/phy3250/phy3250_prv.h
@@ -114,35 +114,10 @@ extern PHY_HW_T phyhwdesc;
 
 // PHY address (configured via PHY ADRx pins)
 #define PHYDEF_PHYADDR           0x00
-
-//------------------------------------------------------------------------------
-// PHY register and bitfield data
-//------------------------------------------------------------------------------
-
-// PHY Register indices
-#define PHY_REG_BMCR             0x00        // Basic Mode Control Register
-#define PHY_REG_BMSR             0x01        // Basic Mode Status Register
-#define PHY_REG_IDR1             0x02        // PHY Identifier 1
-#define PHY_REG_IDR2             0x03        // PHY Identifier 2
-#define PHY_REG_ANAR             0x04        // Auto-Negotiation Advertisement
-#define PHY_REG_ANLPAR           0x05        // Auto-Neg. Link Partner Abitily
-#define PHY_REG_ANER             0x06        // Auto-Neg. Expansion Register
-#define PHY_REG_ANNPTR           0x07        // Auto-Neg. Next Page TX
-
-// BMCR register specific control bits
-#define PHY_BMCR_RESET_BIT         0x8000    // Reset bit
-#define PHY_BMCR_SPEED_BIT         0x2000    // 100M speed enable bit
-#define PHY_BMCR_AUTON_BIT         0x1000    // Auto-negotiation rate bit
-
-// BMSR register specific control bits
-#define PHY_BMSR_LINKUP_STATUS     0x0004    // Link up status bit
-#define PHY_BMSR_AUTON_COMPLETE    0x0020    // Auto-negotiation complete bit
-#define PHY_BMSR_10M_HALF          0x0800    // 10MBase with half duplex support
-#define PHY_BMSR_10M_FULL          0x1000    // 10MBase with full duplex support
-#define PHY_BMSR_TX_HALF           0x2000    // TX with half duplex support
-#define PHY_BMSR_TX_FULL           0x4000    // TX with full duplex support
-#define PHY_BMSR_T4_ABLE           0x8000    // T4 able
-
+
+// LAN8700 Ethernet Phy Ctrl/Status Register
+#define LAN8700_PHY_STATUS	0x1F
+
 // Maximum ethernet frame size, maximum RX and TX packets
 #define ENET_MAXF_SIZE             1536
 #define ENET_MAX_TX_PACKETS        16
-- 
1.7.0.4


From 1b953789847926f7e9217a39746829caac794e42 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:52:11 -0700
Subject: [PATCH 08/28] Added support for NOR FLASH on the Phytec board

---
 board/phy3250/phy3250.c   |   35 ++++++++++++++++++++++++-
 include/configs/phy3250.h |   21 +++++++++++++-
 include/lpc3250.h         |   62 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 115 insertions(+), 3 deletions(-)

diff --git a/board/phy3250/phy3250.c b/board/phy3250/phy3250.c
index ac4c010..6492b8e 100644
--- a/board/phy3250/phy3250.c
+++ b/board/phy3250/phy3250.c
@@ -36,6 +36,24 @@ extern PHY_HW_T phyhwdesc;
 extern void phy3250_get_board_info(void);
 extern int dcache_kill(void);
 
+/* Initialize NOR Flash configuration */
+#ifdef CONFIG_FLASH_CFI_LEGACY
+ulong board_flash_get_legacy (ulong base, int banknum, flash_info_t * info)
+{
+	/*
+	 * PHY3250 board contains two 16-bit SPANSION NOR flash
+	 * to make a single 32 bit NOR flash. 
+	 */
+	if (banknum == 0) {     /* non-CFI boot flash */
+		info->portwidth = FLASH_CFI_32BIT;
+		info->chipwidth = FLASH_CFI_BY16;
+		info->interface = FLASH_CFI_X16;
+		return 1;
+	} else
+		return 0;
+}
+#endif
+
 /*
  * Dummy function to handle errors for EABI incompatibility
  */
@@ -214,7 +232,22 @@ int board_init (void)
                     SLCTAC_RWIDTH(15) |
                     SLCTAC_RHOLD(15) |
                     SLCTAC_RSETUP(15));
-#endif	
+#endif
+
+#ifdef CONFIG_SYS_FLASH_CFI
+	/* Use 32-bit memory interface for NOR Flash */
+	EMC->emcstatic_regs[0].emcstaticconfig = 0x82;
+	/* 
+	 * After Setting a higher clock speed, change the NOR timings to 
+	 * optimum value to get maximum bandwidth
+	 */
+	EMC->emcstatic_regs[0].emcstaticwaitwen = 0x0;
+	EMC->emcstatic_regs[0].emcstaticwait0en = 0x0;
+	EMC->emcstatic_regs[0].emcstaticwaitrd = 0xb;
+	EMC->emcstatic_regs[0].emcstaticpage = 0xb;
+	EMC->emcstatic_regs[0].emcstaticwr = 0x3;
+	EMC->emcstatic_regs[0].emcstaticturn = 0x1;
+#endif
 
 	return 0;
 }
diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
index e474613..8c6fb6c 100644
--- a/include/configs/phy3250.h
+++ b/include/configs/phy3250.h
@@ -94,8 +94,19 @@
 /*
  * NOR FLASH not supported
  */
-#define CONFIG_SYS_NO_FLASH
-#undef CONFIG_ENV_IS_IN_FLASH
+/* NOR Flash (Spansion S29AL008D) */
+#define CONFIG_FLASH_CFI_LEGACY         
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_BASE		(0xE0000000)
+#define CONFIG_SYS_MAX_FLASH_BANKS	(1)
+#define CONFIG_SYS_MAX_FLASH_SECT	19
+#define CONFIG_SYS_FLASH_BANKS_LIST	{ CONFIG_SYS_FLASH_BASE }
+#define CONFIG_SYS_FLASH_LEGACY_512Kx16	1
+#define CONFIG_SYS_FLASH_CFI_WIDTH	FLASH_CFI_16BIT
+
+/* Uncomment below line if you want to store environment in NOR */
+/* #define CONFIG_ENV_IS_IN_FLASH */
 
 /*
  * 1KHz clock tick
@@ -116,10 +127,16 @@
 /*
  * Address and size of Environment Data
  */
+#ifdef CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_SECT_SIZE	0x8000
+#define CONFIG_ENV_SIZE		(CONFIG_ENV_SECT_SIZE)
+#define CONFIG_ENV_ADDR		(0xE0008000) /* Sector 3 (0x8000 - 0xFFFF) */
+#else
 #define CONFIG_ENV_IS_IN_NAND	1
 #define CONFIG_ENV_SIZE		0x4000 /* 1 block */
 #define CONFIG_ENV_OFFSET	0x168000 /* Block 90 */
 #define CONFIG_ENV_ADDR		0x80000100 /* Passed to kernel here */
+#endif
 
 /*
  * Area and size for malloc
diff --git a/include/lpc3250.h b/include/lpc3250.h
index cf7dcde..009fce4 100644
--- a/include/lpc3250.h
+++ b/include/lpc3250.h
@@ -2022,6 +2022,68 @@ typedef struct
 #define I2C_SEVEN   _BIT(9)         /* Seven-bit slave address */
 #define I2C_TFFSIE  _BIT(10)        /* Slave Trnsmt FIFO Not Full IE */
 
+/**********************************************************************
+* External Memory Controller register definitions
+**********************************************************************/
+/* Static chip select configuration structure */
+typedef struct
+{
+  volatile unsigned int emcstaticconfig;
+  volatile unsigned int emcstaticwaitwen;
+  volatile unsigned int emcstaticwait0en;
+  volatile unsigned int emcstaticwaitrd;
+  volatile unsigned int emcstaticpage;
+  volatile unsigned int emcstaticwr;
+  volatile unsigned int emcstaticturn;
+  volatile unsigned int reserved;
+} EMC_STATIC_CFG;
+
+/*  AHB control structure */
+typedef struct
+{
+  volatile unsigned int emcahbcontrol;
+  volatile unsigned int emcahbstatus;
+  volatile unsigned int emcahbtimeout;
+  volatile unsigned int reserved [5];
+} EMC_AHB_CTRL_T;
+
+typedef struct
+{
+  volatile unsigned int emccontrol;
+  volatile unsigned int emcstatus;
+  volatile unsigned int emcconfig;
+  volatile unsigned int reserved1 [5];
+  volatile unsigned int emcdynamiccontrol;
+  volatile unsigned int emcdynamicrefresh;
+  volatile unsigned int emcdynamicreadconfig;
+  volatile unsigned int reserved2;
+  volatile unsigned int emcdynamictrp;
+  volatile unsigned int emcdynamictras;
+  volatile unsigned int emcdynamictsrex;
+  volatile unsigned int reserved3 [2];
+  volatile unsigned int emcdynamictwr;
+  volatile unsigned int emcdynamictrc;
+  volatile unsigned int emcdynamictrfc;
+  volatile unsigned int emcdynamictxsr;
+  volatile unsigned int emcdynamictrrd;
+  volatile unsigned int emcdynamictmrd;
+  volatile unsigned int emcdynamictcdlr;
+  volatile unsigned int reserved4 [8];
+  volatile unsigned int emcstaticextendedwait;
+  volatile unsigned int reserved5 [31];
+  volatile unsigned int emcdynamicconfig0;
+  volatile unsigned int emcdynamicrascas0;
+  volatile unsigned int reserved6 [6];
+  volatile unsigned int emcdynamicconfig1;
+  volatile unsigned int emcdynamicrascas1;
+  volatile unsigned int reserved7 [54];
+  EMC_STATIC_CFG  emcstatic_regs [4];
+  volatile unsigned int reserved8 [96];
+  EMC_AHB_CTRL_T  emcahn_regs [5];
+} EMC_REGS_T;
+
+/* Macro pointing to EMC registers */
+#define EMC  ((EMC_REGS_T *)(EMC_BASE))
 
 #endif /* __LPC3250_H */
 
-- 
1.7.0.4


From 1408ec2975f8df33762d35b9fb790ef92cd1e2ac Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Mon, 19 Jul 2010 03:53:12 -0700
Subject: [PATCH 09/28] Added NAND hardware ECC support and other enhancements

---
 board/ea3250/Makefile           |    2 +-
 board/ea3250/nand.c             |  188 ---------------
 board/phy3250/Makefile          |    2 +-
 board/phy3250/nand.c            |  190 ---------------
 drivers/dma/Makefile            |    1 +
 drivers/dma/lpc32xx_dma.c       |  130 ++++++++++
 drivers/mtd/nand/Makefile       |    1 +
 drivers/mtd/nand/lpc32xx_nand.c |  504 +++++++++++++++++++++++++++++++++++++++
 include/configs/ea3250.h        |   22 ++-
 include/configs/phy3250.h       |   21 ++-
 include/lpc3250.h               |  307 ++++++++++++++++++++++++
 11 files changed, 984 insertions(+), 384 deletions(-)
 delete mode 100644 board/ea3250/nand.c
 delete mode 100644 board/phy3250/nand.c
 create mode 100644 drivers/dma/lpc32xx_dma.c
 create mode 100644 drivers/mtd/nand/lpc32xx_nand.c

diff --git a/board/ea3250/Makefile b/board/ea3250/Makefile
index 55b71e5..135a524 100644
--- a/board/ea3250/Makefile
+++ b/board/ea3250/Makefile
@@ -25,7 +25,7 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(BOARD).a
 
-COBJS	:= ea3250.o nand.o net.o
+COBJS	:= ea3250.o net.o
 COBJS	+= lowlevelsys_init.o
 SOBJS	:= lowlevel_init.o
 
diff --git a/board/ea3250/nand.c b/board/ea3250/nand.c
deleted file mode 100644
index d7f8c04..0000000
--- a/board/ea3250/nand.c
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
- * (C) Copyright 2007-2008
- * Stelian Pop <stelian.pop@leadtechdesign.com>
- * Lead Tech Design <www.leadtechdesign.com>
- *
- * (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include "lpc3250.h"
-#include <nand.h>
-#include <asm/errno.h>
-
-#define	NAND_ALE_OFFS   4
-#define	NAND_CLE_OFFS   8
-
-static void ea3250_nand_init(void)
-{
-	/* Enable clocks to the SLC NAND controller */
-	CLKPWR->clkpwr_nand_clk_ctrl = 0x05;
-
-        /* Reset SLC NAND controller & clear ECC */
-        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
-
-        /* 8-bit bus, no DMA, CE normal */
-        SLCNAND->slc_cfg = 0;
-
-        /* Interrupts disabled and cleared */
-        SLCNAND->slc_ien = 0;
-        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
-
-        SLCNAND->slc_tac = (SLCTAC_WDR(14) |
-                    SLCTAC_WWIDTH(5) |
-                    SLCTAC_WHOLD(2) |
-                    SLCTAC_WSETUP(1) |
-                    SLCTAC_RDR(14) |
-                    SLCTAC_RWIDTH(4) |
-                    SLCTAC_RHOLD(2) |
-                    SLCTAC_RSETUP(1));
-}
-
-static void ea3250_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
-{
-	struct nand_chip *this = mtd->priv;
-	ulong *pCMD, IO_ADDR_W;
-
-	if (ctrl & NAND_CTRL_CHANGE) {
-		IO_ADDR_W = (ulong) this->IO_ADDR_W;
-		IO_ADDR_W &= ~(NAND_CLE_OFFS | NAND_ALE_OFFS);
-
-		if ( ctrl & NAND_CLE ) {
-			IO_ADDR_W |= NAND_CLE_OFFS;
-		}
-		else if ( ctrl & NAND_ALE ) {
-			IO_ADDR_W |= NAND_ALE_OFFS;
-		}
-
-		if ( ctrl & NAND_NCE ) {
-			SLCNAND->slc_cfg |= SLCCFG_CE_LOW;
-		}
-		else {
-			SLCNAND->slc_cfg &= ~SLCCFG_CE_LOW;
-		}
-
-		this->IO_ADDR_W = (void *) IO_ADDR_W;
-	}
-
-	if (cmd != NAND_CMD_NONE) {
-		pCMD = (ulong *) this->IO_ADDR_W;
-		*pCMD = cmd;
-	}
-}
-
-static int ea3250_nand_ready(struct mtd_info *mtd)
-{
-	/* Check the SLC NAND controller status */
-	return (SLCNAND->slc_stat & SLCSTAT_NAND_READY);
-}
-
-static u_char ea3250_read_byte(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
-	volatile unsigned long tmp32;
-	tmp32 = *pReg;
-	return (u_char) tmp32;
-}
-
-/**
- * ea3250_write_buf - [DEFAULT] write buffer to chip
- * @mtd:	MTD device structure
- * @buf:	data buffer
- * @len:	number of bytes to write
- *
- * Default write function for 8bit buswith
- */
-static void ea3250_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
-{
-	int i;
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_W;
-
-	for (i=0; i<len; i++)
-		*pReg = (unsigned long) buf[i];
-}
-
-/**
- * ea3250_read_buf - [DEFAULT] read chip data into buffer
- * @mtd:	MTD device structure
- * @buf:	buffer to store date
- * @len:	number of bytes to read
- *
- * Default read function for 8bit buswith
- */
-static void ea3250_read_buf(struct mtd_info *mtd, u_char *buf, int len)
-{
-	int i;
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
-	volatile unsigned long tmp32;
-
-	for (i=0; i<len; i++)
-	{
-		tmp32 = *pReg;
-		buf[i] = (u_char) tmp32;
-	}
-}
-
-/**
- * nand_verify_buf - [DEFAULT] Verify chip data against buffer
- * @mtd:	MTD device structure
- * @buf:	buffer containing the data to compare
- * @len:	number of bytes to compare
- *
- * Default verify function for 8bit buswith
- */
-static int ea3250_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
-{
-	int i;
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
-	volatile unsigned long tmp32;
-
-	for (i=0; i<len; i++)
-	{
-		tmp32 = *pReg;
-		if (buf[i] != (u_char) tmp32)
-			return -EFAULT;
-	}
-
-	return 0;
-}
-
-int board_nand_init(struct nand_chip *nand)
-{
-	/* Initial NAND interface */
-	ea3250_nand_init();
-
-	nand->ecc.mode = NAND_ECC_SOFT;
-	nand->cmd_ctrl = ea3250_nand_hwcontrol;
-	nand->dev_ready = ea3250_nand_ready;
-	nand->chip_delay = 2000;
-
-	nand->read_byte = ea3250_read_byte;
-	nand->write_buf = ea3250_write_buf;
-	nand->read_buf = ea3250_read_buf;
-	nand->verify_buf = ea3250_verify_buf;
-
-	return 0;
-}
diff --git a/board/phy3250/Makefile b/board/phy3250/Makefile
index 3c0d392..1d29f1a 100644
--- a/board/phy3250/Makefile
+++ b/board/phy3250/Makefile
@@ -25,7 +25,7 @@ include $(TOPDIR)/config.mk
 
 LIB	= $(obj)lib$(BOARD).a
 
-COBJS	:= phy3250.o nand.o net.o
+COBJS	:= phy3250.o net.o
 COBJS	+= lowlevelsys_init.o
 SOBJS	:= lowlevel_init.o
 
diff --git a/board/phy3250/nand.c b/board/phy3250/nand.c
deleted file mode 100644
index bf3a57b..0000000
--- a/board/phy3250/nand.c
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * (C) Copyright 2007-2008
- * Stelian Pop <stelian.pop@leadtechdesign.com>
- * Lead Tech Design <www.leadtechdesign.com>
- *
- * (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-
-#include <common.h>
-#include "lpc3250.h"
-#include <nand.h>
-#include <asm/errno.h>
-
-#define	NAND_ALE_OFFS   4
-#define	NAND_CLE_OFFS   8
-
-static void phy3250_nand_init(void)
-{
-	/* Enable clocks to the SLC NAND controller */
-	CLKPWR->clkpwr_nand_clk_ctrl = 0x05;
-
-        /* Reset SLC NAND controller & clear ECC */
-        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
-
-        /* 8-bit bus, no DMA, CE normal */
-        SLCNAND->slc_cfg = 0;
-
-        /* Interrupts disabled and cleared */
-        SLCNAND->slc_ien = 0;
-        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
-
-	/* This is optimized for a 266MHz clock rate, but will work fine for
-           rates lower then 266MHz */
-        SLCNAND->slc_tac = (SLCTAC_WDR(3) |
-                    SLCTAC_WWIDTH(10) |
-                    SLCTAC_WHOLD(3) |
-                    SLCTAC_WSETUP(4) |
-                    SLCTAC_RDR(3) |
-                    SLCTAC_RWIDTH(10) |
-                    SLCTAC_RHOLD(3) |
-                    SLCTAC_RSETUP(4));
-}
-
-static void phy3250_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
-{
-	struct nand_chip *this = mtd->priv;
-	ulong *pCMD, IO_ADDR_W;
-
-	if (ctrl & NAND_CTRL_CHANGE) {
-		IO_ADDR_W = (ulong) this->IO_ADDR_W;
-		IO_ADDR_W &= ~(NAND_CLE_OFFS | NAND_ALE_OFFS);
-
-		if ( ctrl & NAND_CLE ) {
-			IO_ADDR_W |= NAND_CLE_OFFS;
-		}
-		else if ( ctrl & NAND_ALE ) {
-			IO_ADDR_W |= NAND_ALE_OFFS;
-		}
-
-		if ( ctrl & NAND_NCE ) {
-			SLCNAND->slc_cfg |= SLCCFG_CE_LOW;
-		}
-		else {
-			SLCNAND->slc_cfg &= ~SLCCFG_CE_LOW;
-		}
-
-		this->IO_ADDR_W = (void *) IO_ADDR_W;
-	}
-
-	if (cmd != NAND_CMD_NONE) {
-		pCMD = (ulong *) this->IO_ADDR_W;
-		*pCMD = cmd;
-	}
-}
-
-static int phy3250_nand_ready(struct mtd_info *mtd)
-{
-	/* Check the SLC NAND controller status */
-	return (SLCNAND->slc_stat & SLCSTAT_NAND_READY);
-}
-
-static u_char phy3250_read_byte(struct mtd_info *mtd)
-{
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
-	volatile unsigned long tmp32;
-	tmp32 = *pReg;
-	return (u_char) tmp32;
-}
-
-/**
- * phy3250_write_buf - [DEFAULT] write buffer to chip
- * @mtd:	MTD device structure
- * @buf:	data buffer
- * @len:	number of bytes to write
- *
- * Default write function for 8bit buswith
- */
-static void phy3250_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
-{
-	int i;
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_W;
-
-	for (i=0; i<len; i++)
-		*pReg = (unsigned long) buf[i];
-}
-
-/**
- * phy3250_read_buf - [DEFAULT] read chip data into buffer
- * @mtd:	MTD device structure
- * @buf:	buffer to store date
- * @len:	number of bytes to read
- *
- * Default read function for 8bit buswith
- */
-static void phy3250_read_buf(struct mtd_info *mtd, u_char *buf, int len)
-{
-	int i;
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
-	volatile unsigned long tmp32;
-
-	for (i=0; i<len; i++)
-	{
-		tmp32 = *pReg;
-		buf[i] = (u_char) tmp32;
-	}
-}
-
-/**
- * nand_verify_buf - [DEFAULT] Verify chip data against buffer
- * @mtd:	MTD device structure
- * @buf:	buffer containing the data to compare
- * @len:	number of bytes to compare
- *
- * Default verify function for 8bit buswith
- */
-static int phy3250_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
-{
-	int i;
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
-	volatile unsigned long tmp32;
-
-	for (i=0; i<len; i++)
-	{
-		tmp32 = *pReg;
-		if (buf[i] != (u_char) tmp32)
-			return -EFAULT;
-	}
-
-	return 0;
-}
-
-int board_nand_init(struct nand_chip *nand)
-{
-	/* Initial NAND interface */
-	phy3250_nand_init();
-
-	nand->ecc.mode = NAND_ECC_SOFT;
-	nand->cmd_ctrl = phy3250_nand_hwcontrol;
-	nand->dev_ready = phy3250_nand_ready;
-	nand->chip_delay = 2000;
-
-	nand->read_byte = phy3250_read_byte;
-	nand->write_buf = phy3250_write_buf;
-	nand->read_buf = phy3250_read_buf;
-	nand->verify_buf = phy3250_verify_buf;
-
-	return 0;
-}
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index cf29efa..22b6596 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -26,6 +26,7 @@ include $(TOPDIR)/config.mk
 LIB	:= $(obj)libdma.a
 
 COBJS-$(CONFIG_FSLDMAFEC) += MCD_tasksInit.o MCD_dmaApi.o MCD_tasks.o
+COBJS-$(CONFIG_SYS_LPC32XX_DMA) += lpc32xx_dma.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/dma/lpc32xx_dma.c b/drivers/dma/lpc32xx_dma.c
new file mode 100644
index 0000000..5d9421d
--- /dev/null
+++ b/drivers/dma/lpc32xx_dma.c
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ * 
+ * @Author: Kevin Wells
+ * @Descr: LPC3250 DMA controller interface support functions
+ *  
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *  
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *  
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <lpc3250.h>
+#include <asm/io.h>
+
+
+/* Some optimization stuff */
+#ifndef unlikely
+#define likely(x)	__builtin_expect(!!(x), 1)
+#define unlikely(x)	__builtin_expect(!!(x), 0)
+#endif
+
+#define DMA_CLK_ENABLE      1
+/**********************************************************************
+* DMA controller register structures
+**********************************************************************/
+static uint32_t alloc_ch;
+
+int lpc32xx_dma_get_channel(void)
+{
+	int i;
+	uint32_t status = 0;
+
+	if (!alloc_ch) { /* First time caller */
+		CLKPWR->clkpwr_dmaclk_ctrl |= DMA_CLK_ENABLE;
+		/* Make sure DMA controller and all channels are disabled.
+		*        Controller is in little-endian mode. Disable sync signals */
+		dma_base->config = 0;
+		dma_base->sync = 0;
+
+		/* Clear interrupt and error statuses */
+		dma_base->int_tc_clear = 0xFF;
+		dma_base->raw_tc_stat = 0xFF;
+		dma_base->int_err_clear = 0xFF;
+		dma_base->raw_err_stat = 0xFF;
+
+		/* Enable DMA controller */
+		dma_base->config = DMAC_CTRL_ENABLE;
+	}
+
+	for (i = 0; i < DMA_NO_OF_CHANNELS && (status & _BIT(i)); i++)
+	       ;
+
+	/* Check if all the available channles are busy */
+	if (unlikely(i == DMA_NO_OF_CHANNELS)) return -1;
+	alloc_ch |= _BIT(i);
+	return i;
+}
+
+int lpc32xx_dma_start_xfer(int channel, const dmac_ll_t *desc, uint32_t config)
+{
+	if (unlikely((_BIT(channel) & alloc_ch) == 0)) {
+		printf ("ERR: Request for xfer on "
+		       "unallocated channel %d\r\n", channel);
+		BUG();
+	}
+	dma_base->int_tc_clear = _BIT(channel);
+	dma_base->int_err_clear = _BIT(channel);
+	dma_base->dma_chan[channel].src_addr = desc->dma_src;
+	dma_base->dma_chan[channel].dest_addr = desc->dma_dest;
+	dma_base->dma_chan[channel].lli = desc->next_lli;
+	dma_base->dma_chan[channel].control = desc->next_ctrl;
+	dma_base->dma_chan[channel].config_ch = config;
+
+	return 0;
+}
+
+int lpc32xx_dma_wait_status(int channel)
+{
+	while((
+	      (dma_base->raw_tc_stat | dma_base->raw_err_stat) &
+	      _BIT(channel)) == 0
+	     ) ;
+
+	if (unlikely(dma_base->raw_err_stat & _BIT(channel))) {
+		dma_base->int_err_clear |= _BIT(channel);
+		dma_base->raw_err_stat |= _BIT(channel);
+		return -1;
+	}
+	dma_base->int_tc_clear |= _BIT(channel);
+	dma_base->raw_tc_stat |= _BIT(channel);
+	return 0;
+}
+
+void lpc32xx_dma_put_channel(int channel)
+{
+	/* Check if given channel no is valid */
+	if (channel >= DMA_NO_OF_CHANNELS || channel < 0)
+		return ;
+	alloc_ch &= ~_BIT(channel);
+
+	/* Shut down channel */
+	dma_base->dma_chan [channel].control = 0;
+	dma_base->dma_chan [channel].config_ch = 0;
+	dma_base->sync &= ~_BIT(channel);
+
+	if (!alloc_ch) {
+		/* Disable DMA controller */
+		dma_base->config &= ~DMAC_CTRL_ENABLE;
+
+		/* If all channels are free disable the clock */
+		CLKPWR->clkpwr_dmaclk_ctrl &= ~DMA_CLK_ENABLE;
+	}
+}
+
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 5974d77..004e239 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -41,6 +41,7 @@ COBJS-$(CONFIG_NAND_FSL_UPM) += fsl_upm.o
 COBJS-$(CONFIG_NAND_NOMADIK) += nomadik.o
 COBJS-$(CONFIG_NAND_S3C64XX) += s3c64xx.o
 COBJS-$(CONFIG_NAND_OMAP_GPMC) += omap_gpmc.o
+COBJS-$(CONFIG_SYS_LPC32XX_NAND) += lpc32xx_nand.o
 endif
 
 COBJS	:= $(COBJS-y)
diff --git a/drivers/mtd/nand/lpc32xx_nand.c b/drivers/mtd/nand/lpc32xx_nand.c
new file mode 100644
index 0000000..88f195e
--- /dev/null
+++ b/drivers/mtd/nand/lpc32xx_nand.c
@@ -0,0 +1,504 @@
+/*
+ * Copyright (C) 2008 by NXP Semiconductors
+ * All rights reserved.
+ * 
+ * @Author: Kevin Wells
+ * @Descr: LPC3250 SLC NAND controller interface support functions
+ * 
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include "lpc3250.h"
+#include <nand.h>
+#include <asm/errno.h>
+#include <asm/io.h>
+
+#define	NAND_ALE_OFFS	4
+#define	NAND_CLE_OFFS	8
+
+#define NAND_LARGE_BLOCK_PAGE_SIZE	2048
+#define NAND_SMALL_BLOCK_PAGE_SIZE	512
+
+static struct nand_ecclayout lpc32xx_nand_oob_16 = {
+        .eccbytes = 8,
+        .eccpos = {8, 9, 10, 11, 12, 13, 14, 15},
+        .oobfree = {
+                {.offset = 0,
+                 . length = 5},
+                {.offset = 6,
+                 . length = 2}}
+};
+
+static struct nand_ecclayout lpc32xx_nand_oob_64 = {
+        .eccbytes = 32,
+        .eccpos = { 8, 9, 10, 11, 12, 13, 14, 15,
+		   24, 25, 26, 27, 28, 29, 30, 31,
+		   40, 41, 42, 43, 44, 45, 46, 47,
+		   56, 57, 58, 59, 60, 61, 62, 63},
+        .oobfree = {
+                {.offset = 2,
+                 . length = 6},
+                {.offset = 16,
+                 . length = 8},
+                {.offset = 32,
+                 . length = 8},
+                {.offset = 48,
+                 . length = 8}}
+};
+
+/*
+ * DMA Descriptors
+ * For Large Block: 17 descriptors = ((16 Data and ECC Read) + 1 Spare Area)
+ * For Small Block: 5 descriptors = ((4 Data and ECC Read) + 1 Spare Area)
+ */
+static dmac_ll_t dmalist[(CONFIG_SYS_NAND_ECCSIZE/256) * 2 + 1];
+static int dmachan = -1;
+
+static void lpc32xx_nand_init(void)
+{
+	/* Enable clocks to the SLC NAND controller */
+	CLKPWR->clkpwr_nand_clk_ctrl = (CLKPWR_NANDCLK_SEL_SLC | 
+					CLKPWR_NANDCLK_SLCCLK_EN);
+
+        /* Reset SLC NAND controller & clear ECC */
+        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
+
+        /* 8-bit bus, no DMA, CE normal */
+        SLCNAND->slc_cfg = 0;
+
+        /* Interrupts disabled and cleared */
+        SLCNAND->slc_ien = 0;
+        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
+
+        SLCNAND->slc_tac = LPC32XX_SLC_NAND_TIMING;
+}
+
+static void lpc32xx_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *this = mtd->priv;
+	ulong  IO_ADDR_W;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		IO_ADDR_W = (ulong) this->IO_ADDR_W;
+		IO_ADDR_W &= ~(NAND_CLE_OFFS | NAND_ALE_OFFS);
+
+		if ( ctrl & NAND_CLE ) {
+			IO_ADDR_W |= NAND_CLE_OFFS;
+		}
+		else if ( ctrl & NAND_ALE ) {
+			IO_ADDR_W |= NAND_ALE_OFFS;
+		}
+
+		if ( ctrl & NAND_NCE ) {
+			SLCNAND->slc_cfg |= SLCCFG_CE_LOW;
+		}
+		else {
+			SLCNAND->slc_cfg &= ~SLCCFG_CE_LOW;
+		}
+
+		this->IO_ADDR_W = (void *) IO_ADDR_W;
+	}
+
+	if (cmd != NAND_CMD_NONE) {
+		writel(cmd, this->IO_ADDR_W);
+	}
+}
+
+static int lpc32xx_nand_ready(struct mtd_info *mtd)
+{
+	/* Check the SLC NAND controller status */
+	return (SLCNAND->slc_stat & SLCSTAT_NAND_READY);
+}
+
+static u_char lpc32xx_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+	tmp32 = *pReg;
+	return (u_char) tmp32;
+}
+
+/*
+ * lpc32xx_write_buf - [DEFAULT] write buffer to chip
+ * mtd:	MTD device structure
+ * buf:	data buffer
+ * len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ */
+static void lpc32xx_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_W;
+
+	for (i=0; i<len; i++)
+		*pReg = (unsigned long) buf[i];
+}
+
+/*
+ * lpc32xx_read_buf - [DEFAULT] read chip data into buffer
+ * mtd:	MTD device structure
+ * buf:	buffer to store date
+ * len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ */
+static void lpc32xx_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+
+	for (i=0; i<len; i++) {
+		tmp32 = *pReg;
+		buf[i] = (u_char) tmp32;
+	}
+}
+
+/*
+ * lpc32xx_verify_buf - [DEFAULT] Verify chip data against buffer
+ * mtd:	MTD device structure
+ * buf:	buffer containing the data to compare
+ * len:	number of bytes to compare
+ *
+ * Default verify function for 8bit buswith
+ */
+static int lpc32xx_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
+{
+	int i;
+	struct nand_chip *this = mtd->priv;
+	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
+	volatile unsigned long tmp32;
+
+	for (i=0; i<len; i++) {
+		tmp32 = *pReg;
+		if (buf[i] != (u_char) tmp32)
+			return -EFAULT;
+	}
+	return 0;
+}
+
+static uint8_t nand_slc_bit_cnt16(uint16_t ch)
+{
+	ch = (ch & 0x5555) + ((ch & ~0x5555) >> 1);
+	ch = (ch & 0x3333) + ((ch & ~0x3333) >> 2);
+	ch = (ch & 0x0F0F) + ((ch & ~0x0F0F) >> 4);
+	return (ch + (ch >> 8)) & 0xFF;
+}
+
+static uint8_t bit_cnt32(uint32_t val)
+{
+	return nand_slc_bit_cnt16(val & 0xFFFF) +
+		nand_slc_bit_cnt16(val >> 16);
+}
+
+/* Prepares DMA descriptors for NAND RD/WR operations */
+static void lpc32xx_nand_dma_configure(struct nand_chip *chip,
+		const void * buffer, int size, int read)
+{
+	uint32_t i, dmasrc, ctrl, ecc_ctrl, oob_ctrl, dmadst;
+	uint32_t page_divider = (size == NAND_LARGE_BLOCK_PAGE_SIZE) ? 8: 2;
+	void __iomem * base = chip->IO_ADDR_R;
+	uint8_t *oob_buf = chip->oob_poi;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+	uint8_t *ecc_gen = chip->buffers->ecccalc;
+
+	/* 
+	 * CTRL descriptor entry for reading ECC
+	 * Copy Multiple times to sync DMA with Flash Controller
+	 */
+	ecc_ctrl =  (0x5 |
+			DMAC_CHAN_SRC_BURST_1 |
+			DMAC_CHAN_DEST_BURST_1 |
+			DMAC_CHAN_SRC_WIDTH_32 |
+			DMAC_CHAN_DEST_WIDTH_32 |
+			DMAC_CHAN_DEST_AHB1);
+
+	/* CTRL descriptor entry for reading/writing Data */
+	ctrl =  ((CONFIG_SYS_NAND_ECCSIZE / page_divider) / 4) |
+			DMAC_CHAN_SRC_BURST_4 |
+			DMAC_CHAN_DEST_BURST_4 |
+			DMAC_CHAN_SRC_WIDTH_32 |
+			DMAC_CHAN_DEST_WIDTH_32 |
+			DMAC_CHAN_DEST_AHB1;
+
+	/* CTRL descriptor entry for reading/writing Spare Area */
+	oob_ctrl =  ((CONFIG_SYS_NAND_OOBSIZE / 4) |
+			DMAC_CHAN_SRC_BURST_4 |
+			DMAC_CHAN_DEST_BURST_4 |
+			DMAC_CHAN_SRC_WIDTH_32 |
+			DMAC_CHAN_DEST_WIDTH_32 |
+			DMAC_CHAN_DEST_AHB1);
+
+	if (read) {
+		dmasrc = (uint32_t) (base + offsetof(SLCNAND_REGS_T, slc_dma_data));
+		dmadst = (uint32_t) (buffer);
+		ctrl |= DMAC_CHAN_DEST_AUTOINC;
+	} else {
+		dmadst = (uint32_t) (base + offsetof(SLCNAND_REGS_T, slc_dma_data));
+		dmasrc = (uint32_t) (buffer);
+		ctrl |= DMAC_CHAN_SRC_AUTOINC;
+	}
+
+	/*
+	 * Write Operation Sequence for Small Block NAND
+	 * ----------------------------------------------------------
+	 * 1. X'fer 256 bytes of data from Memory to Flash.
+	 * 2. Copy generated ECC data from Register to Spare Area
+	 * 3. X'fer next 256 bytes of data from Memory to Flash.
+	 * 4. Copy generated ECC data from Register to Spare Area.
+	 * 5. X'fer 16 byets of Spare area from Memory to Flash.
+	 * Read Operation Sequence for Small Block NAND
+	 * ----------------------------------------------------------
+	 * 1. X'fer 256 bytes of data from Flash to Memory.
+	 * 2. Copy generated ECC data from Register to ECC calc Buffer.
+	 * 3. X'fer next 256 bytes of data from Flash to Memory.
+	 * 4. Copy generated ECC data from Register to ECC calc Buffer.
+	 * 5. X'fer 16 bytes of Spare area from Flash to Memory.
+	 * Write Operation Sequence for Large Block NAND
+	 * ----------------------------------------------------------
+	 * 1. Steps(1-4) of Write Operations repeate for four times
+	 * which generates 16 DMA descriptors to X'fer 2048 bytes of
+	 * data & 32 bytes of ECC data.
+	 * 2. X'fer 64 bytes of Spare area from Memory to Flash.
+	 * Read Operation Sequence for Large Block NAND
+	 * ----------------------------------------------------------
+	 * 1. Steps(1-4) of Read Operations repeate for four times
+	 * which generates 16 DMA descriptors to X'fer 2048 bytes of 
+	 * data & 32 bytes of ECC data.
+	 * 2. X'fer 64 bytes of Spare area from Flash to Memory.
+	 */
+
+	for (i = 0; i < size/256; i++) {
+		dmalist[i*2].dma_src = (read ?(dmasrc) :(dmasrc + (i*256)));
+		dmalist[i*2].dma_dest = (read ?(dmadst + (i*256)) :dmadst);
+                dmalist[i*2].next_lli = (uint32_t) & dmalist[(i*2)+1];
+		dmalist[i*2].next_ctrl = ctrl;
+
+                dmalist[(i*2) + 1].dma_src = (uint32_t)
+				(base + offsetof(SLCNAND_REGS_T, slc_ecc));
+                dmalist[(i*2) + 1].dma_dest = (read ?((uint32_t) & ecc_gen[i*4]):
+				((uint32_t) & oob_buf[eccpos[i*4]]));
+                dmalist[(i*2) + 1].next_lli = (uint32_t) & dmalist[(i*2)+2];
+		dmalist[(i*2) + 1].next_ctrl = ecc_ctrl;
+	}
+
+	if (read) {
+		dmasrc = (uint32_t) (base + offsetof(SLCNAND_REGS_T, slc_dma_data));
+		dmadst = (uint32_t) (oob_buf);
+		oob_ctrl |= DMAC_CHAN_DEST_AUTOINC;
+	} else {
+		dmadst = (uint32_t) (base + offsetof(SLCNAND_REGS_T, slc_dma_data));
+		dmasrc = (uint32_t) (oob_buf);
+		oob_ctrl |= DMAC_CHAN_SRC_AUTOINC;
+	}
+
+	/* Read/ Write Spare Area Data To/From Flash */
+	dmalist[i*2].dma_src = dmasrc;
+	dmalist[i*2].dma_dest = dmadst;
+	dmalist[i*2].next_lli = 0;
+	dmalist[i*2].next_ctrl = (oob_ctrl | DMAC_CHAN_INT_TC_EN);
+}
+
+static void lpc32xx_dma_xfer(struct mtd_info *mtd, u_char *buf, int len, int read)
+{
+	struct nand_chip *chip = mtd->priv;
+	uint32_t config;
+
+	/* DMA Channel Configuration */
+	config = (read ? DMAC_CHAN_FLOW_D_P2M : DMAC_CHAN_FLOW_D_M2P) |
+		(read ? DMAC_DEST_PERIP(0) : DMAC_DEST_PERIP(DMA_PERID_NAND1)) |
+		(read ? DMAC_SRC_PERIP(DMA_PERID_NAND1) : DMAC_SRC_PERIP(0)) |
+		DMAC_CHAN_ENABLE;
+
+	/* Prepare DMA descriptors */
+	lpc32xx_nand_dma_configure(chip, buf, len, read);
+
+	/* Start DMA transfers */
+	lpc32xx_dma_start_xfer(dmachan, dmalist, config);
+	SLCNAND->slc_ctrl |= SLCCTRL_DMA_START;
+
+	/* Wait for NAND to be ready */
+	while(!lpc32xx_nand_ready(mtd));
+
+	/* Wait till DMA transfer is DONE */
+	lpc32xx_dma_wait_status(dmachan);
+
+	/* Stop DMA & HW ECC */
+	SLCNAND->slc_ctrl &= ~SLCCTRL_DMA_START;
+	SLCNAND->slc_cfg &= ~(SLCCFG_DMA_DIR | SLCCFG_DMA_BURST |
+				SLCCFG_ECC_EN | SLCCFG_DMA_ECC);
+}
+
+static int lpc32xx_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
+					     uint8_t *ecc_code)
+{
+	return 0;
+}
+
+static int lpc32xx_nand_correct_data(struct mtd_info *mtd, u_char *dat,
+		u_char *read_ecc, u_char *calc_ecc)
+{
+	int ret = 0;
+	uint32_t tmp, err;
+	uint32_t *ecc_stored = (uint32_t*)read_ecc;
+	uint32_t *ecc_gen = (uint32_t*)calc_ecc;
+
+		
+	err = *ecc_stored ^ *ecc_gen;
+	/* Only perform ECC processing if an error is detected */
+	if (err) {
+		/* ECC Failure in i-th block */
+		tmp = bit_cnt32(err);
+		if (tmp == 11) {
+			uint32_t byte = err >> 6;
+			uint32_t bit = 0;
+			bit = ((err & _BIT(1)) >> 1)|((err & _BIT(3)) >> 2)|
+				((err & _BIT(5)) >> 3);
+
+			/* Calculate Byte offset */
+			byte = ((byte & _BIT(1)) >> 1)|((byte & _BIT(3)) >> 2)|
+				((byte & _BIT(5)) >> 3)|((byte & _BIT(7)) >> 4)|
+				((byte & _BIT(9)) >> 5)|((byte & _BIT(11)) >> 6)|
+				((byte & _BIT(13)) >> 7)|((byte & _BIT(15)) >> 8);
+
+			/* Do the correction */
+			dat[byte] ^= _BIT(bit);
+			ret = 1;
+		}else {
+			/* Non-corrrectable */
+			ret = -1;
+		}
+	}
+	return ret;
+}
+
+/*
+ * Enables and prepares SLC NAND controller
+ * for doing data transfers with H/W ECC enabled.
+ */
+static void lpc32xx_hwecc_enable(struct mtd_info *mtd, int mode)
+{
+	struct nand_chip *this = mtd->priv;
+
+	/* Clear ECC, start DMA */
+	SLCNAND->slc_ctrl = SLCCTRL_ECC_CLEAR;
+
+	if (mode == NAND_ECC_READ)
+		SLCNAND->slc_cfg |= SLCCFG_DMA_DIR;
+	else  /* NAND_ECC_WRITE */
+		SLCNAND->slc_cfg &= ~SLCCFG_DMA_DIR;
+
+	SLCNAND->slc_cfg |= (SLCCFG_DMA_BURST | SLCCFG_ECC_EN |
+			SLCCFG_DMA_ECC);
+
+	/* Set transfer count */
+	SLCNAND->slc_tc = this->ecc.size + mtd->oobsize;
+}
+
+static void lpc32xx_nand_write_page_hwecc(struct mtd_info *mtd,
+		                struct nand_chip *chip, const uint8_t *buf)
+{
+        int i, eccsize = chip->ecc.size;
+
+	/* Enable H/W ECC & DMA */
+	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
+
+	/* Configure DMA Desriptor for NAND Write Operation */
+	lpc32xx_dma_xfer(mtd, buf, eccsize, 0);
+}
+
+static int lpc32xx_nand_read_page_hwecc(struct mtd_info *mtd,
+				 struct nand_chip *chip, uint8_t *buf, int page)
+{
+        int i, eccsize = chip->ecc.size;
+        int eccbytes = chip->ecc.bytes;
+        int eccsteps = chip->ecc.steps;
+        uint8_t *p = buf;
+        uint8_t *ecc_calc = chip->buffers->ecccalc;
+        uint8_t *ecc_code = chip->buffers->ecccode;
+        uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	/* Enable HW ECC & DMA */	
+	chip->ecc.hwctl(mtd, NAND_ECC_READ);
+
+	/* Configure DMA Desriptor for NAND Read Operation */
+	lpc32xx_dma_xfer(mtd, buf, eccsize, 1);
+
+	/* Copy only ECC data which are stored into Flash */
+        for (i = 0; i < chip->ecc.total; i++)
+                ecc_code[i] = chip->oob_poi[eccpos[i]];
+	
+	/* Check & Correct data */
+        for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
+                int stat;
+
+                stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
+                if (stat == -1)
+                        mtd->ecc_stats.failed++;
+                else
+                        mtd->ecc_stats.corrected += stat;
+        }
+	return 0;
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	/* Initial NAND interface */
+	lpc32xx_nand_init();
+
+	/* Acquire a channel for our use */
+	dmachan = lpc32xx_dma_get_channel();
+	if (unlikely(dmachan < 0)){
+		printk(KERN_INFO "Unable to get a free DMA "
+				"channel for NAND transfers\r\n");
+		return -1;
+	}
+
+	/* ECC mode and size */
+	nand->ecc.mode = NAND_ECC_HW;
+	nand->ecc.bytes	= CONFIG_SYS_NAND_ECCBYTES;
+	nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;
+	nand->ecc.read_page_raw = lpc32xx_nand_read_page_hwecc;
+	nand->ecc.read_page = lpc32xx_nand_read_page_hwecc;
+	nand->ecc.write_page = lpc32xx_nand_write_page_hwecc;
+	
+	if(CONFIG_SYS_NAND_ECCSIZE == NAND_LARGE_BLOCK_PAGE_SIZE)
+		nand->ecc.layout = &lpc32xx_nand_oob_64;
+	else
+		nand->ecc.layout = &lpc32xx_nand_oob_16;
+
+	nand->ecc.calculate = lpc32xx_ecc_calculate;
+	nand->ecc.correct = lpc32xx_nand_correct_data;
+	nand->ecc.hwctl = lpc32xx_hwecc_enable;
+	nand->cmd_ctrl = lpc32xx_nand_hwcontrol;
+	nand->dev_ready = lpc32xx_nand_ready;
+	nand->chip_delay = 2000;
+
+	nand->read_buf = lpc32xx_read_buf;
+	nand->write_buf = lpc32xx_write_buf;
+	nand->read_byte = lpc32xx_read_byte;
+	nand->verify_buf = lpc32xx_verify_buf;
+
+	return 0;
+}
diff --git a/include/configs/ea3250.h b/include/configs/ea3250.h
index d617619..7db397b 100644
--- a/include/configs/ea3250.h
+++ b/include/configs/ea3250.h
@@ -117,8 +117,8 @@
  * Address and size of Environment Data
  */
 #define CONFIG_ENV_IS_IN_NAND	1
-#define CONFIG_ENV_SIZE		0x20000    /* 1 block */
-#define CONFIG_ENV_OFFSET	0xE0000    /* Block 7 */
+#define CONFIG_ENV_SIZE		0x40000    /* 2 blocks */
+#define CONFIG_ENV_OFFSET	0xFA0000    /* Block 125 */
 #define CONFIG_ENV_ADDR		0x80000100 /* Passed to kernel here */
 
 /*
@@ -226,9 +226,27 @@
  * Support for NAND FLASH, environment store in NAND at block 100
  */
 #define CONFIG_CMD_NAND
+#define CONFIG_SYS_LPC32XX_NAND    /* Enable SLC NAND controller driver */
 #define CONFIG_SYS_MAX_NAND_DEVICE 1
 #define CONFIG_SYS_NAND_BASE 0x20020000 /* SLC NAND controller */
 #define CFG_ENV_IS_IN_NAND
+#define LPC32XX_SLC_NAND_TIMING (SLCTAC_WDR(14) | \
+                    SLCTAC_WWIDTH(5) | \
+                    SLCTAC_WHOLD(2) | \
+                    SLCTAC_WSETUP(1) | \
+                    SLCTAC_RDR(14) | \
+                    SLCTAC_RWIDTH(4) | \
+                    SLCTAC_RHOLD(2) | \
+                    SLCTAC_RSETUP(1))
+
+
+/*
+ * NAND H/W ECC specific settings
+ */
+#define CONFIG_SYS_LPC32XX_DMA            /* DMA supporte required */
+#define CONFIG_SYS_NAND_ECCSIZE      2048 /* ECC generated per page */
+#define CONFIG_SYS_NAND_ECCBYTES       32 /* 3 Bytes ECC per 256 Bytes */
+#define CONFIG_SYS_NAND_OOBSIZE        64 /* OOB size in bytes */
 
 /* allow to overwrite serial and ethaddr */
 #define CONFIG_ENV_OVERWRITE
diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
index 8c6fb6c..5a7e215 100644
--- a/include/configs/phy3250.h
+++ b/include/configs/phy3250.h
@@ -133,8 +133,8 @@
 #define CONFIG_ENV_ADDR		(0xE0008000) /* Sector 3 (0x8000 - 0xFFFF) */
 #else
 #define CONFIG_ENV_IS_IN_NAND	1
-#define CONFIG_ENV_SIZE		0x4000 /* 1 block */
-#define CONFIG_ENV_OFFSET	0x168000 /* Block 90 */
+#define CONFIG_ENV_SIZE		0x10000 /* 4 blocks */
+#define CONFIG_ENV_OFFSET	0x1F4000 /* Block 125 */
 #define CONFIG_ENV_ADDR		0x80000100 /* Passed to kernel here */
 #endif
 
@@ -227,9 +227,26 @@
  * Support for NAND FLASH, environment store in NAND at block 100
  */
 #define CONFIG_CMD_NAND
+#define CONFIG_SYS_LPC32XX_NAND    /* Enable SLC NAND controller driver */
 #define CONFIG_SYS_MAX_NAND_DEVICE 1
 #define CONFIG_SYS_NAND_BASE 0x20020000 /* SLC NAND controller */
 #define CFG_ENV_IS_IN_NAND
+#define LPC32XX_SLC_NAND_TIMING (SLCTAC_WDR(3) | \
+                    SLCTAC_WWIDTH(10) | \
+                    SLCTAC_WHOLD(3) | \
+                    SLCTAC_WSETUP(4) | \
+                    SLCTAC_RDR(3) | \
+                    SLCTAC_RWIDTH(10) | \
+                    SLCTAC_RHOLD(3) | \
+                    SLCTAC_RSETUP(4))
+
+/*
+ * NAND H/W ECC specific settings
+ */
+#define CONFIG_SYS_LPC32XX_DMA            /* DMA supporte required */
+#define CONFIG_SYS_NAND_ECCSIZE       512 /* ECC generated per page */
+#define CONFIG_SYS_NAND_ECCBYTES        8 /* 3 Bytes ECC per 256 Bytes */
+#define CONFIG_SYS_NAND_OOBSIZE        16 /* OOB size in bytes */
 
 /* allow to overwrite serial and ethaddr */
 #define CONFIG_ENV_OVERWRITE
diff --git a/include/lpc3250.h b/include/lpc3250.h
index 009fce4..4820968 100644
--- a/include/lpc3250.h
+++ b/include/lpc3250.h
@@ -551,6 +551,27 @@ typedef struct
 /* PWM 3 clock enable, (0) = disable, (1) = enable */
 #define CLKPWR_TMRPWMCLK_PWM3_EN   0x01
 
+/**********************************************************************
+ * clkpwr_nand_clk_ctrl register definitions
+ **********************************************************************/
+/* NAND FLASH controller interrupt select, (0) = SLC, (1) = MLC */
+#define CLKPWR_NANDCLK_INTSEL_MLC  0x20
+
+/* Enable DMA_REQ on NAND_RnB for MLC */
+#define CLKPWR_NANDCLK_DMA_RNB     0x10
+
+/* Enable DMA_REQ on NAND_INT for MLC */
+#define CLKPWR_NANDCLK_DMA_INT     0x08
+
+/* NAND FLASH controller select, (0) = MLC, (1) = SLC */
+#define CLKPWR_NANDCLK_SEL_SLC     0x04
+
+/* NAND FLASH MLC clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_NANDCLK_MLCCLK_EN   0x02
+
+/* NAND FLASH SLC clock enable, (0) = disable, (1) = enable */
+#define CLKPWR_NANDCLK_SLCCLK_EN   0x01
+
 /*
  * clkpwr_uart3_clk_ctrl, clkpwr_uart4_clk_ctrl, clkpwr_uart5_clk_ctrl
  * and clkpwr_uart6_clk_ctrl register definitions
@@ -1982,6 +2003,292 @@ typedef struct
 * I2C controller register structures
 **********************************************************************/
 
+/**********************************************************************
+* DMA controller register structures
+**********************************************************************/
+
+/* DMA controller channel register structure */
+typedef struct
+{
+  volatile uint32_t src_addr;
+  volatile uint32_t dest_addr;
+  volatile uint32_t lli;
+  volatile uint32_t control;
+  volatile uint32_t config_ch;
+  volatile uint32_t reserved [3];
+} DMAC_CHAN_T;
+
+/* DMA controller register structures */
+typedef struct
+{
+  volatile uint32_t int_stat;
+  volatile uint32_t int_tc_stat;
+  volatile uint32_t int_tc_clear;
+  volatile uint32_t int_err_stat;
+  volatile uint32_t int_err_clear;
+  volatile uint32_t raw_tc_stat;
+  volatile uint32_t raw_err_stat;
+  volatile uint32_t chan_enable;
+  volatile uint32_t sw_burst_req;
+  volatile uint32_t sw_single_req;
+  volatile uint32_t sw_last_burst_req;
+  volatile uint32_t sw_last_single_req;
+  volatile uint32_t config;
+  volatile uint32_t sync;
+  volatile uint32_t reserved [50];
+  DMAC_CHAN_T     dma_chan [8];
+} dma_regs_t;
+
+/* DMA linked list structure used with a channel's LLI register */
+typedef struct
+{
+  volatile uint32_t dma_src;
+  volatile uint32_t dma_dest;
+  volatile uint32_t next_lli;
+  volatile uint32_t next_ctrl;
+} dmac_ll_t;
+
+/**********************************************************************
+* int_stat, int_tc_stat, int_tc_clear, int_err_stat, raw_tc_stat,
+* raw_err_stat, and chan_enable register definitions
+**********************************************************************/
+/* Macro for determining a bit position for a channel */
+#define DMAC_GET_CHAN_POS(chan)     (0x1 << ((chan) & 0x7))
+
+/**********************************************************************
+* sw_burst_req, sw_single_req, sw_last_burst_req, sw_last_single_req,
+* and sync register definitions
+**********************************************************************/
+/* Peripheral DMA bit position for I2S0 DMA0 */
+#define DMA_PER_I2S0_DMA0           _BIT(0)
+
+/* Peripheral DMA bit position for NAND FLASH (same as 12) */
+#define DMA_PER_NAND1               _BIT(1)
+
+/* Peripheral DMA bit position for I2S1 DMA0 */
+#define DMA_PER_I2S1_DMA0           _BIT(2)
+
+/* Peripheral DMA bit position for SPI2 (RX and TX) */
+#define DMA_PER_SPI2_TXRX           _BIT(3)
+
+/* Peripheral DMA bit position for SSP1 (RX) */
+#define DMA_PER_SSP1_RX             _BIT(3)
+
+/* Peripheral DMA bit position for SD card */
+#define DMA_PER_SDCARD              _BIT(4)
+
+/* Peripheral DMA bit position for HSUART1 TX */
+#define DMA_PER_HSUART1_TX          _BIT(5)
+
+/* Peripheral DMA bit position for HSUART1 RX */
+#define DMA_PER_HSUART1_RX          _BIT(6)
+
+/* Peripheral DMA bit position for HSUART2 TX */
+#define DMA_PER_HSUART2_TX          _BIT(7)
+
+/* Peripheral DMA bit position for HSUART2 RX */
+#define DMA_PER_HSUART2_RX          _BIT(8)
+
+/* Peripheral DMA bit position for HSUART7 TX */
+#define DMA_PER_HSUART7_TX          _BIT(9)
+
+/* Peripheral DMA bit position for HSUART7 RX */
+#define DMA_PER_HSUART7_RX          _BIT(10)
+
+/* Peripheral DMA bit position for I2S1 DMA1 */
+#define DMA_PER_I2S1_DMA1           _BIT(10)
+
+/* Peripheral DMA bit position for SPI1 (RX and TX) */
+#define DMA_PER_SPI1_TXRX           _BIT(11)
+
+/* Peripheral DMA bit position for SSP1 (TX) */
+#define DMA_PER_SSP1_TX             _BIT(11)
+
+/* Peripheral DMA bit position for NAND FLASH (same as 1) */
+#define DMA_PER_NAND2               _BIT(12)
+
+/* Peripheral DMA bit position for I2S0 DMA1 */
+#define DMA_PER_I2S0_DMA1           _BIT(13)
+
+/* Peripheral DMA bit position for SSP0 (RX) */
+#define DMA_PER_SSP0_RX             _BIT(14)
+
+/* Peripheral DMA bit position for SSP0 (TX) */
+#define DMA_PER_SSP0_TX             _BIT(15)
+
+/**********************************************************************
+* config register definitions
+**********************************************************************/
+/* Bit for enabling big endian mode on AHB 1 */
+#define DMAC_BIG_ENDIAN_AHB1        _BIT(2)
+
+/* Bit for enabling big endian mode on AHB 0 */
+#define DMAC_BIG_ENDIAN_AHB0        _BIT(1)
+
+/* Bit for enabling the DMA controller */
+#define DMAC_CTRL_ENABLE            _BIT(0)
+
+/**********************************************************************
+* lli register definitions
+**********************************************************************/
+/* Bit for selecting AHB0 (0) or AHB1 (1) */
+#define DMAC_CHAN_LLI_SEL_AHB1      _BIT(0)
+
+/**********************************************************************
+* control register definitions
+**********************************************************************/
+/* Bit for enabling a channel terminal count interrupt */
+#define DMAC_CHAN_INT_TC_EN         _BIT(31)
+
+/* Bit for indicating address is cacheable */
+#define DMAC_CHAN_PROT3             _BIT(30)
+
+/* Bit for indicating address is bufferable */
+#define DMAC_CHAN_PROT2             _BIT(29)
+
+/* Bit for indicating address is privelaged mode (1) or user
+   mode (0) */
+#define DMAC_CHAN_PROT1             _BIT(28)
+
+/* Bit for enabling automatic destination increment */
+#define DMAC_CHAN_DEST_AUTOINC      _BIT(27)
+
+/* Bit for enabling automatic source increment */
+#define DMAC_CHAN_SRC_AUTOINC       _BIT(26)
+
+/* Bit for using AHB1 master for destination transfer */
+#define DMAC_CHAN_DEST_AHB1         _BIT(25)
+
+/* Bit for using AHB1 master for source transfer */
+#define DMAC_CHAN_SRC_AHB1          _BIT(24)
+
+/* Destination data width selection defines */
+#define DMAC_CHAN_DEST_WIDTH_8      0x0
+#define DMAC_CHAN_DEST_WIDTH_16     _BIT(21)
+#define DMAC_CHAN_DEST_WIDTH_32     _BIT(22)
+
+/* Source data width selection defines */
+#define DMAC_CHAN_SRC_WIDTH_8       0x0
+#define DMAC_CHAN_SRC_WIDTH_16      _BIT(18)
+#define DMAC_CHAN_SRC_WIDTH_32      _BIT(19)
+
+/* Destination data burst size defines (in transfer width) */
+#define DMAC_CHAN_DEST_BURST_1      0
+#define DMAC_CHAN_DEST_BURST_4      _BIT(15)
+#define DMAC_CHAN_DEST_BURST_8      _BIT(16)
+#define DMAC_CHAN_DEST_BURST_16     (_BIT(16) | _BIT(15))
+#define DMAC_CHAN_DEST_BURST_32     _BIT(17)
+#define DMAC_CHAN_DEST_BURST_64     (_BIT(17) | _BIT(15))
+#define DMAC_CHAN_DEST_BURST_128    (_BIT(17) | _BIT(16))
+#define DMAC_CHAN_DEST_BURST_256    (_BIT(17) | _BIT(16) | _BIT(15))
+
+/* Macro for direct loading of destination burst size field */
+#define DMAC_CHAN_DEST_BURST_LOAD(n) (((n) & 0x7) << 15)
+
+/* Source data burst size defines (in transfer width) */
+#define DMAC_CHAN_SRC_BURST_1       0
+#define DMAC_CHAN_SRC_BURST_4       _BIT(12)
+#define DMAC_CHAN_SRC_BURST_8       _BIT(13)
+#define DMAC_CHAN_SRC_BURST_16      (_BIT(13) | _BIT(12))
+#define DMAC_CHAN_SRC_BURST_32      _BIT(14)
+#define DMAC_CHAN_SRC_BURST_64      (_BIT(14) | _BIT(12))
+#define DMAC_CHAN_SRC_BURST_128     (_BIT(14) | _BIT(13))
+#define DMAC_CHAN_SRC_BURST_256     (_BIT(14) | _BIT(13) | _BIT(12))
+
+/* Macro for direct loading of source burst size field */
+#define DMAC_CHAN_SRC_BURST_LOAD(n) (((n) & 0x7) << 12)
+
+/* Macro for loading transfer size */
+#define DMAC_CHAN_TRANSFER_SIZE(n)  ((n) & 0xFFF)
+
+/**********************************************************************
+* config_ch register definitions
+**********************************************************************/
+/* Bit for halting a DMA transfer */
+#define DMAC_CHAN_HALT              _BIT(18)
+
+/* Bit for checking active status of the DMA channel */
+#define DMAC_CHAN_ACTIVE            _BIT(17)
+
+/* Bit for enabling locked transfers */
+#define DMAC_CHAN_LOCK              _BIT(16)
+
+/* Terminal count interrupt mask bit */
+#define DMAC_CHAN_ITC               _BIT(15)
+
+/* Interrupt error mask bit */
+#define DMAC_CHAN_IE                _BIT(14)
+
+/* Defines for flow control with DMA as the controller */
+#define DMAC_CHAN_FLOW_D_M2M        (0x0 << 11)
+#define DMAC_CHAN_FLOW_D_M2P        (0x1 << 11)
+#define DMAC_CHAN_FLOW_D_P2M        (0x2 << 11)
+#define DMAC_CHAN_FLOW_D_SP2DP      (0x3 << 11)
+
+/* Defines for flow control with destination peripheral as the
+   controller */
+#define DMAC_CHAN_FLOW_DP_SP2DP     (0x4 << 11)
+
+/* Defines for flow control with peripheral as the controller */
+#define DMAC_CHAN_FLOW_P_M2P        (0x5 << 11)
+#define DMAC_CHAN_FLOW_P_P2M        (0x6 << 11)
+
+/* Defines for flow control with source peripheral as the
+   controller */
+#define DMAC_CHAN_FLOW_SP_SP2DP     (0x7 << 11)
+
+/* Macro for loading destination peripheral */
+#define DMAC_DEST_PERIP(n)          (((n) & 0x1F) << 6)
+
+/* Macro for loading source peripheral */
+#define DMAC_SRC_PERIP(n)           (((n) & 0x1F) << 1)
+
+/* Channel enable bit */
+#define DMAC_CHAN_ENABLE            _BIT(0)
+
+/**********************************************************************
+* config_ch register definitions (source and destination
+* peripheral ID numbers). These can be used with the DMAC_DEST_PERIP
+* and DMAC_SRC_PERIP macros.
+**********************************************************************/
+#define DMA_PERID_I2S0_DMA0         0
+#define DMA_PERID_NAND1             1
+#define DMA_PERID_I2S1_DMA0         2
+#define DMA_PERID_SPI2_TXRX         3
+#define DMA_PERID_SSP1_RX           3
+#define DMA_PERID_SDCARD            4
+#define DMA_PERID_HSUART1_TX        5
+#define DMA_PERID_HSUART1_RX        6
+#define DMA_PERID_HSUART2_TX        7
+#define DMA_PERID_HSUART2_RX        8
+#define DMA_PERID_HSUART7_TX        9
+#define DMA_PERID_HSUART7_RX        10
+#define DMA_PERID_I2S1_DMA1         10
+#define DMA_PERID_SPI1_TXRX         11
+#define DMA_PERID_SSP1_TX           11
+#define DMA_PERID_NAND2             12
+#define DMA_PERID_I2S0_DMA1         13
+#define DMA_PERID_SSP0_RX           14
+#define DMA_PERID_SSP0_TX           15
+
+/* Macro pointing to DMA registers */
+#define dma_base ((dma_regs_t *)(DMA_BASE))
+#define DMA_NO_OF_CHANNELS  8
+#define DMA_ENABLED_CHNS (DMA_BASE + 0x1C)
+
+/* DMA Exported functions */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int lpc32xx_dma_get_channel(void);
+int lpc32xx_dma_start_xfer(int channel, const dmac_ll_t *desc, uint32_t config);
+int lpc32xx_dma_wait_status(int channel);
+void lpc32xx_dma_put_channel(int channel);
+
+#ifdef __cplusplus
+}
+#endif
 
 /**********************************************************************
 * i2c_txrx register definitions
-- 
1.7.0.4


From 27d4d531be42262617ca506356678dcf12d75d21 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Thu, 16 Sep 2010 06:48:48 -0700
Subject: [PATCH 10/28] Add support for FDI board
 Minor changes to EA3250 environment

---
 Makefile                       |    3 +
 cpu/arm926ejs/lpc3250/serial.c |  234 ++++++++++++++++++++++++++++++++++++++++
 include/configs/ea3250.h       |   45 +-------
 3 files changed, 242 insertions(+), 40 deletions(-)

diff --git a/Makefile b/Makefile
index cdc2b66..7b9d959 100644
--- a/Makefile
+++ b/Makefile
@@ -2718,6 +2718,9 @@ phy3250_config	:	unconfig
 ea3250_config:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm926ejs ea3250 NULL lpc3250
 
+fdi3250_config:	unconfig
+	@$(MKCONFIG) $(@:_config=) arm arm926ejs fdi3250 NULL lpc3250
+
 ########################################################################
 ## ARM Integrator boards - see doc/README-integrator for more info.
 integratorap_config	\
diff --git a/cpu/arm926ejs/lpc3250/serial.c b/cpu/arm926ejs/lpc3250/serial.c
index 5183c02..c736ae0 100644
--- a/cpu/arm926ejs/lpc3250/serial.c
+++ b/cpu/arm926ejs/lpc3250/serial.c
@@ -23,6 +23,7 @@
 
 #include <common.h>
 #include <lpc3250.h>
+#include <configs/fdi3250.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -72,6 +73,238 @@ void serial_getdiv(u32 baudrate,
 	}
 }
 
+#ifdef USE_HIGH_SPEED_UART
+void hsuart_getdiv(u32 baudrate,
+			unsigned int *xdiv)
+{
+  unsigned int clkrate, savedclkrate, diff, basepclk;
+  int idiv;
+  unsigned int divider;
+
+  /* Get the clock rate for the UART block */
+  basepclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+
+  /* Find the best divider */
+  divider = 0;
+  savedclkrate = 0;
+  diff = 0xFFFFFFFF;
+  for (idiv = 0; idiv < 0x100; idiv++)
+  {
+    clkrate = basepclk / (14 * (idiv + 1));
+    if (serial_abs(clkrate, baudrate) < diff)
+    {
+      diff = serial_abs(clkrate, baudrate);
+      savedclkrate = clkrate;
+      divider = idiv;
+    }
+  }
+
+  /* Save computed divider */
+  *xdiv = divider;
+}
+
+void serial_setbrg (void)
+{
+	unsigned int xdiv, ydiv;
+    unsigned int divider;
+    UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+
+    if (CFG_UART_SEL == UART1) {
+	    /* Find closest high speed baud rate for desired clock frequency */
+	    hsuart_getdiv(gd->baudrate, &divider);
+        phsuregs->rate = divider;
+
+        // Disable flow control
+        phsuregs->ctrl &= ~((1<<14)|(1<<18));
+    } else {
+	    /* Find closest baud rate for desired clock frequency */
+	    serial_getdiv(gd->baudrate, &xdiv, &ydiv);
+
+	    /* Set clock x/y divider for the UART */
+	    if (puregs == UART3)
+	    {
+		    CLKPWR->clkpwr_uart3_clk_ctrl =
+			    CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+	    }
+	    else if (puregs == UART4)
+	    {
+		    CLKPWR->clkpwr_uart4_clk_ctrl =
+			    CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+	    }
+	    else if (puregs == UART5)
+	    {
+		    CLKPWR->clkpwr_uart5_clk_ctrl =
+			    CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+	    }
+	    else if (puregs == UART6)
+	    {
+		    CLKPWR->clkpwr_uart6_clk_ctrl =
+			    CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+	    }
+    }
+}
+
+/*
+ * Initialise the serial port with the given baudrate. The settings
+ * are always 8 data bits, no parity, 1 stop bit, no start bits.
+ *
+ */
+int serial_init (void)
+{
+	volatile unsigned int tmp32;
+	int unum;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+
+	/* UART setup */
+
+    if (phsuregs == UART1) {
+	    /* set baudrate */
+	    serial_setbrg();
+
+        /* setup the buffers */
+        phsuregs->ctrl = (  (2<<19) /*HSU_HRTS_TRIG_32B*/ | 
+                            (3<<16) /* HSU_TMO_INACT_16B*/ |
+                            (0x14<<9) /* HSU_OFFSET(0x14)*/ | 
+                            (4<<2) /* HSU_RX_TL32B */ | 
+                            (0<<0) /* HSU_TX_TL0B */);
+    } else {
+	    /* Enable UART system clock */
+	    if (puregs == UART3)
+	    {
+		    CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART3_EN;
+		    unum = 3;
+	    }
+	    else if (puregs == UART4)
+	    {
+		    CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART4_EN;
+		    unum = 4;
+	    }
+	    else if (puregs == UART5)
+	    {
+		    CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART5_EN;
+		    unum = 5;
+	    }
+	    else if (puregs == UART6)
+	    {
+		    CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART6_EN;
+		    unum = 6;
+	    }
+
+	    /* Place UART in autoclock mode */
+	    tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum);
+	    UARTCNTL->clkmode = (tmp32 |
+		    UART_CLKMODE_LOAD(UART_CLKMODE_AUTO, (unum)));
+
+	    /* UART baud rate generator isn't used, so just set it to divider
+	       by 1 */
+	    puregs->lcr |= UART_LCR_DIVLATCH_EN;
+	    puregs->dll_fifo = 1;
+	    puregs->dlm_ier = 0;
+	    puregs->lcr &= ~UART_LCR_DIVLATCH_EN;
+
+	    /* Setup default UART state for N81 with FIFO mode */
+	    puregs->lcr = UART_LCR_WLEN_8BITS;
+
+	    /* set baudrate */
+	    serial_setbrg();
+
+	    /* Clear FIFOs and set FIFO level */
+	    puregs->iir_fcr = (UART_FCR_RXFIFO_TL16 |
+		    UART_FCR_TXFIFO_TL0 | UART_FCR_FIFO_CTRL |
+		    UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
+		    UART_FCR_RXFIFO_FLUSH);
+	    tmp32 = puregs->iir_fcr;
+	    tmp32 = puregs->lsr;
+
+	    /* Use automatic clocking */
+    //	tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum + 3);
+    //	UARTCNTL->clkmode = tmp32 | UART_CLKMODE_LOAD(
+    //        	UART_CLKMODE_AUTO, (unum + 3));  // TBD delete me
+    }
+
+	return 0;
+}
+
+/*
+ * Read a single byte from the serial port.
+ */
+int serial_getc (void)
+{
+    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+
+    if (phsuregs == UART1) {
+        // Wait for a character to come in
+        while ((phsuregs->level & 0xFF) == 0)
+            {}
+        // Send the received character back
+        return ((unsigned char)(phsuregs->txrx_fifo));
+    } else {
+	    /* Wait for a character from the UART */
+	    while ((puregs->lsr & UART_LSR_RDR) == 0);
+
+	    return (int) (puregs->dll_fifo & 0xFF);
+    }
+}
+
+/*
+ * Output a single byte to the serial port.
+ */
+void serial_putc (const char c)
+{
+    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+
+    if (phsuregs == UART1) {
+        // Send out the character
+        phsuregs->txrx_fifo = c;
+        
+        // Wait for character to be sent (goes from non-zero to 0)
+        while ((phsuregs->level & 0xFF00) != 0);
+    } else {
+	    /* Wait for FIFO to become empty */
+	    while ((puregs->lsr & UART_LSR_THRE) == 0);
+
+	    puregs->dll_fifo = (u32) c;
+    }
+
+	/* If \n, also do \r */
+	if (c == '\n')
+	{
+		serial_putc ('\r');
+	}
+}
+
+/*
+ * Test whether a character is in the RX buffer
+ */
+int serial_tstc (void)
+{
+    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+
+    if (phsuregs == UART1) {
+	    /* Wait for a character from the UART */
+	    if ((phsuregs->level & 0xFF) == 0)
+	    {
+            // No characters waiting
+            return 0;
+        }
+    } else {
+	    /* Wait for a character from the UART */
+	    if ((puregs->lsr & UART_LSR_RDR) == 0)
+	    {
+		    return 0;
+	    }
+    }
+
+    // Got here, must be a character waiting
+	return 1;
+}
+
+#else
 void serial_setbrg (void)
 {
 	unsigned int xdiv, ydiv;
@@ -212,6 +445,7 @@ int serial_tstc (void)
 
 	return 1;
 }
+#endif
 
 /*
  * Put a string to the UART
diff --git a/include/configs/ea3250.h b/include/configs/ea3250.h
index 7db397b..c8dec8f 100644
--- a/include/configs/ea3250.h
+++ b/include/configs/ea3250.h
@@ -269,18 +269,15 @@
 #define CONFIG_BOOTFILE		"uImage"  /* File to load */
 #define CONFIG_LOADADDR		0x80100000	   
 #define CONFIG_ROOTPATH		/home/user/ltib/rootfs
-#define CONFIG_BOOTARGS		
-
-#define CONFIG_BOOTCOMMAND	"run mtdboot"
-
-#define CONFIG_NFSBOOTCOMMAND					\
- "setenv bootargs root=/dev/nfs rw "				\
+#define CONFIG_BOOTARGS		"root=/dev/nfs rw "		\
 	"nfsroot=$(serverip):$(rootpath) "			\
 	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
 	"console=ttyS0,115200n8;"				\
 	"run loadkernel;"					\
 	"bootm $(loadaddr)"
 
+#define CONFIG_BOOTCOMMAND	"dhcp; bootm"
+
 #define MTDBOOTCOMMAND "mtdboot="				\
  "setenv bootargs root=/dev/mtdblock3 rw rootfstype=jffs2 "	\
 	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
@@ -288,45 +285,13 @@
 	"run loadkernel;"					\
 	"bootm $(loadaddr)\0"
 
-#define UPDATEKERNEL "update_kernel="				\
-	"run loadkernel; "					\
-	"nand erase $(nand_kernel_off) $(nand_kernel_sz); "	\
-	"nand write.jffs2 $(loadaddr) $(nand_kernel_off) $(nand_kernel_sz)\0"
-
-#define UPDATEROOTFS "update_fs="				\
-	"run loadrootfs; "					\
-	"nand erase $(nand_rootfs_off) $(nand_rootfs_sz); "	\
-	"nand write.jffs2 $(loadaddr) $(nand_rootfs_off) $(nand_rootfs_sz)\0"
-
-#define UPDATEUBOOT_TFTP "update_uboot_tftp="		\
-	"tftpboot $(loadaddr) u-boot.bin; "		\
-	"nand erase 0x60000 0x40000; "			\
-	"nand write $(loadaddr) 0x60000 0x40000\0"
-
 /*
  * Other preset environment variables and example bootargs string
  */
 
 #define CONFIG_EXTRA_ENV_SETTINGS \
-	"nand_kernel_off=0x100000\0" \
-	"nand_kernel_sz=0x1a0000\0" \
-	"nand_rootfs_off=0x500000\0" \
-	"nand_rootfs_sz=0x500000\0" \
-	"loadkernel=usb start;fatload usb 0 $(loadaddr) uImage;usb stop\0" \
-	"loadkernel_nand=nboot.jffs2 $(loadaddr) 0x0 $(nand_kernel_off)\0" \
-	"loadkernel_tftp=tftpboot $(loadaddr) uImage\0" \
-	"loadkernel_usb=usb start;fatload usb 0 $(loadaddr) uImage;usb stop\0" \
-	"loadrootfs=usb start;fatload usb 0 $(loadaddr) rootfs.jffs2;usb stop\0" \
-	"loadrootfs_tftp=tftpboot $(loadaddr) rootfs.jffs2\0" \
-	"loadrootfs_usb=usb start;fatload usb 0 $(loadaddr) rootfs.jffs2;usb stop\0" \
-	"erase_env=nand erase 0xe0000 0x20000\0" \
-	MTDBOOTCOMMAND \
-	UPDATEKERNEL \
-	UPDATEROOTFS \
-	UPDATEUBOOT_TFTP
-
-
- 
+	MTDBOOTCOMMAND 
+
 /*
  * BOOTP options
  */
-- 
1.7.0.4


From 4ccb0670f6743a64ab27760eb58762a542d61f10 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Thu, 16 Sep 2010 10:07:08 -0700
Subject: [PATCH 11/28] Fix problem introduced in previous patch *%*&

---
 cpu/arm926ejs/lpc3250/serial.c |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)

diff --git a/cpu/arm926ejs/lpc3250/serial.c b/cpu/arm926ejs/lpc3250/serial.c
index c736ae0..02765c2 100644
--- a/cpu/arm926ejs/lpc3250/serial.c
+++ b/cpu/arm926ejs/lpc3250/serial.c
@@ -23,7 +23,6 @@
 
 #include <common.h>
 #include <lpc3250.h>
-#include <configs/fdi3250.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
-- 
1.7.0.4


From 79cdfd21e75b44673972e5491b1598217bbae6a6 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Thu, 11 Nov 2010 15:55:12 -0800
Subject: [PATCH 12/28] LPC32x0: FDI3250 : Add missing files that should of been in v1.02

---
 board/fdi3250/Makefile           |   52 ++++
 board/fdi3250/config.mk          |   37 +++
 board/fdi3250/fdi3250.c          |  174 ++++++++++++
 board/fdi3250/fdi3250_prv.h      |   38 +++
 board/fdi3250/lowlevel_init.S    |   60 ++++
 board/fdi3250/lowlevelsys_init.c |   37 +++
 board/fdi3250/net.c              |  549 ++++++++++++++++++++++++++++++++++++++
 board/fdi3250/u-boot.lds         |   61 +++++
 include/configs/fdi3250.h        |  284 ++++++++++++++++++++
 9 files changed, 1292 insertions(+), 0 deletions(-)
 create mode 100644 board/fdi3250/Makefile
 create mode 100644 board/fdi3250/config.mk
 create mode 100644 board/fdi3250/fdi3250.c
 create mode 100644 board/fdi3250/fdi3250_prv.h
 create mode 100644 board/fdi3250/lowlevel_init.S
 create mode 100644 board/fdi3250/lowlevelsys_init.c
 create mode 100644 board/fdi3250/net.c
 create mode 100644 board/fdi3250/u-boot.lds
 create mode 100644 include/configs/fdi3250.h

diff --git a/board/fdi3250/Makefile b/board/fdi3250/Makefile
new file mode 100644
index 0000000..90cfb7e
--- /dev/null
+++ b/board/fdi3250/Makefile
@@ -0,0 +1,52 @@
+#
+# Copyright (C) 2010 by NXP Semiconductors
+# All rights reserved.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	:= fdi3250.o net.o
+COBJS	+= lowlevelsys_init.o
+SOBJS	:= lowlevel_init.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak .depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/fdi3250/config.mk b/board/fdi3250/config.mk
new file mode 100644
index 0000000..8facfe3
--- /dev/null
+++ b/board/fdi3250/config.mk
@@ -0,0 +1,37 @@
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# Embedded Artists LPC3250 OEM Board with or without S1L
+#
+
+#
+# 32 MB SDRAM @ 0x80000000
+#
+# Linux-Kernel is @ 0x80008000, entry 0x80008000
+# params @ 0x80000100
+# optionally with a ramdisk at 0x80300000
+#
+# we load ourself to 0x00000000 or 0x83FC0000
+#
+# download area is 0x80f00000
+#
+
+TEXT_BASE = 0x81FC0000
+
diff --git a/board/fdi3250/fdi3250.c b/board/fdi3250/fdi3250.c
new file mode 100644
index 0000000..c4a3b0c
--- /dev/null
+++ b/board/fdi3250/fdi3250.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2010 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <configs/fdi3250.h>
+#include <asm/mach-types.h>
+#include <lpc3250.h>
+#include <net.h>
+#include "fdi3250_prv.h"
+		
+DECLARE_GLOBAL_DATA_PTR;
+extern int dcache_kill(void);
+
+/*
+ * Dummy function to handle errors for EABI incompatibility
+ */
+void raise(void)
+{
+}
+
+/*
+ * Dummy function to handle errors for EABI incompatibility
+ */
+void abort(void)
+{
+}
+
+void reset_timer (void)
+{
+	unsigned int clkdlycnt, tbaseclk;
+
+	/* Reset timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR0->tcr = 0;
+	TIMER_CNTR0->tc = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR0->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR0->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
+	/* Set prescale counter value for a 1mS tick */
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	clkdlycnt = (tbaseclk / CONFIG_SYS_HZ);
+	TIMER_CNTR0->pr = clkdlycnt - 1;
+
+	/* Enable the timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_EN;
+}
+
+ulong get_timer (ulong base)
+{
+	ulong tcr = TIMER_CNTR0->tc;
+	return tcr - base;
+}
+
+void timer_init(void)
+{
+	/* Enable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
+		CLKPWR_TMRPWMCLK_TIMER0_EN;
+
+	reset_timer();
+}
+
+/*
+ * Use the watchdog timer to reset the system
+ */
+void reset_cpu(ulong addr)
+{
+	/* Enable the WDT clock */
+	CLKPWR->clkpwr_timer_clk_ctrl |= CLKPWR_PWMCLK_WDOG_EN;
+
+	/* Force RESETOUT_N active */
+	WDT->wdtim_mctrl = WDT_RESFRC1;
+	WDT->wdtim_ctrl = WDT_COUNT_ENAB;
+
+	/* Wait forever */
+	while (1);
+}
+
+void udelay(unsigned long usec)
+{
+	unsigned long tbaseclk;
+
+	/* Enable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
+		CLKPWR_TMRPWMCLK_TIMER1_EN;
+
+	/* Reset timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR1->tcr = 0;
+	TIMER_CNTR1->tc = 0;
+	TIMER_CNTR1->pr = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR1->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR1->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
+	/* Set prescale counter value for a 1uS tick */
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	tbaseclk = (tbaseclk / 1000000) - 1;
+	TIMER_CNTR1->pr = tbaseclk;
+
+	/* Set match for number of usecs */
+	TIMER_CNTR1->mr[0] = usec;
+
+	/* Interrupt on match 0 */
+	TIMER_CNTR1->mcr = TIMER_CNTR_MCR_MTCH(0);
+
+	/* Enable the timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_EN;
+
+	/* Loop until match occurs */
+	while ((TIMER_CNTR1->ir & TIMER_CNTR_MTCH_BIT(0)) == 0);
+
+	/* Stop timer */
+	TIMER_CNTR1->tcr = 0;
+
+	/* Disable timer system clock */
+	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 &=
+		~CLKPWR_TMRPWMCLK_TIMER1_EN;
+}
+
+/*
+ * Miscellaneous platform dependent initialisations
+ */
+int board_init (void)
+{
+	/* Kill data cache */
+	dcache_kill();
+
+	/* arch number of Logic-Board - MACH_TYPE_LPC3XXX */
+	gd->bd->bi_arch_number = MACH_TYPE_UBOOTSYS;
+
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = CONFIG_ENV_ADDR;
+
+	return 0;
+}
+
+int dram_init (void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
+
+	/* 32M, change this for 64M boards */
+	gd->bd->bi_dram[0].size = 0x02000000; /* 32M */
+
+	return 0;
+}
+
diff --git a/board/fdi3250/fdi3250_prv.h b/board/fdi3250/fdi3250_prv.h
new file mode 100644
index 0000000..f2d09c9
--- /dev/null
+++ b/board/fdi3250/fdi3250_prv.h
@@ -0,0 +1,38 @@
+/***********************************************************************
+ * $Id::$
+ *
+ * Project: Embedded Artists LPC3250 OEM Board definitions
+ *
+ * Description:
+ *     This file contains board specific information such as the
+ *     chip select wait states, and other board specific information.
+ *
+ ***********************************************************************
+ * Software that is described herein is for illustrative purposes only
+ * which provides customers with programming information regarding the
+ * products. This software is supplied "AS IS" without any warranties.
+ * NXP Semiconductors assumes no responsibility or liability for the
+ * use of the software, conveys no license or title under any patent,
+ * copyright, or mask work right to the product. NXP Semiconductors
+ * reserves the right to make changes in the software without
+ * notification. NXP Semiconductors also make no representation or
+ * warranty that such application will be suitable for the specified
+ * use without further testing or modification.
+ **********************************************************************/
+
+#ifndef FDI3250_PRV_H
+#define FDI3250_PRV_H
+
+
+// Enable the following define to setup for RMII mode
+#define USE_PHY_RMII
+
+// PHY address (configured via PHY ADRx pins)
+#define PHYDEF_PHYADDR           0x0001
+
+// Maximum ethernet frame size, maximum RX and TX packets
+#define ENET_MAXF_SIZE             1536
+#define ENET_MAX_TX_PACKETS        16
+#define ENET_MAX_RX_PACKETS        16
+
+#endif /* FDI3250_PRV_H */
diff --git a/board/fdi3250/lowlevel_init.S b/board/fdi3250/lowlevel_init.S
new file mode 100644
index 0000000..d38e38c
--- /dev/null
+++ b/board/fdi3250/lowlevel_init.S
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2010 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+
+#include <config.h>
+#include <version.h>
+
+#define IRAM_STK_TEMP 0x0003C000
+.globl arm9dimm3250_sys_init
+.globl dcache_kill
+
+.globl lowlevel_init
+lowlevel_init:
+	/*
+	 * Setup basic stack and save return address
+	 */
+	ldr	sp, =IRAM_STK_TEMP
+	stmia	sp, {lr}
+
+	/*
+	 * Initialize ARM9DIMM3250 board
+	 */
+	bl	arm9dimm3250_sys_init
+
+	ldmia	sp, {r0}
+	mov	pc, r0
+
+dcache_kill:
+	/*
+	 * The data cache may have been enabled when booting from
+	 * S1l, so disable it now to prevent problems.
+	 */
+flush1:
+	mrc	p15, 0, r15, c7, c10, 3
+	bne	flush1
+	mcr	p15, 0, r0, c1, c0, 0
+	bic	r0, r0, #4
+	mrc	p15, 0, r0, c1, c0, 0
+	mov	pc, lr
+
diff --git a/board/fdi3250/lowlevelsys_init.c b/board/fdi3250/lowlevelsys_init.c
new file mode 100644
index 0000000..8ae8fb3
--- /dev/null
+++ b/board/fdi3250/lowlevelsys_init.c
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2010 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <configs/fdi3250.h>
+#include <asm/mach-types.h>
+#include <lpc3250.h>
+#include <net.h>
+#include "fdi3250_prv.h"
+
+/*
+ * Miscellaneous platform dependent initializations
+ */
+void arm9dimm3250_sys_init(void)
+{
+}
+
diff --git a/board/fdi3250/net.c b/board/fdi3250/net.c
new file mode 100644
index 0000000..55215e2
--- /dev/null
+++ b/board/fdi3250/net.c
@@ -0,0 +1,549 @@
+/*
+ * Copyright (C) 2010 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <common.h>
+#include <command.h>
+#include <net.h>
+#include <lpc3250.h>
+#include <configs/fdi3250.h>
+#include "fdi3250_prv.h"
+#include "miiphy.h"
+
+static unsigned long g_dmabase;
+static unsigned long gdma_size;
+static TXRX_DESC_T *pTXDesc;
+static unsigned long *pTXStatus;
+static unsigned long pTXVBuffs [ENET_MAX_TX_PACKETS];
+static TXRX_DESC_T *pRXDesc;
+static RX_STATUS_T *pRXStatus;
+static unsigned long pRXVBuffs [ENET_MAX_RX_PACKETS];
+#ifndef USE_IRAM_FOR_ETH_BUFFERS
+static unsigned long ethbuffs[4096];
+#endif
+
+#define DP83848_PHY_STATUS	0x10
+
+static void msDelay(unsigned long ms)
+{
+	udelay(ms * 1000);
+}
+
+//------------------------------------------------------------------------------
+static int RMII_Write (unsigned long PhyReg, unsigned long Value)
+{
+	unsigned long mst = 250;
+	int sts = 0;
+
+	// Write value at PHY address and register
+	ENETMAC->madr = (PHYDEF_PHYADDR << 8) | PhyReg;
+	ENETMAC->mwtd = Value;
+
+	// Wait for unbusy status
+	while (mst > 0)
+	{
+		if ((ENETMAC->mind & MIND_BUSY) == 0)
+		{
+			mst = 0;
+			sts = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	return sts;
+}
+
+//------------------------------------------------------------------------------
+int RMII_Read(unsigned long PhyReg, unsigned long *data) 
+{
+	unsigned long mst = 250;
+	int sts = 0;
+
+	// Read value at PHY address and register
+	ENETMAC->madr = (PHYDEF_PHYADDR << 8) | PhyReg;
+	ENETMAC->mcmd = MCMD_READ;
+
+	// Wait for unbusy status
+	while (mst > 0)
+	{
+		if ((ENETMAC->mind & MIND_BUSY) == 0)
+		{
+			mst = 0;
+			*data = ENETMAC->mrdd;
+			sts = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	ENETMAC->mcmd = 0;
+
+	return sts;
+}
+
+//------------------------------------------------------------------------------
+int HYPHYReset(void)
+{
+	int goodacc;
+	unsigned long tmp1, mst;
+
+	// Reset the PHY and wait for reset to complete
+	goodacc = RMII_Write(PHY_BMCR, PHY_BMCR_RESET);
+	if (goodacc == 0)
+	{
+		return 0;
+	}
+	mst = 400;
+	goodacc = 0;
+	while (mst > 0)
+	{
+		RMII_Read(PHY_BMCR, &tmp1);
+		if ((tmp1 & PHY_BMCR_RESET) == 0)
+		{
+			mst = 0;
+			goodacc = 1;
+		}
+		else
+		{
+			mst--;
+			msDelay(1);
+		}
+	}
+
+	return goodacc;
+}
+
+static int phy_get_link_status (void)
+{
+        unsigned long status;
+
+        /* Status is read once to clear old link state */
+        RMII_Read(PHY_BMSR,&status);
+
+        /*
+	 * Wait if the link is up, and autonegotiation is in progress
+	 * (ie - we're capable and it's not done)
+	 */
+        status = 0;
+        RMII_Read(PHY_BMSR,&status);
+        if ((status & PHY_BMSR_LS) && (status & PHY_BMSR_AUTN_ABLE)
+            && !(status & PHY_BMSR_AUTN_COMP)) {
+                int i = 0;
+
+                while (!(status & PHY_BMSR_AUTN_COMP)) {
+                        /* Timeout reached */
+                        if (i > 1000) {
+                                printf("Timeout\n");
+                                return 1;
+                        }
+                        i++;
+                        msDelay(1);   /* 1 ms */
+                        RMII_Read(PHY_BMSR,&status);
+                }
+                return 0;
+        } else {
+                if (status & PHY_BMSR_LS)
+                        return 0;
+                else
+                        return 1;
+        }
+        return 1;
+}
+
+//------------------------------------------------------------------------------
+int txrx_setup(void)
+{
+	int idx;
+	unsigned long *pTXStatusL, pbase1, pbase2, pbase3;
+	TXRX_DESC_T *pTXRXDesc;
+	RX_STATUS_T *pRXStatusL;
+
+	// Get physical address and size of DMA buffers
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+	g_dmabase = (unsigned long) IRAM_ETH_BUFF_BASE;
+	gdma_size = IRAM_ETH_BUFF_SIZE;
+#else
+	g_dmabase = (unsigned long) &ethbuffs;
+	gdma_size = sizeof(ethbuffs);
+#endif
+
+	// Setup base pointers
+	pbase1 = g_dmabase;     // Start of descriptors
+	pbase2 = pbase1 + 256;  // Start of statuses
+	pbase3 = pbase1 + 1024; // Start of buffers
+
+	// Setup pointers to TX structures
+	ENETMAC->txdescriptor =  pbase1;
+	ENETMAC->txstatus = pbase2;
+	ENETMAC->txdescriptornumber = (ENET_MAX_TX_PACKETS - 1);
+
+	// Save base address of TX descriptor table and TX status
+	pTXRXDesc = (TXRX_DESC_T *) pbase1;
+	pTXStatusL = (unsigned long *) pbase2;
+	pTXDesc = pTXRXDesc;
+	pTXStatus = pTXStatusL;
+
+	// Build TX descriptors
+	for (idx = 0; idx < ENET_MAX_TX_PACKETS; idx++)
+	{
+		pTXRXDesc->packet = pbase3;
+		pTXRXDesc->control = 0;
+		*pTXStatusL = 0;
+
+		// Save virtual address of buffer
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+		pTXVBuffs [idx] = (unsigned long) pbase3;
+#else
+#pragma error "NOT supported"
+#endif
+
+		// Next descriptor and status
+		pTXRXDesc++;
+		pTXStatusL++;
+		pbase1 += sizeof (TXRX_DESC_T);
+		pbase2 += sizeof (unsigned long);
+		pbase3 += ENET_MAXF_SIZE;
+	}
+
+	// Setup pointers to RX structures
+	ENETMAC->rxdescriptor = pbase1;
+	ENETMAC->rxstatus = pbase2;
+	ENETMAC->rxdescriptornumber = (ENET_MAX_RX_PACKETS - 1);
+
+	// Save base address of RX descriptor table and RX status
+	pRXDesc = pTXRXDesc;
+	pRXStatus = pRXStatusL = (RX_STATUS_T *) pTXStatusL;
+
+	// Build RX descriptors
+	for (idx = 0; idx < ENET_MAX_TX_PACKETS; idx++)
+	{
+		pTXRXDesc->packet = pbase3;
+		pTXRXDesc->control = 0x80000000 | (ENET_MAXF_SIZE - 1);
+		pRXStatusL->statusinfo = 0;
+		pRXStatusL->statushashcrc = 0;
+
+		// Save virtual address of buffer
+#ifdef USE_IRAM_FOR_ETH_BUFFERS
+		pRXVBuffs [idx] = (unsigned long) pbase3;
+#else
+#pragma error "NOT supported"
+#endif
+
+		// Next descriptor and status
+		pTXRXDesc++;
+		pRXStatusL++;
+		pbase1 += sizeof (TXRX_DESC_T);
+		pbase2 += sizeof (unsigned long);
+		pbase3 += ENET_MAXF_SIZE;
+	}
+
+    return 1;
+}
+
+//------------------------------------------------------------------------------
+int HWInit(bd_t * bd)
+{
+	int btemp;
+	unsigned int duplex, speed;
+	unsigned long tmp1, mst = 250;
+
+	// Enable MAC interface
+	CLKPWR->clkpwr_macclk_ctrl = (CLKPWR_MACCTRL_HRCCLK_EN |
+		CLKPWR_MACCTRL_MMIOCLK_EN | CLKPWR_MACCTRL_DMACLK_EN |
+#ifdef USE_PHY_RMII
+		CLKPWR_MACCTRL_USE_RMII_PINS);
+#else
+		CLKPWR_MACCTRL_USE_MII_PINS);
+#endif
+
+	// Set RMII management clock rate. This clock should be slower
+	// than 12.5MHz (for NXP PHYs only). For a divider of 28, the
+	// clock rate when HCLK is 150MHz will be 5.4MHz
+	ENETMAC->mcfg = MCFG_CLOCK_SELECT(MCFG_CLOCK_HOST_DIV_28);
+
+	// Reset all MAC logic
+	ENETMAC->mac1 = (MAC1_SOFT_RESET | MAC1_SIMULATION_RESET |
+		MAC1_RESET_MCS_TX | MAC1_RESET_TX | MAC1_RESET_MCS_RX |
+		MAC1_RESET_RX);
+	ENETMAC->command = (COMMAND_REG_RESET | COMMAND_TXRESET |
+		COMMAND_RXRESET);
+	msDelay(10);
+
+	// Initial MAC initialization
+	ENETMAC->mac1 = MAC1_PASS_ALL_RX_FRAMES;
+	ENETMAC->mac2 = (MAC2_PAD_CRC_ENABLE | MAC2_CRC_ENABLE);
+	ENETMAC->maxf = ENET_MAXF_SIZE;
+
+	// Maximum number of retries, 0x37 collision window, gap */
+	ENETMAC->clrt = (CLRT_LOAD_RETRY_MAX(0xF) |
+		CLRT_LOAD_COLLISION_WINDOW(0x37));
+	ENETMAC->ipgr = IPGR_LOAD_PART2(0x12);
+
+#ifdef USE_PHY_RMII
+	// RMII setup
+	ENETMAC->command = (COMMAND_RMII | COMMAND_PASSRUNTFRAME);
+	ENETMAC->supp = SUPP_RESET_RMII;
+	msDelay(10);
+#else
+	// MII setup
+	ENETMAC->command = COMMAND_PASSRUNTFRAME;
+#endif
+	// Enable rate auto-negotiation for the link
+	if (RMII_Write(PHY_BMCR,
+		(PHY_BMCR_100MB | PHY_BMCR_AUTON)) == 0)
+	{
+		return 0;
+	}
+        
+	mst = 1000;
+        btemp = 1;
+        while(mst > 0)
+        {
+                /* Wait for Link status to set UP or Timeout */
+                if(phy_get_link_status() == 0) {
+                        mst = 0;
+                        btemp = 0;
+                        printf("ENET:auto-negotiation complete#$\n");
+                }
+                else {
+                        mst--;
+                        msDelay(1);
+                }
+        }
+        if(btemp) {
+                printf("ENET:auto-negotiation failed#$\n");
+                return 0;
+        }
+
+        /* Read PHY Status Register to determine Ethernet Configuration */
+        tmp1 = 0;
+        RMII_Read (DP83848_PHY_STATUS,&tmp1);
+        duplex = (tmp1 & 0x0004) >> 2;
+        speed = (tmp1 & 0x0002) >> 1;
+
+	// Configure Full/Half Duplex mode
+	if (duplex == 1)
+	{
+		// 10MBase full duplex is supported
+		ENETMAC->mac2 |= MAC2_FULL_DUPLEX;
+		ENETMAC->command |= COMMAND_FULLDUPLEX;
+		ENETMAC->ipgt = IPGT_LOAD(0x15);
+		printf("ENET:FULL DUPLEX\n");
+	}
+	else
+	{
+		ENETMAC->ipgt = IPGT_LOAD(0x12);
+		printf("ENET:HALF DUPLEX\n");
+	}
+
+	// Configure 100MBit/10MBit mode
+	if (speed == 0)
+	{
+		// 100MBase mode
+		ENETMAC->supp = SUPP_SPEED;
+		printf("ENET:100MBase\n");
+	}
+	else
+	{
+		// 10MBase mode
+		ENETMAC->supp = 0;
+		printf("ENET:10Base\n");
+	}
+
+	// Save station address
+	ENETMAC->sa [2] = (unsigned long) (bd->bi_enetaddr[0] | (bd->bi_enetaddr[1] << 8));
+	ENETMAC->sa [1] = (unsigned long) (bd->bi_enetaddr[2] | (bd->bi_enetaddr[3] << 8));
+	ENETMAC->sa [0] = (unsigned long) (bd->bi_enetaddr[4] | (bd->bi_enetaddr[5] << 8));
+
+	// Setup TX and RX descriptors
+	txrx_setup();
+
+	// Enable broadcast and matching address packets
+	ENETMAC->rxfliterctrl = (RXFLTRW_ACCEPTUBROADCAST |
+		RXFLTRW_ACCEPTPERFECT);
+
+	// Clear and enable interrupts
+	ENETMAC->intclear = 0xFFFF;
+	ENETMAC->intenable = 0;
+
+	// Enable receive and transmit mode of MAC ethernet core
+	ENETMAC->command |= (COMMAND_RXENABLE | COMMAND_TXENABLE);
+	ENETMAC->mac1 |= MAC1_RECV_ENABLE;
+
+	// Perform a 'dummy' send of the first ethernet frame with a size of 0
+	// to 'prime' the MAC. The first packet after a reset seems to wait
+	// until at least 2 packets are ready to go.
+	tmp1 = 0;
+	eth_send(&tmp1, 4);
+
+	return 1;
+}
+
+//------------------------------------------------------------------------------
+int HWDeInit(void)
+{
+	// Reset PHY
+	(void) HYPHYReset();
+
+	// Reset all MAC logic
+	ENETMAC->mac1 = (MAC1_SOFT_RESET | MAC1_SIMULATION_RESET |
+		MAC1_RESET_MCS_TX | MAC1_RESET_TX | MAC1_RESET_MCS_RX |
+		MAC1_RESET_RX);
+	ENETMAC->command = (COMMAND_REG_RESET | COMMAND_TXRESET |
+		COMMAND_RXRESET);
+	msDelay(2);
+
+	// Disable MAC clocks, but keep MAC interface active
+#ifdef USE_PHY_RMII
+	CLKPWR->clkpwr_macclk_ctrl = CLKPWR_MACCTRL_USE_RMII_PINS;
+#else
+	CLKPWR->clkpwr_macclk_ctrl = CLKPWR_MACCTRL_USE_MII_PINS;
+#endif
+
+	return 1;
+}
+
+void eth_halt (void)
+{
+	HWDeInit();
+}
+
+int eth_init (bd_t * bd)
+{
+	int rc;
+
+	char *s, *e;
+	int i;
+
+	s = getenv ("ethaddr");
+	for (i = 0; i < 6; ++i) {
+		bd->bi_enetaddr[i] = s ? simple_strtoul (s, &e, 16) : 0;
+		if (s)
+			s = (*e) ? e + 1 : e;
+	}
+
+
+	printf ("\tHW MAC address:  "
+		"%02X:%02X:%02X:%02X:%02X:%02X\n",
+		bd->bi_enetaddr[0], bd->bi_enetaddr[1],
+		bd->bi_enetaddr[2], bd->bi_enetaddr[3],
+		bd->bi_enetaddr[4], bd->bi_enetaddr[5] );
+
+	rc = HWInit(bd);
+
+	// De-init if an error occurred
+	if (rc == 0)
+	{
+		printf ("ENET init failure\n");
+		HWDeInit();
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Get a data block via Ethernet */
+int eth_rx (void)
+{
+	unsigned long idx, length;
+
+	// Determine if a frame has been received
+	length = 0;
+	idx = ENETMAC->rxconsumeindex;
+	if (ENETMAC->rxproduceindex != idx)
+	{
+		// Clear interrupt
+		ENETMAC->intclear = MACINT_RXDONEINTEN;
+
+		// Frame received, get size of RX packet
+		length = (pRXStatus[idx].statusinfo & 0x7FF);
+
+		/* Pass the packet up to the protocol layer */
+		if (length > 0)
+		{
+		        memcpy((void *) NetRxPackets[0], (void *) pRXVBuffs [idx], length);
+			NetReceive (NetRxPackets[0], (unsigned short) length);
+		}
+
+		// Return DMA buffer
+		idx++;
+		if (idx >= ENET_MAX_TX_PACKETS)
+		{
+			idx = 0;
+		}
+		ENETMAC->rxconsumeindex = (unsigned long) idx;
+	}
+
+	return (int) length;
+}
+
+/* Send a data block via Ethernet. */
+int eth_send (volatile void *packet, int length)
+{
+	unsigned long idx, cidx, fb;
+
+	// Determine number of free buffers and wait for a buffer if needed
+	fb = 0;
+	while (fb == 0)
+	{
+		idx = ENETMAC->txproduceindex;
+		cidx = ENETMAC->txconsumeindex;
+
+		if (idx == cidx)
+		{
+			// Producer and consumer are the same, all buffers are free
+			fb = ENET_MAX_TX_PACKETS;
+		}
+		else if (cidx > idx)
+		{
+			fb = (ENET_MAX_TX_PACKETS - 1) -
+				((idx + ENET_MAX_TX_PACKETS) - cidx);
+		}
+		else
+		{
+			fb = (ENET_MAX_TX_PACKETS - 1) - (cidx - idx);
+		}
+	}
+
+	// Update descriptor with new frame size
+	pTXDesc[idx].control = (length | 0x40000000);
+
+	// Move data to buffer
+	memcpy((void *) pTXVBuffs [idx], (void *)packet, length);
+
+	// Get next index for transmit data DMA buffer and descriptor
+	idx++;
+	if (idx >= ENET_MAX_TX_PACKETS)
+	{
+		idx = 0;
+	}
+	ENETMAC->txproduceindex = idx;
+
+	return 0;
+}
+
diff --git a/board/fdi3250/u-boot.lds b/board/fdi3250/u-boot.lds
new file mode 100644
index 0000000..af17af2
--- /dev/null
+++ b/board/fdi3250/u-boot.lds
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright 2002
+ * Gary Jennejohn, DENX Software Engineering, <gj@denx.de>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
+OUTPUT_ARCH(arm)
+ENTRY(_start)
+SECTIONS
+{
+	. = 0x81FC0000;
+
+	. = ALIGN(4);
+	.text      :
+	{
+	  cpu/arm926ejs/start.o	(.text)
+	  *(.text)
+	}
+
+	. = ALIGN(4);
+	.rodata : { *(.rodata) }
+ 
+	.ARM.extab	: { *(.ARM.extab* .gnu.linkonce.armextab.*) }
+	__exidx_start = .;
+	.ARM.exidx	: { *(.ARM.exidx* .gnu.linkonce.armexidx.*) }
+	__exidx_end = .;
+
+	. = ALIGN(4);
+	.data : { *(.data) }
+
+	. = ALIGN(4);
+	.got : { *(.got) }
+
+	. = .;
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : { *(.u_boot_cmd) }
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	__bss_start = .;
+	.bss (NOLOAD) : { *(.bss) }
+	_end = .;
+}
diff --git a/include/configs/fdi3250.h b/include/configs/fdi3250.h
new file mode 100644
index 0000000..740a125
--- /dev/null
+++ b/include/configs/fdi3250.h
@@ -0,0 +1,284 @@
+/*
+ * Copyright (C) 2010 by NXP Semiconductors
+ * All rights reserved.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * FDI LPC3250 Board configuation data
+ */
+
+#ifndef __FDI3250_H__
+#define __FDI3250_H__
+
+/*
+ *
+ * Chip speific options
+ *
+ */
+
+/*
+ * Ethernet buffer support in uncached IRAM and buffer size
+ */
+#define USE_IRAM_FOR_ETH_BUFFERS
+#define IRAM_ETH_BUFF_BASE 0x08010000 /* Uncached IRAM */
+#define IRAM_ETH_BUFF_SIZE 0x00010000
+
+/*
+ * There are 2 boot options for u-boot on the LPC3250 board. Option 1
+ * or option 2. In either cases, u-boot does not need to be relocated.
+ *
+ * Option 1 - define CFG_BOOT_USES1L
+ * With this option, the S1L loader present in the board initializes the
+ * system (including SDRAM, MMUs, some MUX states, etc.). U-boot is loaded
+ * into an already initialized system in SDRAM at address 0x83FC0000 (the
+ * end of SDRAM in a 64M system). Because most of the system is already
+ * initialized, system init is not performed again.
+ *
+ * Option 2 - undefine CFG_BOOT_USES1L [NOT SUPPORTED]
+ * With this option, u-boot is the primary boot loader that is loaded and
+ * started from the kickstart loader (see documentation with the
+ * LPC3250 board for the kickstart loader). In this configuration, u-boot
+ * loads and runs from RAM at address 0x00000000 and requires complete
+ * system initialization. The kickstart loader will copy the u-boot image
+ * from FLASH starting at block 1 into IRAM and start it at address 0x0.
+ */
+#define CFG_BOOT_USES1L
+
+#ifdef CFG_BOOT_USES1L
+/*
+ * Skip low level init of MMU, SDRAM, muxing, etc. if u-boot is loaded
+ * and executed from S1L
+ */
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#endif
+
+/*
+ * Linux machine type
+ */
+#define MACH_TYPE_FDI3250 (2513)
+#define MACH_TYPE_UBOOTSYS MACH_TYPE_FDI3250
+
+/*
+ * System UART selection, valid selections include UART1 via UART7
+ */
+#define CFG_UART_SEL UART1
+#define USE_HIGH_SPEED_UART /* Only enable for 1, 2, or 7 */
+
+/*
+ * SDRAM physical Memory Map
+ */
+#define CONFIG_NR_DRAM_BANKS    1
+#define PHYS_SDRAM_1		0x80000000 /* SDRAM Bank #1 */
+
+/*
+ * NOR FLASH not supported
+ */
+#define CONFIG_SYS_NO_FLASH
+#undef CONFIG_ENV_IS_IN_FLASH
+
+/*
+ * 1KHz clock tick
+ */
+#define CONFIG_SYS_HZ		1000
+
+/*
+ * ARM926ejs options
+ */
+#define CONFIG_ARM926EJS	   1 /* This is an arm926ejs CPU core  */
+
+/*
+ *
+ * u-boot specific options
+ *
+ */
+
+/*
+ * Address and size of Environment Data
+ */
+#define CONFIG_ENV_IS_IN_NAND	1
+#define CONFIG_ENV_SIZE		0x40000    /* 2 blocks */
+#define CONFIG_ENV_OFFSET	0xFA0000    /* Block 125 */
+#define CONFIG_ENV_ADDR		0x80000100 /* Passed to kernel here */
+
+/*
+ * Area and size for malloc
+ */
+#define CONFIG_SYS_MALLOC_LEN (CONFIG_ENV_SIZE + 128 * 1024)
+#define CONFIG_SYS_GBL_DATA_SIZE 128
+
+/*
+ * Stack sizes
+ *
+ * The stack sizes are set up in start.S using the settings below
+ */
+#define CONFIG_STACKSIZE (32*1024) /* 32K stack */
+
+/*
+ * ATAG support
+ */
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+/*
+ * Default baud rate and baud rate table, console config
+ */
+#define CONFIG_CONS_INDEX	   1
+#define CONFIG_BAUDRATE		115200
+#define CONFIG_SYS_BAUDRATE_TABLE	{ 9600, 19200, 38400, 57600, 115200 }
+
+/*
+ * Default load address for programs
+ */
+#define CONFIG_SYS_LOAD_ADDR	0x80100000 /* default load address */
+
+/*
+ * Default boot delay is 3 seconds
+ */
+#define CONFIG_BOOTDELAY 3
+#define CONFIG_ZERO_BOOTDELAY_CHECK	/* check for keypress on bootdelay==0 */
+
+/*
+ * Interrupts are not supported in this boot loader
+ */
+#undef CONFIG_USE_IRQ
+
+/*
+ * Use verbose help
+ */
+#define CONFIG_SYS_LONGHELP
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_ENV
+#define CONFIG_CMD_ECHO /* ECHO command */
+#define CONFIG_CMD_CACHE /* Cache support */
+#define CONFIG_CMD_RUN
+#define CONFIG_CMD_LOADB
+#define CONFIG_CMD_LOADS
+#define CONFIG_CMD_SAVES
+#define CONFIG_CMD_MEMORY
+#define CONFIG_CMD_PING
+#define CONFIG_CMD_NET
+#define CONFIG_CMD_BDI
+#define CONFIG_CMD_SAVEENV
+#define CONFIG_CMD_ELF
+#define CONFIG_CMD_FAT
+#undef CONFIG_CMD_MISC
+
+/*
+ * Prompt, command buffer
+ */
+#define	CONFIG_SYS_CBSIZE		256		/* Console I/O Buffer Size	*/
+#define	CONFIG_SYS_PROMPT	"uboot> "	/* Monitor Command Prompt	*/
+#define	CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16) /* Print Buffer Size */
+#define	CONFIG_SYS_MAXARGS		16		/* max number of command args	*/
+#define CONFIG_SYS_BARGSIZE		CONFIG_SYS_CBSIZE	/* Boot Argument Buffer Size	*/
+
+/*
+ * Default range for the memory tests
+ */
+#define CONFIG_SYS_MEMTEST_START 0x80010000
+#define CONFIG_SYS_MEMTEST_END 0x81000000
+
+/*
+ * Support for NAND FLASH, environment store in NAND at block 100
+ */
+#define CONFIG_CMD_NAND
+#define CONFIG_SYS_LPC32XX_NAND    /* Enable SLC NAND controller driver */
+#define CONFIG_SYS_MAX_NAND_DEVICE 1
+#define CONFIG_SYS_NAND_BASE 0x20020000 /* SLC NAND controller */
+#define CFG_ENV_IS_IN_NAND
+#define LPC32XX_SLC_NAND_TIMING (SLCTAC_WDR(14) | \
+                    SLCTAC_WWIDTH(5) | \
+                    SLCTAC_WHOLD(2) | \
+                    SLCTAC_WSETUP(1) | \
+                    SLCTAC_RDR(14) | \
+                    SLCTAC_RWIDTH(4) | \
+                    SLCTAC_RHOLD(2) | \
+                    SLCTAC_RSETUP(1))
+
+/*
+ * NAND H/W ECC specific settings
+ */
+#define CONFIG_SYS_LPC32XX_DMA            /* DMA support required */
+#define CONFIG_SYS_NAND_ECCSIZE      2048 /* ECC generated per page */
+#define CONFIG_SYS_NAND_ECCBYTES       32 /* 3 Bytes ECC per 256 Bytes */
+#define CONFIG_SYS_NAND_OOBSIZE        64 /* OOB size in bytes */
+
+/* allow to overwrite serial and ethaddr */
+#define CONFIG_ENV_OVERWRITE
+
+/*
+ * Support for various capabilities
+ */
+#define CONFIG_AUTO_COMPLETE
+#define CONFIG_CMDLINE_EDITING
+#define CONFIG_SYS_LOADS_BAUD_CHANGE
+
+/*
+ * Network setup
+ */
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_IPADDR		192.168.5.234
+#define CONFIG_SERVERIP		192.168.5.88
+#define CONFIG_ETHADDR		00:1a:f1:00:00:00
+
+#define CONFIG_BOOTFILE		"uImage"  /* File to load */
+#define CONFIG_LOADADDR		0x80100000	   
+#define CONFIG_ROOTPATH		/home/user/ltib/rootfs
+#define CONFIG_BOOTARGS		"root=/dev/nfs rw "		\
+	"nfsroot=$(serverip):$(rootpath) "			\
+	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
+	"console=ttyTX0,115200n8;"				\
+	"run loadkernel;"					\
+	"bootm $(loadaddr)"
+
+#define CONFIG_BOOTCOMMAND	"dhcp; bootm"
+
+#define MTDBOOTCOMMAND "mtdboot="				\
+ "setenv bootargs root=/dev/mtdblock4 rw rootfstype=jffs2 "	\
+	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
+	"console=ttyTX0,115200n8; "				\
+	"run loadkernel;"					\
+	"bootm $(loadaddr)\0"
+
+/*
+ * Other preset environment variables and example bootargs string
+ */
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	MTDBOOTCOMMAND
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_HOSTNAME
+#define CONFIG_BOOTP_BOOTFILESIZE
+
+#endif  /* __FDI3250_H__*/
+
-- 
1.7.0.4


From 443bc2e6f70beefaf1e9b0ec048bd99031de4a6b Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Thu, 11 Nov 2010 16:26:36 -0800
Subject: [PATCH 13/28] LPC32x0: Various changes

Removed dcache_kill and flush1 functions from all boards, not needed
Removed odd CFL_BOOT_USES1L define and all related code
Moved Phytec SSP code for MAC lookup from low level to phy3250.c
Some whitespace fixes
Removed use of CONFIG_SKIP_LOWLEVEL_INIT to allow Icache to be setup
Should improve performance
---
 board/ea3250/ea3250.c            |    4 -
 board/ea3250/lowlevel_init.S     |   13 --
 board/ea3250/lowlevelsys_init.c  |    5 -
 board/fdi3250/fdi3250.c          |    4 -
 board/fdi3250/lowlevel_init.S    |   13 --
 board/phy3250/lowlevel_init.S    |   13 --
 board/phy3250/lowlevelsys_init.c |  186 ---------------------
 board/phy3250/phy3250.c          |  337 ++++++++++++++++++++++++++++----------
 include/configs/ea3250.h         |   35 ----
 include/configs/fdi3250.h        |   35 ----
 include/configs/phy3250.h        |   35 ----
 11 files changed, 251 insertions(+), 429 deletions(-)

diff --git a/board/ea3250/ea3250.c b/board/ea3250/ea3250.c
index e2d5069..8c59102 100644
--- a/board/ea3250/ea3250.c
+++ b/board/ea3250/ea3250.c
@@ -32,7 +32,6 @@
 #include "ea3250_prv.h"
 		
 DECLARE_GLOBAL_DATA_PTR;
-extern int dcache_kill(void);
 
 /* ISP1301 USB transceiver I2C registers */
 #define	ISP1301_MODE_CONTROL_1		0x04	/* u8 read, set, +1 clear */
@@ -209,9 +208,6 @@ void udelay(unsigned long usec)
  */
 int board_init (void)
 {
-	/* Kill data cache */
-	dcache_kill();
-
 	/* arch number of Logic-Board - MACH_TYPE_LPC3XXX */
 	gd->bd->bi_arch_number = MACH_TYPE_UBOOTSYS;
 
diff --git a/board/ea3250/lowlevel_init.S b/board/ea3250/lowlevel_init.S
index feed40a..de947f7 100644
--- a/board/ea3250/lowlevel_init.S
+++ b/board/ea3250/lowlevel_init.S
@@ -48,16 +48,3 @@ lowlevel_init:
 	ldmia	sp, {r0}
 	mov	pc, r0
 
-dcache_kill:
-	/*
-	 * The data cache may have been enabled when booting from
-	 * S1l, so disable it now to prevent problems.
-	 */
-flush1:
-	mrc	p15, 0, r15, c7, c10, 3
-	bne	flush1
-	mcr	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #4
-	mrc	p15, 0, r0, c1, c0, 0
-	mov	pc, lr
-
diff --git a/board/ea3250/lowlevelsys_init.c b/board/ea3250/lowlevelsys_init.c
index 11e4e4a..ed63bf9 100644
--- a/board/ea3250/lowlevelsys_init.c
+++ b/board/ea3250/lowlevelsys_init.c
@@ -36,10 +36,5 @@
  */
 void ea3250_sys_init(void)
 {
-
-#ifndef CFG_BOOT_USES1L
-	/* Initialize system including clocking, SDRAM, muxing, MMU, etc. */
-	/* TBD stubbed - NOT SUPPORTED */
-#endif
 }
 
diff --git a/board/fdi3250/fdi3250.c b/board/fdi3250/fdi3250.c
index c4a3b0c..ad99a23 100644
--- a/board/fdi3250/fdi3250.c
+++ b/board/fdi3250/fdi3250.c
@@ -29,7 +29,6 @@
 #include "fdi3250_prv.h"
 		
 DECLARE_GLOBAL_DATA_PTR;
-extern int dcache_kill(void);
 
 /*
  * Dummy function to handle errors for EABI incompatibility
@@ -150,9 +149,6 @@ void udelay(unsigned long usec)
  */
 int board_init (void)
 {
-	/* Kill data cache */
-	dcache_kill();
-
 	/* arch number of Logic-Board - MACH_TYPE_LPC3XXX */
 	gd->bd->bi_arch_number = MACH_TYPE_UBOOTSYS;
 
diff --git a/board/fdi3250/lowlevel_init.S b/board/fdi3250/lowlevel_init.S
index d38e38c..04757aa 100644
--- a/board/fdi3250/lowlevel_init.S
+++ b/board/fdi3250/lowlevel_init.S
@@ -45,16 +45,3 @@ lowlevel_init:
 	ldmia	sp, {r0}
 	mov	pc, r0
 
-dcache_kill:
-	/*
-	 * The data cache may have been enabled when booting from
-	 * S1l, so disable it now to prevent problems.
-	 */
-flush1:
-	mrc	p15, 0, r15, c7, c10, 3
-	bne	flush1
-	mcr	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #4
-	mrc	p15, 0, r0, c1, c0, 0
-	mov	pc, lr
-
diff --git a/board/phy3250/lowlevel_init.S b/board/phy3250/lowlevel_init.S
index a589735..4f8ba26 100644
--- a/board/phy3250/lowlevel_init.S
+++ b/board/phy3250/lowlevel_init.S
@@ -48,16 +48,3 @@ lowlevel_init:
 	ldmia	sp, {r0}
 	mov	pc, r0
 
-dcache_kill:
-	/*
-	 * The data cache may have been enabled when booting from
-	 * S1l, so disable it now to prevent problems.
-	 */
-flush1:
-	mrc	p15, 0, r15, c7, c10, 3
-	bne	flush1
-	mcr	p15, 0, r0, c1, c0, 0
-	bic	r0, r0, #4
-	mrc	p15, 0, r0, c1, c0, 0
-	mov	pc, lr
-
diff --git a/board/phy3250/lowlevelsys_init.c b/board/phy3250/lowlevelsys_init.c
index fd2da9a..0564f6e 100644
--- a/board/phy3250/lowlevelsys_init.c
+++ b/board/phy3250/lowlevelsys_init.c
@@ -29,197 +29,11 @@
 #include <asm/mach-types.h>
 #include <lpc3250.h>
 #include <net.h>
-#include "phy3250_prv.h"
-
-PHY_HW_T phyhwdesc;
-
-static int ssp_read(void *buffer,
-			int max_fifo)
-{
-	volatile unsigned long tmp1;
-	int count = 0;
-	u_char *data8 = (u_char *) buffer;
-
-	while ((max_fifo > 0) && ((SSP0->sr & SSP_SR_RNE) != 0))
-	{
-		tmp1 = SSP0->data;
-		*data8 = (u_char) tmp1;
-		data8++;
-
-		/* Increment data count and decrement buffer size count */
-		count++;
-		max_fifo--;
-	}
-
-	return count;
-}
-
-static int ssp_write(void *buffer,
-                 int n_fifo)
-{
-	int count = 0;
-	u_char *data8 = (u_char *) buffer;
-
-	/* Loop until transmit ring buffer is full or until n_bytes
-	   expires */
-	while ((n_fifo > 0) && ((SSP0->sr & SSP_SR_TNF) != 0))
-	{
-		SSP0->data = (unsigned long) * data8;
-		data8++;
-
-		/* Increment data count and decrement buffer size count */
-		count++;
-		n_fifo--;
-	}
-
-	return count;
-}
-
-static void ssp_set_clock(unsigned long target_clock)
-{
-	unsigned long control, prescale, cr0_div, cmp_clk, ssp_clk;
-
-	/* Get clock for SSP */
-	ssp_clk = sys_get_rate(CLKPWR_HCLK);
-
-	/* Find closest divider to get at or under the target frequency.
-	   Use smallest prescaler possible and rely on the divider to get
-	   the closest target frequency */
-	cr0_div = 0;
-	cmp_clk = 0xFFFFFFFF;
-	prescale = 2;
-	while (cmp_clk > target_clock)
-	{
-		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
-		if (cmp_clk > target_clock)
-		{
-			cr0_div++;
-			if (cr0_div > 0xFF)
-			{
-				cr0_div = 0;
-				prescale += 2;
-			}
-		}
-	}
-
-	/* Write computed prescaler and divider back to register */
-	control = SSP0->cr0 &= ~(SSP_CR0_SCR(0xFF));
-	SSP0->cr0 = control | SSP_CR0_SCR(cr0_div - 1);
-	SSP0->cpsr = prescale;
-}
-
-/*
- * Initialize SSP0 for interface to the serial EEPROM
- */
-static void phy3250_ssp0_init(void)
-{
-	volatile unsigned long tmp;
-
-	/* Enable SSP0 clock */
-	CLKPWR->clkpwr_ssp_blk_ctrl |= CLKPWR_SSPCTRL_SSPCLK0_EN;
-
-	SSP0->cr0 = (SSP_CR0_DSS(8) | SSP_CR0_FRF_SPI);
-	SSP0->cr1 |= SSP_CR1_SSP_ENABLE;
-
-	/* Empty FIFO */
-	while ((SSP0->sr & SSP_SR_RNE) != 0)
-	{
-		tmp = SSP0->data;
-	}
-
-	ssp_set_clock(500000);
-
-	/* Clear latched interrupts */
-	SSP0->icr = (SSP_ICR_RORIC | SSP_ICR_RTIC);
-
-	/* Disable interrupts */
-	SSP0->imsc = 0; // TBD (SSP_IMSC_RORIM | SSP_IMSC_RTIM | SSP_IMSC_RXIM);
-}
-
-static int phy3250_sspxfer(u_char *out,
-                               u_char *in,
-                               int bytes)
-{
-  int rbytes = 0, xfrd = 0;
-
-	/* Assert chip select */
-	GPIO->p3_outp_clr = OUTP_STATE_GPIO(5);
-	ssp_write(out, bytes);
-	while (rbytes < bytes)
-	{
-		rbytes += ssp_read(&in [rbytes], 1);
-	}
-
-	GPIO->p3_outp_set = OUTP_STATE_GPIO(5);
-	xfrd = 1;
-
-	return xfrd;
-}
-
-static u_char phy3250_sspread(int index)
-{
-	u_char datai [8], datao [8];
-	u_char byte = 0;
-
-	/* Read byte */
-	datao [0] = SEEPROM_READ;
-	datao [1] = (u_char)((index >> 8) & 0xFF);
-	datao [2] = (u_char)((index >> 0) & 0xFF);
-	datao [3] = 0xFF;
-	phy3250_sspxfer(datao, datai, 4);
-	byte = datai [3];
-
-	return byte;
-}
-
-void phy3250_get_board_info(void)
-{
-	u_char *p8;
-	int idx;
-
-	/* Initialize SSP0 */
-	phy3250_ssp0_init();
-
-	/* Read data from EEPROM - this needs to be done here as the
-	   SDRAM configuration depends on these settings. */
-	p8 = (u_char *) & phyhwdesc;
-	for (idx = 0; idx < sizeof(phyhwdesc); idx++)
-	{
-		*p8 = phy3250_sspread(PHY3250_SEEPROM_CFGOFS + idx);
-		p8++;
-	}
-
-	if (phyhwdesc.fieldvval != PHY_HW_VER_VAL)
-	{
-		/* Set some defaults */
-		phyhwdesc.dramcfg = (PHYHW_DRAM_TYPE_LPSDRAM | PHYHW_DRAM_SIZE_64M);
-		phyhwdesc.syscfg = PHYHW_SDIO_POP;
-		phyhwdesc.fieldvval = PHY_HW_VER_VAL;
-
-		/* Default MAC address in index order of 0:1:2:3:4:5 */
-		phyhwdesc.mac [0] = 0x00;
-		phyhwdesc.mac [1] = 0x01;
-		phyhwdesc.mac [2] = 0x90;
-		phyhwdesc.mac [3] = 0x00;
-		phyhwdesc.mac [4] = 0xC0;
-		phyhwdesc.mac [5] = 0x81;
-		phyhwdesc.mac [6] = 0x00;
-		phyhwdesc.mac [7] = 0x00;
-
-	}
-}
 
 /*
  * Miscellaneous platform dependent initializations
  */
 void phy3250_sys_init(void)
 {
-	/* Get board information to determine DRAM size and MAC address */
-	phy3250_get_board_info();
-
-#ifndef CFG_BOOT_USES1L
-	/* Initialize system including clocking, SDRAM, muxing, MMU, etc. */
-	/* TBD stubbed */
-#endif
 }
 
diff --git a/board/phy3250/phy3250.c b/board/phy3250/phy3250.c
index 6492b8e..de8cf50 100644
--- a/board/phy3250/phy3250.c
+++ b/board/phy3250/phy3250.c
@@ -32,9 +32,6 @@
 #include "phy3250_prv.h"
 		
 DECLARE_GLOBAL_DATA_PTR;
-extern PHY_HW_T phyhwdesc;
-extern void phy3250_get_board_info(void);
-extern int dcache_kill(void);
 
 /* Initialize NOR Flash configuration */
 #ifdef CONFIG_FLASH_CFI_LEGACY
@@ -70,26 +67,26 @@ void abort(void)
 
 void reset_timer (void)
 {
-	unsigned int clkdlycnt, tbaseclk;
-
-	/* Reset timer */
-	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_RESET;
-	TIMER_CNTR0->tcr = 0;
-	TIMER_CNTR0->tc = 0;
-
-	/* Clear and enable match function */
-	TIMER_CNTR0->ir = TIMER_CNTR_MTCH_BIT(0);
-
-	/* Count mode is PCLK edge */
-	TIMER_CNTR0->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
-
+	unsigned int clkdlycnt, tbaseclk;
+
+	/* Reset timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR0->tcr = 0;
+	TIMER_CNTR0->tc = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR0->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR0->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
 	/* Set prescale counter value for a 1mS tick */
-	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
-	clkdlycnt = (tbaseclk / CONFIG_SYS_HZ);
-	TIMER_CNTR0->pr = clkdlycnt - 1;
-
-	/* Enable the timer */
-	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_EN;
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	clkdlycnt = (tbaseclk / CONFIG_SYS_HZ);
+	TIMER_CNTR0->pr = clkdlycnt - 1;
+
+	/* Enable the timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_EN;
 }
 
 ulong get_timer (ulong base)
@@ -102,7 +99,7 @@ void timer_init(void)
 {
 	/* Enable timer system clock */
 	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
-		CLKPWR_TMRPWMCLK_TIMER0_EN;
+		CLKPWR_TMRPWMCLK_TIMER0_EN;
 
 	reset_timer();
 }
@@ -125,45 +122,45 @@ void reset_cpu(ulong addr)
 
 void udelay(unsigned long usec)
 {
-	unsigned long tbaseclk;
+	unsigned long tbaseclk;
 
 	/* Enable timer system clock */
 	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
-		CLKPWR_TMRPWMCLK_TIMER1_EN;
-
-	/* Reset timer */
-	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_RESET;
-	TIMER_CNTR1->tcr = 0;
-	TIMER_CNTR1->tc = 0;
-	TIMER_CNTR1->pr = 0;
-
-	/* Clear and enable match function */
-	TIMER_CNTR1->ir = TIMER_CNTR_MTCH_BIT(0);
-
-	/* Count mode is PCLK edge */
-	TIMER_CNTR1->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
-
+		CLKPWR_TMRPWMCLK_TIMER1_EN;
+
+	/* Reset timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR1->tcr = 0;
+	TIMER_CNTR1->tc = 0;
+	TIMER_CNTR1->pr = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR1->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR1->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
 	/* Set prescale counter value for a 1uS tick */
-	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
-	tbaseclk = (tbaseclk / 1000000) - 1;
-	TIMER_CNTR1->pr = tbaseclk;
-
-	/* Set match for number of usecs */
-	TIMER_CNTR1->mr[0] = usec;
-
-	/* Interrupt on match 0 */
-	TIMER_CNTR1->mcr = TIMER_CNTR_MCR_MTCH(0);
-
-	/* Enable the timer */
-	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_EN;
-
-	/* Loop until match occurs */
-	while ((TIMER_CNTR1->ir & TIMER_CNTR_MTCH_BIT(0)) == 0);
-
-	/* Stop timer */
-	TIMER_CNTR1->tcr = 0;
-
-	/* Disable timer system clock */
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	tbaseclk = (tbaseclk / 1000000) - 1;
+	TIMER_CNTR1->pr = tbaseclk;
+
+	/* Set match for number of usecs */
+	TIMER_CNTR1->mr[0] = usec;
+
+	/* Interrupt on match 0 */
+	TIMER_CNTR1->mcr = TIMER_CNTR_MCR_MTCH(0);
+
+	/* Enable the timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_EN;
+
+	/* Loop until match occurs */
+	while ((TIMER_CNTR1->ir & TIMER_CNTR_MTCH_BIT(0)) == 0);
+
+	/* Stop timer */
+	TIMER_CNTR1->tcr = 0;
+
+	/* Disable timer system clock */
 	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 &=
 		~CLKPWR_TMRPWMCLK_TIMER1_EN;
 }
@@ -189,18 +186,186 @@ int misc_init_r(void)
 	return 1;
 }
 
+PHY_HW_T phyhwdesc;
+
+static int ssp_read(void *buffer,
+			int max_fifo)
+{
+	volatile unsigned long tmp1;
+	int count = 0;
+	u_char *data8 = (u_char *) buffer;
+
+	while ((max_fifo > 0) && ((SSP0->sr & SSP_SR_RNE) != 0))
+	{
+		tmp1 = SSP0->data;
+		*data8 = (u_char) tmp1;
+		data8++;
+
+		/* Increment data count and decrement buffer size count */
+		count++;
+		max_fifo--;
+	}
+
+	return count;
+}
+
+static int ssp_write(void *buffer,
+                 int n_fifo)
+{
+	int count = 0;
+	u_char *data8 = (u_char *) buffer;
+
+	/* Loop until transmit ring buffer is full or until n_bytes
+	   expires */
+	while ((n_fifo > 0) && ((SSP0->sr & SSP_SR_TNF) != 0))
+	{
+		SSP0->data = (unsigned long) * data8;
+		data8++;
+
+		/* Increment data count and decrement buffer size count */
+		count++;
+		n_fifo--;
+	}
+
+	return count;
+}
+
+static void ssp_set_clock(unsigned long target_clock)
+{
+	unsigned long control, prescale, cr0_div, cmp_clk, ssp_clk;
+
+	/* Get clock for SSP */
+	ssp_clk = sys_get_rate(CLKPWR_HCLK);
+
+	/* Find closest divider to get at or under the target frequency.
+	   Use smallest prescaler possible and rely on the divider to get
+	   the closest target frequency */
+	cr0_div = 0;
+	cmp_clk = 0xFFFFFFFF;
+	prescale = 2;
+	while (cmp_clk > target_clock)
+	{
+		cmp_clk = ssp_clk / ((cr0_div + 1) * prescale);
+		if (cmp_clk > target_clock)
+		{
+			cr0_div++;
+			if (cr0_div > 0xFF)
+			{
+				cr0_div = 0;
+				prescale += 2;
+			}
+		}
+	}
+
+	/* Write computed prescaler and divider back to register */
+	control = SSP0->cr0 &= ~(SSP_CR0_SCR(0xFF));
+	SSP0->cr0 = control | SSP_CR0_SCR(cr0_div - 1);
+	SSP0->cpsr = prescale;
+}
+
+/*
+ * Initialize SSP0 for interface to the serial EEPROM
+ */
+static void phy3250_ssp0_init(void)
+{
+	volatile unsigned long tmp;
+
+	/* Enable SSP0 clock */
+	CLKPWR->clkpwr_ssp_blk_ctrl |= CLKPWR_SSPCTRL_SSPCLK0_EN;
+
+	SSP0->cr0 = (SSP_CR0_DSS(8) | SSP_CR0_FRF_SPI);
+	SSP0->cr1 |= SSP_CR1_SSP_ENABLE;
+
+	/* Empty FIFO */
+	while ((SSP0->sr & SSP_SR_RNE) != 0)
+	{
+		tmp = SSP0->data;
+	}
+
+	ssp_set_clock(500000);
+
+	/* Clear latched interrupts */
+	SSP0->icr = (SSP_ICR_RORIC | SSP_ICR_RTIC);
+
+	/* Disable interrupts */
+	SSP0->imsc = 0; // TBD (SSP_IMSC_RORIM | SSP_IMSC_RTIM | SSP_IMSC_RXIM);
+}
+
+static int phy3250_sspxfer(u_char *out,
+                               u_char *in,
+                               int bytes)
+{
+  int rbytes = 0, xfrd = 0;
+
+	/* Assert chip select */
+	GPIO->p3_outp_clr = OUTP_STATE_GPIO(5);
+	ssp_write(out, bytes);
+	while (rbytes < bytes)
+	{
+		rbytes += ssp_read(&in [rbytes], 1);
+	}
+
+	GPIO->p3_outp_set = OUTP_STATE_GPIO(5);
+	xfrd = 1;
+
+	return xfrd;
+}
+
+static u_char phy3250_sspread(int index)
+{	
+	u_char datai [8], datao [8];
+	u_char byte = 0;
+
+	/* Read byte */
+	datao [0] = SEEPROM_READ;
+	datao [1] = (u_char)((index >> 8) & 0xFF);
+	datao [2] = (u_char)((index >> 0) & 0xFF);
+	datao [3] = 0xFF;
+	phy3250_sspxfer(datao, datai, 4);
+	byte = datai [3];
+
+	return byte;
+}
+
+void phy3250_get_board_info(void)
+{
+	u_char *p8;
+	int idx;
+
+	/* Initialize SSP0 */
+	phy3250_ssp0_init();
+
+	/* Read data from EEPROM - this needs to be done here as the
+	   SDRAM configuration depends on these settings. */
+	p8 = (u_char *) & phyhwdesc;
+	for (idx = 0; idx < sizeof(phyhwdesc); idx++)
+	{
+		*p8 = phy3250_sspread(PHY3250_SEEPROM_CFGOFS + idx);
+		p8++;
+	}
+
+	if (phyhwdesc.fieldvval != PHY_HW_VER_VAL)
+	{
+		/* Set some defaults */
+		phyhwdesc.dramcfg = (PHYHW_DRAM_TYPE_LPSDRAM | PHYHW_DRAM_SIZE_64M);
+		phyhwdesc.syscfg = PHYHW_SDIO_POP;
+		phyhwdesc.fieldvval = PHY_HW_VER_VAL;
+
+		/* Default MAC address in index order of 0:1:2:3:4:5 */
+		phyhwdesc.mac [0] = 0x00;
+		phyhwdesc.mac [1] = 0x01;
+		phyhwdesc.mac [2] = 0x90;
+		phyhwdesc.mac [3] = 0x00;
+		phyhwdesc.mac [4] = 0xC0;
+		phyhwdesc.mac [5] = 0x81;
+		phyhwdesc.mac [6] = 0x00;
+		phyhwdesc.mac [7] = 0x00;
+	}
+}
+
 int board_init (void)
 {	
-	/* Kill data cache */
-	dcache_kill();
-
-#ifdef CONFIG_SKIP_LOWLEVEL_INIT
-	/* Normally, the phy3250_get_board_info() function is called as part of the
-	   low level system initialization. For systems that don't do low level system
-	   init (S1L based), call this function here to get the board configuration
-	   structure */
 	phy3250_get_board_info();
-#endif
 
 	/* arch number of Logic-Board - MACH_TYPE_LPC3XXX */
 	gd->bd->bi_arch_number = MACH_TYPE_UBOOTSYS;
@@ -212,25 +377,25 @@ int board_init (void)
 	/* Enable clocks to the SLC NAND controller */
 	CLKPWR->clkpwr_nand_clk_ctrl = 0x05;
 
-        /* Reset SLC NAND controller & clear ECC */
-        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
-
-        /* 8-bit bus, no DMA, CE normal */
-        SLCNAND->slc_cfg = 0;
-
-        /* Interrupts disabled and cleared */
-        SLCNAND->slc_ien = 0;
-        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
-
-	// TBD fix me with optimal timings later
-        /* Start with slowest timings possible */
-        SLCNAND->slc_tac = (SLCTAC_WDR(15) |
-                    SLCTAC_WWIDTH(15) |
-                    SLCTAC_WHOLD(15) |
-                    SLCTAC_WSETUP(15) |
-                    SLCTAC_RDR(15) |
-                    SLCTAC_RWIDTH(15) |
-                    SLCTAC_RHOLD(15) |
+        /* Reset SLC NAND controller & clear ECC */
+        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
+
+        /* 8-bit bus, no DMA, CE normal */
+        SLCNAND->slc_cfg = 0;
+
+        /* Interrupts disabled and cleared */
+        SLCNAND->slc_ien = 0;
+        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
+
+	// TBD fix me with optimal timings later
+        /* Start with slowest timings possible */
+        SLCNAND->slc_tac = (SLCTAC_WDR(15) |
+                    SLCTAC_WWIDTH(15) |
+                    SLCTAC_WHOLD(15) |
+                    SLCTAC_WSETUP(15) |
+                    SLCTAC_RDR(15) |
+                    SLCTAC_RWIDTH(15) |
+                    SLCTAC_RHOLD(15) |
                     SLCTAC_RSETUP(15));
 #endif
 
diff --git a/include/configs/ea3250.h b/include/configs/ea3250.h
index c8dec8f..10cbae1 100644
--- a/include/configs/ea3250.h
+++ b/include/configs/ea3250.h
@@ -32,12 +32,6 @@
 #define __EA3250_H__
 
 /*
- *
- * Chip speific options
- *
- */
-
-/*
  * Ethernet buffer support in uncached IRAM and buffer size
  */
 #define USE_IRAM_FOR_ETH_BUFFERS
@@ -45,35 +39,6 @@
 #define IRAM_ETH_BUFF_SIZE 0x00010000
 
 /*
- * There are 2 boot options for u-boot on the LPC3250 board. Option 1
- * or option 2. In either cases, u-boot does not need to be relocated.
- *
- * Option 1 - define CFG_BOOT_USES1L
- * With this option, the S1L loader present in the board initializes the
- * system (including SDRAM, MMUs, some MUX states, etc.). U-boot is loaded
- * into an already initialized system in SDRAM at address 0x83FC0000 (the
- * end of SDRAM in a 64M system). Because most of the system is already
- * initialized, system init is not performed again.
- *
- * Option 2 - undefine CFG_BOOT_USES1L [NOT SUPPORTED]
- * With this option, u-boot is the primary boot loader that is loaded and
- * started from the kickstart loader (see documentation with the
- * LPC3250 board for the kickstart loader). In this configuration, u-boot
- * loads and runs from RAM at address 0x00000000 and requires complete
- * system initialization. The kickstart loader will copy the u-boot image
- * from FLASH starting at block 1 into IRAM and start it at address 0x0.
- */
-#define CFG_BOOT_USES1L
-
-#ifdef CFG_BOOT_USES1L
-/*
- * Skip low level init of MMU, SDRAM, muxing, etc. if u-boot is loaded
- * and executed from S1L
- */
-#define CONFIG_SKIP_LOWLEVEL_INIT
-#endif
-
-/*
  * Linux machine type
  */
 #define MACH_TYPE_EA3250 (2512)
diff --git a/include/configs/fdi3250.h b/include/configs/fdi3250.h
index 740a125..ec873da 100644
--- a/include/configs/fdi3250.h
+++ b/include/configs/fdi3250.h
@@ -29,12 +29,6 @@
 #define __FDI3250_H__
 
 /*
- *
- * Chip speific options
- *
- */
-
-/*
  * Ethernet buffer support in uncached IRAM and buffer size
  */
 #define USE_IRAM_FOR_ETH_BUFFERS
@@ -42,35 +36,6 @@
 #define IRAM_ETH_BUFF_SIZE 0x00010000
 
 /*
- * There are 2 boot options for u-boot on the LPC3250 board. Option 1
- * or option 2. In either cases, u-boot does not need to be relocated.
- *
- * Option 1 - define CFG_BOOT_USES1L
- * With this option, the S1L loader present in the board initializes the
- * system (including SDRAM, MMUs, some MUX states, etc.). U-boot is loaded
- * into an already initialized system in SDRAM at address 0x83FC0000 (the
- * end of SDRAM in a 64M system). Because most of the system is already
- * initialized, system init is not performed again.
- *
- * Option 2 - undefine CFG_BOOT_USES1L [NOT SUPPORTED]
- * With this option, u-boot is the primary boot loader that is loaded and
- * started from the kickstart loader (see documentation with the
- * LPC3250 board for the kickstart loader). In this configuration, u-boot
- * loads and runs from RAM at address 0x00000000 and requires complete
- * system initialization. The kickstart loader will copy the u-boot image
- * from FLASH starting at block 1 into IRAM and start it at address 0x0.
- */
-#define CFG_BOOT_USES1L
-
-#ifdef CFG_BOOT_USES1L
-/*
- * Skip low level init of MMU, SDRAM, muxing, etc. if u-boot is loaded
- * and executed from S1L
- */
-#define CONFIG_SKIP_LOWLEVEL_INIT
-#endif
-
-/*
  * Linux machine type
  */
 #define MACH_TYPE_FDI3250 (2513)
diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
index 5a7e215..f797d94 100644
--- a/include/configs/phy3250.h
+++ b/include/configs/phy3250.h
@@ -32,12 +32,6 @@
 #define __PHY3250_H__
 
 /*
- *
- * Chip speific options
- *
- */
-
-/*
  * Ethernet buffer support in uncached IRAM and buffer size
  */
 #define USE_IRAM_FOR_ETH_BUFFERS
@@ -45,35 +39,6 @@
 #define IRAM_ETH_BUFF_SIZE 0x00010000
 
 /*
- * There are 2 boot options for u-boot on the Phytec 3250 board. Option 1
- * or option 2. In either cases, u-boot does not need to be relocated.
- *
- * Option 1 - define CFG_BOOT_USES1L
- * With this option, the S1L loader present in the board initializes the
- * system (including SDRAM, MMUs, some MUX states, etc.). U-boot is loaded
- * into an already initialized system in SDRAM at address 0x83FC0000 (the
- * end of SDRAM in a 64M system). Because most of the system is already
- * initialized, system init is not performed again.
- *
- * Option 2 - undefine CFG_BOOT_USES1L
- * With this option, u-boot is the primary boot loader that is loaded and
- * started from the Phytec kickstart loader (see documentation with the
- * Phytec board for the kickstart loader). In this configuration, u-boot
- * loads and runs from RAM at address 0x00000000 and requires complete
- * system initialization. The kickstart loader will copy the u-boot image
- * from FLASH starting at block 1 into IRAM and start it at address 0x0.
- */
-#define CFG_BOOT_USES1L
-
-#ifdef CFG_BOOT_USES1L
-/*
- * Skip low level init of MMU, SDRAM, muxing, etc. if u-boot is loaded
- * and executed from S1L
- */
-#define CONFIG_SKIP_LOWLEVEL_INIT
-#endif
-
-/*
  * Linux machine type
  */
 #define MACH_TYPE_PHY3250 (2511)
-- 
1.7.0.4


From 624281f36bc67cce30022dc19c213d103250eaec Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Thu, 11 Nov 2010 17:07:44 -0800
Subject: [PATCH 14/28] LPC32x0: Removed extra code for Phytec board and optimized NAND timing

---
 board/phy3250/phy3250.c   |   26 --------------------------
 include/configs/phy3250.h |    8 ++++----
 2 files changed, 4 insertions(+), 30 deletions(-)

diff --git a/board/phy3250/phy3250.c b/board/phy3250/phy3250.c
index de8cf50..2697b57 100644
--- a/board/phy3250/phy3250.c
+++ b/board/phy3250/phy3250.c
@@ -373,32 +373,6 @@ int board_init (void)
 	/* adress of boot parameters */
 	gd->bd->bi_boot_params = CONFIG_ENV_ADDR;
 
-#ifdef CONFIG_CMD_NAND
-	/* Enable clocks to the SLC NAND controller */
-	CLKPWR->clkpwr_nand_clk_ctrl = 0x05;
-
-        /* Reset SLC NAND controller & clear ECC */
-        SLCNAND->slc_ctrl = (SLCCTRL_SW_RESET | SLCCTRL_ECC_CLEAR);
-
-        /* 8-bit bus, no DMA, CE normal */
-        SLCNAND->slc_cfg = 0;
-
-        /* Interrupts disabled and cleared */
-        SLCNAND->slc_ien = 0;
-        SLCNAND->slc_icr = (SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN);
-
-	// TBD fix me with optimal timings later
-        /* Start with slowest timings possible */
-        SLCNAND->slc_tac = (SLCTAC_WDR(15) |
-                    SLCTAC_WWIDTH(15) |
-                    SLCTAC_WHOLD(15) |
-                    SLCTAC_WSETUP(15) |
-                    SLCTAC_RDR(15) |
-                    SLCTAC_RWIDTH(15) |
-                    SLCTAC_RHOLD(15) |
-                    SLCTAC_RSETUP(15));
-#endif
-
 #ifdef CONFIG_SYS_FLASH_CFI
 	/* Use 32-bit memory interface for NOR Flash */
 	EMC->emcstatic_regs[0].emcstaticconfig = 0x82;
diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
index f797d94..b7a9aed 100644
--- a/include/configs/phy3250.h
+++ b/include/configs/phy3250.h
@@ -196,12 +196,12 @@
 #define CONFIG_SYS_MAX_NAND_DEVICE 1
 #define CONFIG_SYS_NAND_BASE 0x20020000 /* SLC NAND controller */
 #define CFG_ENV_IS_IN_NAND
-#define LPC32XX_SLC_NAND_TIMING (SLCTAC_WDR(3) | \
-                    SLCTAC_WWIDTH(10) | \
+#define LPC32XX_SLC_NAND_TIMING (SLCTAC_WDR(14) | \
+                    SLCTAC_WWIDTH(9) | \
                     SLCTAC_WHOLD(3) | \
                     SLCTAC_WSETUP(4) | \
-                    SLCTAC_RDR(3) | \
-                    SLCTAC_RWIDTH(10) | \
+                    SLCTAC_RDR(14) | \
+                    SLCTAC_RWIDTH(9) | \
                     SLCTAC_RHOLD(3) | \
                     SLCTAC_RSETUP(4))
 
-- 
1.7.0.4


From 4722d300d1d508eb2950fdb846f386fbd9d956e9 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Tue, 21 Dec 2010 09:17:28 -0800
Subject: [PATCH 15/28] ARM: LPC32XX: Update execution area for PHY and FDI images

The image size for the Phytec and FDI executables exceeded the
end of memory. Lower the execution address to allow more room in
memory.
---
 board/fdi3250/config.mk  |    2 +-
 board/fdi3250/u-boot.lds |    2 +-
 board/phy3250/config.mk  |    2 +-
 board/phy3250/u-boot.lds |    2 +-
 4 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/board/fdi3250/config.mk b/board/fdi3250/config.mk
index 8facfe3..0879b3f 100644
--- a/board/fdi3250/config.mk
+++ b/board/fdi3250/config.mk
@@ -33,5 +33,5 @@
 # download area is 0x80f00000
 #
 
-TEXT_BASE = 0x81FC0000
+TEXT_BASE = 0x81F80000
 
diff --git a/board/fdi3250/u-boot.lds b/board/fdi3250/u-boot.lds
index af17af2..55d3d87 100644
--- a/board/fdi3250/u-boot.lds
+++ b/board/fdi3250/u-boot.lds
@@ -26,7 +26,7 @@ OUTPUT_ARCH(arm)
 ENTRY(_start)
 SECTIONS
 {
-	. = 0x81FC0000;
+	. = 0x81F80000;
 
 	. = ALIGN(4);
 	.text      :
diff --git a/board/phy3250/config.mk b/board/phy3250/config.mk
index 35f345b..f194fdc 100644
--- a/board/phy3250/config.mk
+++ b/board/phy3250/config.mk
@@ -33,5 +33,5 @@
 # download area is 0x80f00000
 #
 
-TEXT_BASE = 0x83FC0000
+TEXT_BASE = 0x83F80000
 
diff --git a/board/phy3250/u-boot.lds b/board/phy3250/u-boot.lds
index 497036d..f771989 100644
--- a/board/phy3250/u-boot.lds
+++ b/board/phy3250/u-boot.lds
@@ -26,7 +26,7 @@ OUTPUT_ARCH(arm)
 ENTRY(_start)
 SECTIONS
 {
-	. = 0x83FC0000;
+	. = 0x83F80000;
 
 	. = ALIGN(4);
 	.text      :
-- 
1.7.0.4


From 598a607d8dd19854fb2f7dd968bb479f596a2dd6 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Tue, 21 Dec 2010 09:19:09 -0800
Subject: [PATCH 16/28] ARM: LPC32XX: Move reset function from board to CPU area

The CPU reset function is common for all boards. This moves 3 identical
functions from the board files to a single CPU file. The EA board file
also got a whitespace cleanup.
---
 board/ea3250/ea3250.c   |  126 ++++++++++++++++++++--------------------------
 board/fdi3250/fdi3250.c |   16 ------
 board/phy3250/phy3250.c |   16 ------
 3 files changed, 55 insertions(+), 103 deletions(-)

diff --git a/board/ea3250/ea3250.c b/board/ea3250/ea3250.c
index 8c59102..99ef996 100644
--- a/board/ea3250/ea3250.c
+++ b/board/ea3250/ea3250.c
@@ -105,26 +105,26 @@ void abort(void)
 
 void reset_timer (void)
 {
-	unsigned int clkdlycnt, tbaseclk;
-
-	/* Reset timer */
-	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_RESET;
-	TIMER_CNTR0->tcr = 0;
-	TIMER_CNTR0->tc = 0;
-
-	/* Clear and enable match function */
-	TIMER_CNTR0->ir = TIMER_CNTR_MTCH_BIT(0);
-
-	/* Count mode is PCLK edge */
-	TIMER_CNTR0->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
-
+	unsigned int clkdlycnt, tbaseclk;
+
+	/* Reset timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR0->tcr = 0;
+	TIMER_CNTR0->tc = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR0->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR0->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
 	/* Set prescale counter value for a 1mS tick */
-	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
-	clkdlycnt = (tbaseclk / CONFIG_SYS_HZ);
-	TIMER_CNTR0->pr = clkdlycnt - 1;
-
-	/* Enable the timer */
-	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_EN;
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	clkdlycnt = (tbaseclk / CONFIG_SYS_HZ);
+	TIMER_CNTR0->pr = clkdlycnt - 1;
+
+	/* Enable the timer */
+	TIMER_CNTR0->tcr = TIMER_CNTR_TCR_EN;
 }
 
 ulong get_timer (ulong base)
@@ -137,68 +137,52 @@ void timer_init(void)
 {
 	/* Enable timer system clock */
 	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
-		CLKPWR_TMRPWMCLK_TIMER0_EN;
+		CLKPWR_TMRPWMCLK_TIMER0_EN;
 
 	reset_timer();
 }
 
-/*
- * Use the watchdog timer to reset the system
- */
-void reset_cpu(ulong addr)
-{
-	/* Enable the WDT clock */
-	CLKPWR->clkpwr_timer_clk_ctrl |= CLKPWR_PWMCLK_WDOG_EN;
-
-	/* Force RESETOUT_N active */
-	WDT->wdtim_mctrl = WDT_RESFRC1;
-	WDT->wdtim_ctrl = WDT_COUNT_ENAB;
-
-	/* Wait forever */
-	while (1);
-}
-
 void udelay(unsigned long usec)
 {
-	unsigned long tbaseclk;
+	unsigned long tbaseclk;
 
 	/* Enable timer system clock */
 	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 |=
-		CLKPWR_TMRPWMCLK_TIMER1_EN;
-
-	/* Reset timer */
-	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_RESET;
-	TIMER_CNTR1->tcr = 0;
-	TIMER_CNTR1->tc = 0;
-	TIMER_CNTR1->pr = 0;
-
-	/* Clear and enable match function */
-	TIMER_CNTR1->ir = TIMER_CNTR_MTCH_BIT(0);
-
-	/* Count mode is PCLK edge */
-	TIMER_CNTR1->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
-
+		CLKPWR_TMRPWMCLK_TIMER1_EN;
+
+	/* Reset timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_RESET;
+	TIMER_CNTR1->tcr = 0;
+	TIMER_CNTR1->tc = 0;
+	TIMER_CNTR1->pr = 0;
+
+	/* Clear and enable match function */
+	TIMER_CNTR1->ir = TIMER_CNTR_MTCH_BIT(0);
+
+	/* Count mode is PCLK edge */
+	TIMER_CNTR1->ctcr = TIMER_CNTR_SET_MODE(TIMER_CNTR_CTCR_TIMER_MODE);
+
 	/* Set prescale counter value for a 1uS tick */
-	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
-	tbaseclk = (tbaseclk / 1000000) - 1;
-	TIMER_CNTR1->pr = tbaseclk;
-
-	/* Set match for number of usecs */
-	TIMER_CNTR1->mr[0] = usec;
-
-	/* Interrupt on match 0 */
-	TIMER_CNTR1->mcr = TIMER_CNTR_MCR_MTCH(0);
-
-	/* Enable the timer */
-	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_EN;
-
-	/* Loop until match occurs */
-	while ((TIMER_CNTR1->ir & TIMER_CNTR_MTCH_BIT(0)) == 0);
-
-	/* Stop timer */
-	TIMER_CNTR1->tcr = 0;
-
-	/* Disable timer system clock */
+	tbaseclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	tbaseclk = (tbaseclk / 1000000) - 1;
+	TIMER_CNTR1->pr = tbaseclk;
+
+	/* Set match for number of usecs */
+	TIMER_CNTR1->mr[0] = usec;
+
+	/* Interrupt on match 0 */
+	TIMER_CNTR1->mcr = TIMER_CNTR_MCR_MTCH(0);
+
+	/* Enable the timer */
+	TIMER_CNTR1->tcr = TIMER_CNTR_TCR_EN;
+
+	/* Loop until match occurs */
+	while ((TIMER_CNTR1->ir & TIMER_CNTR_MTCH_BIT(0)) == 0);
+
+	/* Stop timer */
+	TIMER_CNTR1->tcr = 0;
+
+	/* Disable timer system clock */
 	CLKPWR->clkpwr_timers_pwms_clk_ctrl_1 &=
 		~CLKPWR_TMRPWMCLK_TIMER1_EN;
 }
diff --git a/board/fdi3250/fdi3250.c b/board/fdi3250/fdi3250.c
index ad99a23..7f5ee10 100644
--- a/board/fdi3250/fdi3250.c
+++ b/board/fdi3250/fdi3250.c
@@ -83,22 +83,6 @@ void timer_init(void)
 	reset_timer();
 }
 
-/*
- * Use the watchdog timer to reset the system
- */
-void reset_cpu(ulong addr)
-{
-	/* Enable the WDT clock */
-	CLKPWR->clkpwr_timer_clk_ctrl |= CLKPWR_PWMCLK_WDOG_EN;
-
-	/* Force RESETOUT_N active */
-	WDT->wdtim_mctrl = WDT_RESFRC1;
-	WDT->wdtim_ctrl = WDT_COUNT_ENAB;
-
-	/* Wait forever */
-	while (1);
-}
-
 void udelay(unsigned long usec)
 {
 	unsigned long tbaseclk;
diff --git a/board/phy3250/phy3250.c b/board/phy3250/phy3250.c
index 2697b57..621e079 100644
--- a/board/phy3250/phy3250.c
+++ b/board/phy3250/phy3250.c
@@ -104,22 +104,6 @@ void timer_init(void)
 	reset_timer();
 }
 
-/*
- * Use the watchdog timer to reset the system
- */
-void reset_cpu(ulong addr)
-{
-	/* Enable the WDT clock */
-	CLKPWR->clkpwr_timer_clk_ctrl |= CLKPWR_PWMCLK_WDOG_EN;
-
-	/* Force RESETOUT_N active */
-	WDT->wdtim_mctrl = WDT_RESFRC1;
-	WDT->wdtim_ctrl = WDT_COUNT_ENAB;
-
-	/* Wait forever */
-	while (1);
-}
-
 void udelay(unsigned long usec)
 {
 	unsigned long tbaseclk;
-- 
1.7.0.4


From 85bdb426f8e904a8baed43e326c013648c8da726 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Tue, 21 Dec 2010 09:20:35 -0800
Subject: [PATCH 17/28] ARM:LPC32XX: Add reset function to CPU file, cleanup cache functions

The CPU reset function has been mvoed here from the board files and
the cache and CP15 functions removed as they were already available
in teh ARM926EJS CPU file.
---
 cpu/arm926ejs/lpc3250/cpu.c |   84 ++++++------------------------------------
 1 files changed, 12 insertions(+), 72 deletions(-)

diff --git a/cpu/arm926ejs/lpc3250/cpu.c b/cpu/arm926ejs/lpc3250/cpu.c
index 1372ada..87b871e 100644
--- a/cpu/arm926ejs/lpc3250/cpu.c
+++ b/cpu/arm926ejs/lpc3250/cpu.c
@@ -32,80 +32,20 @@
 #include <common.h>
 #include <command.h>
 #include <arm926ejs.h>
+#include <lpc3250.h>
 
-/* read co-processor 15, register #1 (control register) */
-static unsigned long read_p15_c1 (void)
-{
-	unsigned long value;
-
-	__asm__ __volatile__(
-		"mrc     p15, 0, %0, c1, c0, 0   @ read control reg\n"
-		: "=r" (value)
-		:
-		: "memory");
-
-#ifdef MMU_DEBUG
-	printf ("p15/c1 is = %08lx\n", value);
-#endif
-	return value;
-}
-
-/* write to co-processor 15, register #1 (control register) */
-static void write_p15_c1 (unsigned long value)
-{
-#ifdef MMU_DEBUG
-	printf ("write %08lx to p15/c1\n", value);
-#endif
-	__asm__ __volatile__(
-		"mcr     p15, 0, %0, c1, c0, 0   @ write it back\n"
-		:
-		: "r" (value)
-		: "memory");
-
-	read_p15_c1 ();
-}
-
-static void cp_delay (void)
-{
-	volatile int i;
-
-	/* copro seems to need some delay between reading and writing */
-	for (i = 0; i < 100; i++);
-}
-
-/* See also ARM Ref. Man. */
-#define C1_MMU		(1<<0)		/* mmu off/on */
-#define C1_ALIGN	(1<<1)		/* alignment faults off/on */
-#define C1_DC		(1<<2)		/* dcache off/on */
-#define C1_BIG_ENDIAN	(1<<7)	/* big endian off/on */
-#define C1_SYS_PROT	(1<<8)		/* system protection */
-#define C1_ROM_PROT	(1<<9)		/* ROM protection */
-#define C1_IC		(1<<12)		/* icache off/on */
-#define C1_HIGH_VECTORS	(1<<13)	/* location of vectors: low/high addresses */
-#define RESERVED_1	(0xf << 3)	/* must be 111b for R/W */
-
-/* It makes no sense to use the dcache if the MMU is not enabled */
-void dcache_enable (void)
-{
-	ulong reg;
-
-	reg = read_p15_c1 ();
-	cp_delay ();
-	write_p15_c1 (reg | C1_DC);
-}
-
-void dcache_disable (void)
+/*
+ * Use the watchdog timer to reset the system
+ */
+void reset_cpu(ulong addr)
 {
-	ulong reg;
+	/* Enable the WDT clock */
+	CLKPWR->clkpwr_timer_clk_ctrl |= CLKPWR_PWMCLK_WDOG_EN;
 
-	reg = read_p15_c1 ();
-	cp_delay ();
-	reg &= ~C1_DC;
-	write_p15_c1 (reg);
-}
+	/* Force RESETOUT_N active */
+	WDT->wdtim_pulse = 13000;
+	WDT->wdtim_mctrl = 0x70;
 
-int dcache_status (void)
-{
-	return (read_p15_c1 () & C1_DC) != 0;
+	/* Wait forever */
+	while (1);
 }
-
-- 
1.7.0.4


From f62e3502fb003de39e349de45035543ff9b14a38 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Tue, 21 Dec 2010 09:21:28 -0800
Subject: [PATCH 18/28] ARM:LPC32XX: Update u-boot board configs

Various board related updates, new helper macros used for board
setup
---
 include/configs/ea3250.h  |  112 +++++++++++++++++++++++++++++++++++----------
 include/configs/fdi3250.h |  106 ++++++++++++++++++++++++++++++++++--------
 include/configs/phy3250.h |  100 +++++++++++++++++++++++++++++++++++++---
 3 files changed, 265 insertions(+), 53 deletions(-)

diff --git a/include/configs/ea3250.h b/include/configs/ea3250.h
index 10cbae1..a5ffab9 100644
--- a/include/configs/ea3250.h
+++ b/include/configs/ea3250.h
@@ -83,7 +83,7 @@
  */
 #define CONFIG_ENV_IS_IN_NAND	1
 #define CONFIG_ENV_SIZE		0x40000    /* 2 blocks */
-#define CONFIG_ENV_OFFSET	0xFA0000    /* Block 125 */
+#define CONFIG_ENV_OFFSET	0x100000   /* Blocks 8/9  */
 #define CONFIG_ENV_ADDR		0x80000100 /* Passed to kernel here */
 
 /*
@@ -204,11 +204,10 @@
                     SLCTAC_RHOLD(2) | \
                     SLCTAC_RSETUP(1))
 
-
 /*
  * NAND H/W ECC specific settings
  */
-#define CONFIG_SYS_LPC32XX_DMA            /* DMA supporte required */
+#define CONFIG_SYS_LPC32XX_DMA            /* DMA support required */
 #define CONFIG_SYS_NAND_ECCSIZE      2048 /* ECC generated per page */
 #define CONFIG_SYS_NAND_ECCBYTES       32 /* 3 Bytes ECC per 256 Bytes */
 #define CONFIG_SYS_NAND_OOBSIZE        64 /* OOB size in bytes */
@@ -227,35 +226,98 @@
  * Network setup
  */
 #define CONFIG_NETMASK		255.255.255.0
-#define CONFIG_IPADDR		192.168.5.234
-#define CONFIG_SERVERIP		192.168.5.88
+#define CONFIG_IPADDR		192.168.1.101
+#define CONFIG_SERVERIP		192.168.1.41
 #define CONFIG_ETHADDR		00:1a:f1:00:00:00
+#define CONFIG_GATEWAYIP	192.168.1.1
 
-#define CONFIG_BOOTFILE		"uImage"  /* File to load */
-#define CONFIG_LOADADDR		0x80100000	   
+#define CONFIG_BOOTFILE		uImage
+#define CONFIG_LOADADDR		0x80100000
 #define CONFIG_ROOTPATH		/home/user/ltib/rootfs
-#define CONFIG_BOOTARGS		"root=/dev/nfs rw "		\
-	"nfsroot=$(serverip):$(rootpath) "			\
-	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
-	"console=ttyS0,115200n8;"				\
-	"run loadkernel;"					\
-	"bootm $(loadaddr)"
-
-#define CONFIG_BOOTCOMMAND	"dhcp; bootm"
-
-#define MTDBOOTCOMMAND "mtdboot="				\
- "setenv bootargs root=/dev/mtdblock3 rw rootfstype=jffs2 "	\
-	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
-	"console=ttyS0,115200n8; "				\
-	"run loadkernel;"					\
-	"bootm $(loadaddr)\0"
+
+/* Boot arguments for JFFS2 root file system in NAND */
+#define MTDROOTCOMMAND "mtdboot="				\
+	"setenv bootargs "					\
+	"console=ttyS0,115200n8 "				\
+	"root=/dev/mtdblock3 rw rootfstype=jffs2 "		\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Boot arguments for NFS based root file system */
+#define NFSROOTCOMMAND "nfsboot="				\
+	"setenv bootargs "					\
+	"console=ttyS0,115200n8 "				\
+	"root=/dev/nfs3 rw nfsroot=${serverip}:${rootpath} "	\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Boot arguments for ramdisk image loaded via TFTP */
+#define RDROOTCOMMAND "ramdiskboot="				\
+	"setenv bootargs "					\
+	"console=ttyS0,115200n8 "				\
+	"root=/dev/ram0 rw "					\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Kernel boot using tftp with static IP */
+#define TFTPSTATICIPKERNELBOOT "tftpstatickernel="		\
+	"tftpboot ${loadaddr} ${serverip}:${bootfile}\0"
+
+/* Kernel boot using tftp with DHCP obtained IP Address */
+#define TFTPDHCPKERNELBOOT "tftpdhcpkernel=dhcp\0"
+
+/*Kernel boot from NAND */
+#define MTDKERNELBOOT "mtdkernel=nboot.jffs2 ${loadaddr} "	\
+	"0 0x00140000\0"
+
+/* Command to burn kernel image into NAND FLASH */
+#define MTDKERNELBURN "mtdkernelburn="				\
+	"nand erase 0x00140000 0x00400000;"			\
+	"nand write.jffs2 ${loadaddr} 0x00140000 0x00400000\0"
+
+/* Root filesystem image name and load address */
+#define ROOTFSNAME "rootfile=rootfs.jffs2\0"
+#define ROOTFSLOADADDR "rootloadaddr=0x82000000\0"
+#define ROOTFSLOADSIZE "rootloadsize=0x01000000\0"
+
+/* Load JFFS2 root file system using TFTP with static IP */
+#define TFTPSTATICROOTFSLOAD "tftpstaticloadroot="		\
+	"tftpboot ${rootloadaddr} ${serverip}:${rootfile}\0"
+
+/* Load JFFS2 root file system using TFTP with DHCP */
+#define TFTPDHCPROOTFSLOAD "tftpdhcploadroot="			\
+	"dhcp ${rootloadaddr} ${serverip}:${rootfile}\0"
+
+/* Command to load root file system into RAM (ramdisk) */
+#define RDROOTFSLOAD "ramdiskload="				\
+	"nand read.jffs2 ${rootloadaddr} 0x00540000 "		\
+	"${rootloadsize}\0"
+
+/* Command to burn root file system image into NAND FLASH */
+#define MTDROOTBURN "mtdrootburn="				\
+	"nand erase 0x00540000 0x07AC0000;"			\
+	"nand write.jffs2 ${rootloadaddr} 0x00540000"		\
+	" ${rootloadsize}\0"
 
 /*
  * Other preset environment variables and example bootargs string
  */
-
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	MTDBOOTCOMMAND 
+#define CONFIG_EXTRA_ENV_SETTINGS				\
+	MTDROOTCOMMAND						\
+	NFSROOTCOMMAND						\
+	RDROOTCOMMAND						\
+	TFTPSTATICIPKERNELBOOT					\
+	TFTPDHCPKERNELBOOT					\
+	MTDKERNELBOOT						\
+	MTDKERNELBURN						\
+	ROOTFSNAME						\
+	ROOTFSLOADADDR						\
+	ROOTFSLOADSIZE						\
+	TFTPSTATICROOTFSLOAD					\
+	TFTPDHCPROOTFSLOAD					\
+	RDROOTFSLOAD						\
+	MTDROOTBURN
+
+/* Default boot command */
+#define CONFIG_BOOTCOMMAND					\
+	"run nfsboot;run tftpstatickernel; bootm ${loadaddr}"
 
 /*
  * BOOTP options
diff --git a/include/configs/fdi3250.h b/include/configs/fdi3250.h
index ec873da..7982a4d 100644
--- a/include/configs/fdi3250.h
+++ b/include/configs/fdi3250.h
@@ -80,7 +80,7 @@
  */
 #define CONFIG_ENV_IS_IN_NAND	1
 #define CONFIG_ENV_SIZE		0x40000    /* 2 blocks */
-#define CONFIG_ENV_OFFSET	0xFA0000    /* Block 125 */
+#define CONFIG_ENV_OFFSET	0x100000   /* Blocks 8/9 */
 #define CONFIG_ENV_ADDR		0x80000100 /* Passed to kernel here */
 
 /*
@@ -207,34 +207,98 @@
  * Network setup
  */
 #define CONFIG_NETMASK		255.255.255.0
-#define CONFIG_IPADDR		192.168.5.234
-#define CONFIG_SERVERIP		192.168.5.88
+#define CONFIG_IPADDR		192.168.1.101
+#define CONFIG_SERVERIP		192.168.1.41
 #define CONFIG_ETHADDR		00:1a:f1:00:00:00
+#define CONFIG_GATEWAYIP	192.168.1.1
 
-#define CONFIG_BOOTFILE		"uImage"  /* File to load */
-#define CONFIG_LOADADDR		0x80100000	   
+#define CONFIG_BOOTFILE		uImage
+#define CONFIG_LOADADDR		0x80100000
 #define CONFIG_ROOTPATH		/home/user/ltib/rootfs
-#define CONFIG_BOOTARGS		"root=/dev/nfs rw "		\
-	"nfsroot=$(serverip):$(rootpath) "			\
-	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
-	"console=ttyTX0,115200n8;"				\
-	"run loadkernel;"					\
-	"bootm $(loadaddr)"
 
-#define CONFIG_BOOTCOMMAND	"dhcp; bootm"
-
-#define MTDBOOTCOMMAND "mtdboot="				\
- "setenv bootargs root=/dev/mtdblock4 rw rootfstype=jffs2 "	\
-	"ip=$(ipaddr) ethaddr=$(ethaddr) "			\
-	"console=ttyTX0,115200n8; "				\
-	"run loadkernel;"					\
-	"bootm $(loadaddr)\0"
+/* Boot arguments for JFFS2 root file system in NAND */
+#define MTDROOTCOMMAND "mtdboot="				\
+	"setenv bootargs "					\
+	"console=ttyTX0,115200n8 "				\
+	"root=/dev/mtdblock3 rw rootfstype=jffs2 "		\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Boot arguments for NFS based root file system */
+#define NFSROOTCOMMAND "nfsboot="				\
+	"setenv bootargs "					\
+	"console=ttyTX0,115200n8 "				\
+	"root=/dev/nfs3 rw nfsroot=${serverip}:${rootpath} "	\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Boot arguments for ramdisk image loaded via TFTP */
+#define RDROOTCOMMAND "ramdiskboot="				\
+	"setenv bootargs "					\
+	"console=ttyTX0,115200n8 "				\
+	"root=/dev/ram0 rw "					\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Kernel boot using tftp with static IP */
+#define TFTPSTATICIPKERNELBOOT "tftpstatickernel="		\
+	"tftpboot ${loadaddr} ${serverip}:${bootfile}\0"
+
+/* Kernel boot using tftp with DHCP obtained IP Address */
+#define TFTPDHCPKERNELBOOT "tftpdhcpkernel=dhcp\0"
+
+/*Kernel boot from NAND */
+#define MTDKERNELBOOT "mtdkernel=nboot.jffs2 ${loadaddr} "	\
+	"0 0x00140000\0"
+
+/* Command to burn kernel image into NAND FLASH */
+#define MTDKERNELBURN "mtdkernelburn="				\
+	"nand erase 0x00140000 0x00400000;"			\
+	"nand write.jffs2 ${loadaddr} 0x00140000 0x00400000\0"
+
+/* Root filesystem image name and load address */
+#define ROOTFSNAME "rootfile=rootfs.jffs2\0"
+#define ROOTFSLOADADDR "rootloadaddr=0x81000000\0"
+#define ROOTFSLOADSIZE "rootloadsize=0x01000000\0"
+
+/* Load JFFS2 root file system using TFTP with static IP */
+#define TFTPSTATICROOTFSLOAD "tftpstaticloadroot="		\
+	"tftpboot ${rootloadaddr} ${serverip}:${rootfile}\0"
+
+/* Load JFFS2 root file system using TFTP with DHCP */
+#define TFTPDHCPROOTFSLOAD "tftpdhcploadroot="			\
+	"dhcp ${rootloadaddr} ${serverip}:${rootfile}\0"
+
+/* Command to load root file system into RAM (ramdisk) */
+#define RDROOTFSLOAD "ramdiskload="				\
+	"nand read.jffs2 ${rootloadaddr} 0x00540000 "		\
+	"${rootloadsize}\0"
+
+/* Command to burn root file system image into NAND FLASH */
+#define MTDROOTBURN "mtdrootburn="				\
+	"nand erase 0x00540000 0x0FAC0000;"			\
+	"nand write.jffs2 ${rootloadaddr} 0x00540000"		\
+	" ${rootloadsize}\0"
 
 /*
  * Other preset environment variables and example bootargs string
  */
-#define CONFIG_EXTRA_ENV_SETTINGS \
-	MTDBOOTCOMMAND
+#define CONFIG_EXTRA_ENV_SETTINGS				\
+	MTDROOTCOMMAND						\
+	NFSROOTCOMMAND						\
+	RDROOTCOMMAND						\
+	TFTPSTATICIPKERNELBOOT					\
+	TFTPDHCPKERNELBOOT					\
+	MTDKERNELBOOT						\
+	MTDKERNELBURN						\
+	ROOTFSNAME						\
+	ROOTFSLOADADDR						\
+	ROOTFSLOADSIZE						\
+	TFTPSTATICROOTFSLOAD					\
+	TFTPDHCPROOTFSLOAD					\
+	RDROOTFSLOAD						\
+	MTDROOTBURN
+
+/* Default boot command */
+#define CONFIG_BOOTCOMMAND					\
+	"run nfsboot;run tftpstatickernel; bootm ${loadaddr}"
 
 /*
  * BOOTP options
diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
index b7a9aed..fee0a03 100644
--- a/include/configs/phy3250.h
+++ b/include/configs/phy3250.h
@@ -226,13 +226,99 @@
 /*
  * Network setup
  */
-#define CONFIG_NETMASK		   255.255.255.0
-#define CONFIG_IPADDR		   192.168.1.193
-#define CONFIG_SERVERIP		   192.168.1.45
-#define CONFIG_GATEWAYIP	   192.168.1.1
-#define CONFIG_NETMASK		   255.255.255.0
-#define CONFIG_BOOTFILE		   "uImage"  /* File to load */
-#define CONFIG_BOOTARGS		   "console=ttyS0,115200n8 root=/dev/nfs rw nfsroot=192.168.1.51:/home/user/ltib/rootfs ethaddr=${ethaddr} ip=192.168.1.193"
+#define CONFIG_NETMASK		255.255.255.0
+#define CONFIG_IPADDR		192.168.1.101
+#define CONFIG_SERVERIP		192.168.1.41
+#define CONFIG_GATEWAYIP	192.168.1.1
+
+#define CONFIG_BOOTFILE		uImage
+#define CONFIG_LOADADDR		0x80100000
+#define CONFIG_ROOTPATH		/home/user/ltib/rootfs
+
+/* Boot arguments for JFFS2 root file system in NAND */
+#define MTDROOTCOMMAND "mtdboot="				\
+	"setenv bootargs "					\
+	"console=ttyS0,115200n8 "				\
+	"root=/dev/mtdblock4 rw rootfstype=jffs2 "		\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Boot arguments for NFS based root file system */
+#define NFSROOTCOMMAND "nfsboot="				\
+	"setenv bootargs "					\
+	"console=ttyS0,115200n8 "				\
+	"root=/dev/nfs3 rw nfsroot=${serverip}:${rootpath} "	\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Boot arguments for ramdisk image loaded via TFTP */
+#define RDROOTCOMMAND "ramdiskboot="				\
+	"setenv bootargs "					\
+	"console=ttyS0,115200n8 "				\
+	"root=/dev/ram0 rw "					\
+	"ip=${ipaddr} ethaddr=${ethaddr}\0"
+
+/* Kernel boot using tftp with static IP */
+#define TFTPSTATICIPKERNELBOOT "tftpstatickernel="		\
+	"tftpboot ${loadaddr} ${serverip}:${bootfile}\0"
+
+/* Kernel boot using tftp with DHCP obtained IP Address */
+#define TFTPDHCPKERNELBOOT "tftpdhcpkernel=dhcp\0"
+
+/*Kernel boot from NAND */
+#define MTDKERNELBOOT "mtdkernel=nboot.jffs2 ${loadaddr} "	\
+	"0 0x00604000\0"
+
+/* Command to burn kernel image into NAND FLASH */
+#define MTDKERNELBURN "mtdkernelburn="				\
+	"nand erase 0x00604000 0x00400000;"			\
+	"nand write.jffs2 ${loadaddr} 0x00604000 0x00400000\0"
+
+/* Root filesystem image name and load address */
+#define ROOTFSNAME "rootfile=rootfs.jffs2\0"
+#define ROOTFSLOADADDR "rootloadaddr=0x82000000\0"
+#define ROOTFSLOADSIZE "rootloadsize=0x01000000\0"
+
+/* Load JFFS2 root file system using TFTP with static IP */
+#define TFTPSTATICROOTFSLOAD "tftpstaticloadroot="		\
+	"tftpboot ${rootloadaddr} ${serverip}:${rootfile}\0"
+
+/* Load JFFS2 root file system using TFTP with DHCP */
+#define TFTPDHCPROOTFSLOAD "tftpdhcploadroot="			\
+	"dhcp ${rootloadaddr} ${serverip}:${rootfile}\0"
+
+/* Command to load root file system into RAM (ramdisk) */
+#define RDROOTFSLOAD "ramdiskload="				\
+	"nand read.jffs2 ${rootloadaddr} 0x00604000 "		\
+	"${rootloadsize}\0"
+
+/* Command to burn root file system image into NAND FLASH */
+#define MTDROOTBURN "mtdrootburn="				\
+	"nand erase 0x00604000 0x039FC000;"			\
+	"nand write.jffs2 ${rootloadaddr} 0x00604000"		\
+	" ${rootloadsize}\0"
+
+/*
+ * Other preset environment variables and example bootargs string
+ */
+#define CONFIG_EXTRA_ENV_SETTINGS				\
+	MTDROOTCOMMAND						\
+	NFSROOTCOMMAND						\
+	RDROOTCOMMAND						\
+	TFTPSTATICIPKERNELBOOT					\
+	TFTPDHCPKERNELBOOT					\
+	MTDKERNELBOOT						\
+	MTDKERNELBURN						\
+	ROOTFSNAME						\
+	ROOTFSLOADADDR						\
+	ROOTFSLOADSIZE						\
+	TFTPSTATICROOTFSLOAD					\
+	TFTPDHCPROOTFSLOAD					\
+	RDROOTFSLOAD						\
+	MTDROOTBURN
+
+/* Default boot command */
+#define CONFIG_BOOTCOMMAND					\
+	"run nfsboot;run tftpstatickernel; bootm ${loadaddr}"
+
 /*
  * BOOTP options
  */
-- 
1.7.0.4


From ecbcc06a60f20c37c434694208841d784260422d Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Wed, 22 Dec 2010 11:49:32 -0800
Subject: [PATCH 19/28] ARM:LPC32XX: NAND ECC inversion changes

Invert NAND ECC for the LPC32XX driver and use 1 less byte per ECC
---
 drivers/mtd/nand/lpc32xx_nand.c |  286 +++++++++++++--------------------------
 include/configs/ea3250.h        |    2 +-
 include/configs/fdi3250.h       |    2 +-
 include/configs/phy3250.h       |    2 +-
 4 files changed, 95 insertions(+), 197 deletions(-)

diff --git a/drivers/mtd/nand/lpc32xx_nand.c b/drivers/mtd/nand/lpc32xx_nand.c
index 88f195e..e6821eb 100644
--- a/drivers/mtd/nand/lpc32xx_nand.c
+++ b/drivers/mtd/nand/lpc32xx_nand.c
@@ -1,10 +1,10 @@
 /*
  * Copyright (C) 2008 by NXP Semiconductors
  * All rights reserved.
- * 
+ *
  * @Author: Kevin Wells
  * @Descr: LPC3250 SLC NAND controller interface support functions
- * 
+ *
  * See file CREDITS for list of people who contributed to this
  * project.
  *
@@ -12,12 +12,12 @@
  * modify it under the terms of the GNU General Public License as
  * published by the Free Software Foundation; either version 2 of
  * the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
@@ -37,44 +37,32 @@
 #define NAND_SMALL_BLOCK_PAGE_SIZE	512
 
 static struct nand_ecclayout lpc32xx_nand_oob_16 = {
-        .eccbytes = 8,
-        .eccpos = {8, 9, 10, 11, 12, 13, 14, 15},
+        .eccbytes = 6,
+        .eccpos = {10, 11, 12, 13, 14, 15},
         .oobfree = {
                 {.offset = 0,
-                 . length = 5},
+                 . length = 4},
                 {.offset = 6,
-                 . length = 2}}
-};
-
-static struct nand_ecclayout lpc32xx_nand_oob_64 = {
-        .eccbytes = 32,
-        .eccpos = { 8, 9, 10, 11, 12, 13, 14, 15,
-		   24, 25, 26, 27, 28, 29, 30, 31,
-		   40, 41, 42, 43, 44, 45, 46, 47,
-		   56, 57, 58, 59, 60, 61, 62, 63},
-        .oobfree = {
-                {.offset = 2,
-                 . length = 6},
-                {.offset = 16,
-                 . length = 8},
-                {.offset = 32,
-                 . length = 8},
-                {.offset = 48,
-                 . length = 8}}
+                 . length = 4}
+		}
 };
 
+extern int nand_correct_data(struct mtd_info *mtd, u_char *dat,
+                             u_char *read_ecc, u_char *calc_ecc);
 /*
  * DMA Descriptors
  * For Large Block: 17 descriptors = ((16 Data and ECC Read) + 1 Spare Area)
  * For Small Block: 5 descriptors = ((4 Data and ECC Read) + 1 Spare Area)
  */
 static dmac_ll_t dmalist[(CONFIG_SYS_NAND_ECCSIZE/256) * 2 + 1];
+static uint32_t ecc_buffer[8]; /* MAX ECC size */
 static int dmachan = -1;
+#define XFER_PENDING ((SLCNAND->slc_stat & SLCSTAT_DMA_FIFO) | SLCNAND->slc_tc)
 
 static void lpc32xx_nand_init(void)
 {
 	/* Enable clocks to the SLC NAND controller */
-	CLKPWR->clkpwr_nand_clk_ctrl = (CLKPWR_NANDCLK_SEL_SLC | 
+	CLKPWR->clkpwr_nand_clk_ctrl = (CLKPWR_NANDCLK_SEL_SLC |
 					CLKPWR_NANDCLK_SLCCLK_EN);
 
         /* Reset SLC NAND controller & clear ECC */
@@ -137,45 +125,6 @@ static u_char lpc32xx_read_byte(struct mtd_info *mtd)
 }
 
 /*
- * lpc32xx_write_buf - [DEFAULT] write buffer to chip
- * mtd:	MTD device structure
- * buf:	data buffer
- * len:	number of bytes to write
- *
- * Default write function for 8bit buswith
- */
-static void lpc32xx_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
-{
-	int i;
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_W;
-
-	for (i=0; i<len; i++)
-		*pReg = (unsigned long) buf[i];
-}
-
-/*
- * lpc32xx_read_buf - [DEFAULT] read chip data into buffer
- * mtd:	MTD device structure
- * buf:	buffer to store date
- * len:	number of bytes to read
- *
- * Default read function for 8bit buswith
- */
-static void lpc32xx_read_buf(struct mtd_info *mtd, u_char *buf, int len)
-{
-	int i;
-	struct nand_chip *this = mtd->priv;
-	unsigned long *pReg = (unsigned long *) this->IO_ADDR_R;
-	volatile unsigned long tmp32;
-
-	for (i=0; i<len; i++) {
-		tmp32 = *pReg;
-		buf[i] = (u_char) tmp32;
-	}
-}
-
-/*
  * lpc32xx_verify_buf - [DEFAULT] Verify chip data against buffer
  * mtd:	MTD device structure
  * buf:	buffer containing the data to compare
@@ -198,32 +147,17 @@ static int lpc32xx_verify_buf(struct mtd_info *mtd, const u_char *buf, int len)
 	return 0;
 }
 
-static uint8_t nand_slc_bit_cnt16(uint16_t ch)
-{
-	ch = (ch & 0x5555) + ((ch & ~0x5555) >> 1);
-	ch = (ch & 0x3333) + ((ch & ~0x3333) >> 2);
-	ch = (ch & 0x0F0F) + ((ch & ~0x0F0F) >> 4);
-	return (ch + (ch >> 8)) & 0xFF;
-}
-
-static uint8_t bit_cnt32(uint32_t val)
-{
-	return nand_slc_bit_cnt16(val & 0xFFFF) +
-		nand_slc_bit_cnt16(val >> 16);
-}
-
 /* Prepares DMA descriptors for NAND RD/WR operations */
+/* If the size is < 256 Bytes then it is assumed to be
+ * an OOB transfer */
 static void lpc32xx_nand_dma_configure(struct nand_chip *chip,
 		const void * buffer, int size, int read)
 {
 	uint32_t i, dmasrc, ctrl, ecc_ctrl, oob_ctrl, dmadst;
-	uint32_t page_divider = (size == NAND_LARGE_BLOCK_PAGE_SIZE) ? 8: 2;
 	void __iomem * base = chip->IO_ADDR_R;
-	uint8_t *oob_buf = chip->oob_poi;
-	uint32_t *eccpos = chip->ecc.layout->eccpos;
-	uint8_t *ecc_gen = chip->buffers->ecccalc;
+	uint32_t *ecc_gen = ecc_buffer;
 
-	/* 
+	/*
 	 * CTRL descriptor entry for reading ECC
 	 * Copy Multiple times to sync DMA with Flash Controller
 	 */
@@ -235,7 +169,7 @@ static void lpc32xx_nand_dma_configure(struct nand_chip *chip,
 			DMAC_CHAN_DEST_AHB1);
 
 	/* CTRL descriptor entry for reading/writing Data */
-	ctrl =  ((CONFIG_SYS_NAND_ECCSIZE / page_divider) / 4) |
+	ctrl =  64 | /* 256/4 */
 			DMAC_CHAN_SRC_BURST_4 |
 			DMAC_CHAN_DEST_BURST_4 |
 			DMAC_CHAN_SRC_WIDTH_32 |
@@ -284,7 +218,7 @@ static void lpc32xx_nand_dma_configure(struct nand_chip *chip,
 	 * Read Operation Sequence for Large Block NAND
 	 * ----------------------------------------------------------
 	 * 1. Steps(1-4) of Read Operations repeate for four times
-	 * which generates 16 DMA descriptors to X'fer 2048 bytes of 
+	 * which generates 16 DMA descriptors to X'fer 2048 bytes of
 	 * data & 32 bytes of ECC data.
 	 * 2. X'fer 64 bytes of Spare area from Flash to Memory.
 	 */
@@ -292,24 +226,30 @@ static void lpc32xx_nand_dma_configure(struct nand_chip *chip,
 	for (i = 0; i < size/256; i++) {
 		dmalist[i*2].dma_src = (read ?(dmasrc) :(dmasrc + (i*256)));
 		dmalist[i*2].dma_dest = (read ?(dmadst + (i*256)) :dmadst);
-                dmalist[i*2].next_lli = (uint32_t) & dmalist[(i*2)+1];
+		dmalist[i*2].next_lli = (uint32_t) & dmalist[(i*2)+1];
 		dmalist[i*2].next_ctrl = ctrl;
 
-                dmalist[(i*2) + 1].dma_src = (uint32_t)
-				(base + offsetof(SLCNAND_REGS_T, slc_ecc));
-                dmalist[(i*2) + 1].dma_dest = (read ?((uint32_t) & ecc_gen[i*4]):
-				((uint32_t) & oob_buf[eccpos[i*4]]));
-                dmalist[(i*2) + 1].next_lli = (uint32_t) & dmalist[(i*2)+2];
+		dmalist[(i*2) + 1].dma_src = (uint32_t)
+		        (base + offsetof(SLCNAND_REGS_T, slc_ecc));
+		dmalist[(i*2) + 1].dma_dest =  (uint32_t) & ecc_gen[i];
+		dmalist[(i*2) + 1].next_lli = (uint32_t) & dmalist[(i*2)+2];
 		dmalist[(i*2) + 1].next_ctrl = ecc_ctrl;
 	}
 
+	if (i) { /* Data only transfer */
+		dmalist[(i*2) - 1].next_lli = 0;
+		dmalist[(i*2) - 1].next_ctrl |= DMAC_CHAN_INT_TC_EN;
+		return ;
+	}
+
+	/* OOB only transfer */
 	if (read) {
 		dmasrc = (uint32_t) (base + offsetof(SLCNAND_REGS_T, slc_dma_data));
-		dmadst = (uint32_t) (oob_buf);
+		dmadst = (uint32_t) (buffer);
 		oob_ctrl |= DMAC_CHAN_DEST_AUTOINC;
 	} else {
 		dmadst = (uint32_t) (base + offsetof(SLCNAND_REGS_T, slc_dma_data));
-		dmasrc = (uint32_t) (oob_buf);
+		dmasrc = (uint32_t) (buffer);
 		oob_ctrl |= DMAC_CHAN_SRC_AUTOINC;
 	}
 
@@ -320,7 +260,7 @@ static void lpc32xx_nand_dma_configure(struct nand_chip *chip,
 	dmalist[i*2].next_ctrl = (oob_ctrl | DMAC_CHAN_INT_TC_EN);
 }
 
-static void lpc32xx_dma_xfer(struct mtd_info *mtd, u_char *buf, int len, int read)
+static void lpc32xx_nand_xfer(struct mtd_info *mtd, const u_char *buf, int len, int read)
 {
 	struct nand_chip *chip = mtd->priv;
 	uint32_t config;
@@ -334,15 +274,30 @@ static void lpc32xx_dma_xfer(struct mtd_info *mtd, u_char *buf, int len, int rea
 	/* Prepare DMA descriptors */
 	lpc32xx_nand_dma_configure(chip, buf, len, read);
 
+	/* Setup SLC controller and start transfer */
+	if (read)
+		SLCNAND->slc_cfg |= SLCCFG_DMA_DIR;
+	else  /* NAND_ECC_WRITE */
+		SLCNAND->slc_cfg &= ~SLCCFG_DMA_DIR;
+	SLCNAND->slc_cfg |= SLCCFG_DMA_BURST;
+
+	/* Write length for new transfers */
+	if (!XFER_PENDING)
+		SLCNAND->slc_tc = len +
+			(len != mtd->oobsize ? mtd->oobsize : 0);
+
+	SLCNAND->slc_ctrl |= SLCCTRL_DMA_START;
+
 	/* Start DMA transfers */
 	lpc32xx_dma_start_xfer(dmachan, dmalist, config);
-	SLCNAND->slc_ctrl |= SLCCTRL_DMA_START;
 
 	/* Wait for NAND to be ready */
 	while(!lpc32xx_nand_ready(mtd));
 
 	/* Wait till DMA transfer is DONE */
-	lpc32xx_dma_wait_status(dmachan);
+	if (lpc32xx_dma_wait_status(dmachan)) {
+		printk(KERN_ERR "NAND DMA transfer error!\r\n");
+	}
 
 	/* Stop DMA & HW ECC */
 	SLCNAND->slc_ctrl &= ~SLCCTRL_DMA_START;
@@ -350,47 +305,25 @@ static void lpc32xx_dma_xfer(struct mtd_info *mtd, u_char *buf, int len, int rea
 				SLCCFG_ECC_EN | SLCCFG_DMA_ECC);
 }
 
-static int lpc32xx_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
-					     uint8_t *ecc_code)
+static uint32_t slc_ecc_copy_to_buffer(uint8_t * spare,
+		const uint32_t * ecc, int count)
 {
+	int i;
+	for (i = 0; i < (count * 3); i += 3) {
+		uint32_t ce = ecc[i/3];
+		ce = ~(ce << 2) & 0xFFFFFF;
+		spare[i+2] = (uint8_t)(ce & 0xFF); ce >>= 8;
+		spare[i+1] = (uint8_t)(ce & 0xFF); ce >>= 8;
+		spare[i]   = (uint8_t)(ce & 0xFF);
+	}
 	return 0;
 }
 
-static int lpc32xx_nand_correct_data(struct mtd_info *mtd, u_char *dat,
-		u_char *read_ecc, u_char *calc_ecc)
+static int lpc32xx_ecc_calculate(struct mtd_info *mtd, const uint8_t *dat,
+					     uint8_t *ecc_code)
 {
-	int ret = 0;
-	uint32_t tmp, err;
-	uint32_t *ecc_stored = (uint32_t*)read_ecc;
-	uint32_t *ecc_gen = (uint32_t*)calc_ecc;
-
-		
-	err = *ecc_stored ^ *ecc_gen;
-	/* Only perform ECC processing if an error is detected */
-	if (err) {
-		/* ECC Failure in i-th block */
-		tmp = bit_cnt32(err);
-		if (tmp == 11) {
-			uint32_t byte = err >> 6;
-			uint32_t bit = 0;
-			bit = ((err & _BIT(1)) >> 1)|((err & _BIT(3)) >> 2)|
-				((err & _BIT(5)) >> 3);
-
-			/* Calculate Byte offset */
-			byte = ((byte & _BIT(1)) >> 1)|((byte & _BIT(3)) >> 2)|
-				((byte & _BIT(5)) >> 3)|((byte & _BIT(7)) >> 4)|
-				((byte & _BIT(9)) >> 5)|((byte & _BIT(11)) >> 6)|
-				((byte & _BIT(13)) >> 7)|((byte & _BIT(15)) >> 8);
-
-			/* Do the correction */
-			dat[byte] ^= _BIT(bit);
-			ret = 1;
-		}else {
-			/* Non-corrrectable */
-			ret = -1;
-		}
-	}
-	return ret;
+	return slc_ecc_copy_to_buffer(ecc_code, ecc_buffer,
+			CONFIG_SYS_NAND_ECCSIZE == NAND_LARGE_BLOCK_PAGE_SIZE ? 8 : 2);
 }
 
 /*
@@ -399,67 +332,37 @@ static int lpc32xx_nand_correct_data(struct mtd_info *mtd, u_char *dat,
  */
 static void lpc32xx_hwecc_enable(struct mtd_info *mtd, int mode)
 {
-	struct nand_chip *this = mtd->priv;
-
-	/* Clear ECC, start DMA */
+	/* Clear ECC */
 	SLCNAND->slc_ctrl = SLCCTRL_ECC_CLEAR;
 
-	if (mode == NAND_ECC_READ)
-		SLCNAND->slc_cfg |= SLCCFG_DMA_DIR;
-	else  /* NAND_ECC_WRITE */
-		SLCNAND->slc_cfg &= ~SLCCFG_DMA_DIR;
-
-	SLCNAND->slc_cfg |= (SLCCFG_DMA_BURST | SLCCFG_ECC_EN |
-			SLCCFG_DMA_ECC);
-
-	/* Set transfer count */
-	SLCNAND->slc_tc = this->ecc.size + mtd->oobsize;
+	/* Setup SLC controller for H/W ECC operations */
+	SLCNAND->slc_cfg |= (SLCCFG_ECC_EN | SLCCFG_DMA_ECC);
 }
 
-static void lpc32xx_nand_write_page_hwecc(struct mtd_info *mtd,
-		                struct nand_chip *chip, const uint8_t *buf)
+/*
+ * lpc32xx_write_buf - [DEFAULT] write buffer to chip
+ * mtd:	MTD device structure
+ * buf:	data buffer
+ * len:	number of bytes to write
+ *
+ * Default write function for 8bit buswith
+ */
+static void lpc32xx_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
 {
-        int i, eccsize = chip->ecc.size;
-
-	/* Enable H/W ECC & DMA */
-	chip->ecc.hwctl(mtd, NAND_ECC_WRITE);
-
-	/* Configure DMA Desriptor for NAND Write Operation */
-	lpc32xx_dma_xfer(mtd, buf, eccsize, 0);
+	lpc32xx_nand_xfer(mtd, buf, len, 0);
 }
 
-static int lpc32xx_nand_read_page_hwecc(struct mtd_info *mtd,
-				 struct nand_chip *chip, uint8_t *buf, int page)
+/*
+ * lpc32xx_read_buf - [DEFAULT] read chip data into buffer
+ * mtd:	MTD device structure
+ * buf:	buffer to store date
+ * len:	number of bytes to read
+ *
+ * Default read function for 8bit buswith
+ */
+static void lpc32xx_read_buf(struct mtd_info *mtd, u_char *buf, int len)
 {
-        int i, eccsize = chip->ecc.size;
-        int eccbytes = chip->ecc.bytes;
-        int eccsteps = chip->ecc.steps;
-        uint8_t *p = buf;
-        uint8_t *ecc_calc = chip->buffers->ecccalc;
-        uint8_t *ecc_code = chip->buffers->ecccode;
-        uint32_t *eccpos = chip->ecc.layout->eccpos;
-
-	/* Enable HW ECC & DMA */	
-	chip->ecc.hwctl(mtd, NAND_ECC_READ);
-
-	/* Configure DMA Desriptor for NAND Read Operation */
-	lpc32xx_dma_xfer(mtd, buf, eccsize, 1);
-
-	/* Copy only ECC data which are stored into Flash */
-        for (i = 0; i < chip->ecc.total; i++)
-                ecc_code[i] = chip->oob_poi[eccpos[i]];
-	
-	/* Check & Correct data */
-        for (i = 0 ; eccsteps; eccsteps--, i += eccbytes, p += eccsize) {
-                int stat;
-
-                stat = chip->ecc.correct(mtd, p, &ecc_code[i], &ecc_calc[i]);
-                if (stat == -1)
-                        mtd->ecc_stats.failed++;
-                else
-                        mtd->ecc_stats.corrected += stat;
-        }
-	return 0;
+	lpc32xx_nand_xfer(mtd, buf, len, 1);
 }
 
 int board_nand_init(struct nand_chip *nand)
@@ -479,17 +382,12 @@ int board_nand_init(struct nand_chip *nand)
 	nand->ecc.mode = NAND_ECC_HW;
 	nand->ecc.bytes	= CONFIG_SYS_NAND_ECCBYTES;
 	nand->ecc.size = CONFIG_SYS_NAND_ECCSIZE;
-	nand->ecc.read_page_raw = lpc32xx_nand_read_page_hwecc;
-	nand->ecc.read_page = lpc32xx_nand_read_page_hwecc;
-	nand->ecc.write_page = lpc32xx_nand_write_page_hwecc;
-	
-	if(CONFIG_SYS_NAND_ECCSIZE == NAND_LARGE_BLOCK_PAGE_SIZE)
-		nand->ecc.layout = &lpc32xx_nand_oob_64;
-	else
+
+	if(CONFIG_SYS_NAND_ECCSIZE != NAND_LARGE_BLOCK_PAGE_SIZE)
 		nand->ecc.layout = &lpc32xx_nand_oob_16;
 
 	nand->ecc.calculate = lpc32xx_ecc_calculate;
-	nand->ecc.correct = lpc32xx_nand_correct_data;
+	nand->ecc.correct = nand_correct_data;
 	nand->ecc.hwctl = lpc32xx_hwecc_enable;
 	nand->cmd_ctrl = lpc32xx_nand_hwcontrol;
 	nand->dev_ready = lpc32xx_nand_ready;
diff --git a/include/configs/ea3250.h b/include/configs/ea3250.h
index a5ffab9..0b47bfe 100644
--- a/include/configs/ea3250.h
+++ b/include/configs/ea3250.h
@@ -209,7 +209,7 @@
  */
 #define CONFIG_SYS_LPC32XX_DMA            /* DMA support required */
 #define CONFIG_SYS_NAND_ECCSIZE      2048 /* ECC generated per page */
-#define CONFIG_SYS_NAND_ECCBYTES       32 /* 3 Bytes ECC per 256 Bytes */
+#define CONFIG_SYS_NAND_ECCBYTES       24 /* 3 Bytes ECC per 256 Bytes */
 #define CONFIG_SYS_NAND_OOBSIZE        64 /* OOB size in bytes */
 
 /* allow to overwrite serial and ethaddr */
diff --git a/include/configs/fdi3250.h b/include/configs/fdi3250.h
index 7982a4d..4cd9811 100644
--- a/include/configs/fdi3250.h
+++ b/include/configs/fdi3250.h
@@ -190,7 +190,7 @@
  */
 #define CONFIG_SYS_LPC32XX_DMA            /* DMA support required */
 #define CONFIG_SYS_NAND_ECCSIZE      2048 /* ECC generated per page */
-#define CONFIG_SYS_NAND_ECCBYTES       32 /* 3 Bytes ECC per 256 Bytes */
+#define CONFIG_SYS_NAND_ECCBYTES       24 /* 3 Bytes ECC per 256 Bytes */
 #define CONFIG_SYS_NAND_OOBSIZE        64 /* OOB size in bytes */
 
 /* allow to overwrite serial and ethaddr */
diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
index fee0a03..80153e8 100644
--- a/include/configs/phy3250.h
+++ b/include/configs/phy3250.h
@@ -210,7 +210,7 @@
  */
 #define CONFIG_SYS_LPC32XX_DMA            /* DMA supporte required */
 #define CONFIG_SYS_NAND_ECCSIZE       512 /* ECC generated per page */
-#define CONFIG_SYS_NAND_ECCBYTES        8 /* 3 Bytes ECC per 256 Bytes */
+#define CONFIG_SYS_NAND_ECCBYTES        6 /* 3 Bytes ECC per 256 Bytes */
 #define CONFIG_SYS_NAND_OOBSIZE        16 /* OOB size in bytes */
 
 /* allow to overwrite serial and ethaddr */
-- 
1.7.0.4


From c4566101335fab9d3a3c25e63f8ac3b7904ede72 Mon Sep 17 00:00:00 2001
From: Srinivas Bakki <srinivas.bakki@nxp.com>
Date: Wed, 9 Feb 2011 10:29:07 +0530
Subject: [PATCH 20/28] ARM: LPC32xx: fixed bootargs with changing nfs

---
 include/configs/fdi3250.h |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/include/configs/fdi3250.h b/include/configs/fdi3250.h
index 4cd9811..37ff45b 100644
--- a/include/configs/fdi3250.h
+++ b/include/configs/fdi3250.h
@@ -227,7 +227,7 @@
 #define NFSROOTCOMMAND "nfsboot="				\
 	"setenv bootargs "					\
 	"console=ttyTX0,115200n8 "				\
-	"root=/dev/nfs3 rw nfsroot=${serverip}:${rootpath} "	\
+	"root=/dev/nfs rw nfsroot=${serverip}:${rootpath} "	\
 	"ip=${ipaddr} ethaddr=${ethaddr}\0"
 
 /* Boot arguments for ramdisk image loaded via TFTP */
-- 
1.7.0.4


From 76b94982561d32394281004f56226b5918658433 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Fri, 4 Mar 2011 14:32:25 -0800
Subject: [PATCH 21/28] Fix kernel burn and load address for u-boot macros

Reported-by: Stephen Locke <slocke@omnitech.ca>
Signed-off-by Kevin Wells <wellsk40@gmail.com>
---
 include/configs/phy3250.h |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/include/configs/phy3250.h b/include/configs/phy3250.h
index 80153e8..d0cae4d 100644
--- a/include/configs/phy3250.h
+++ b/include/configs/phy3250.h
@@ -265,12 +265,12 @@
 
 /*Kernel boot from NAND */
 #define MTDKERNELBOOT "mtdkernel=nboot.jffs2 ${loadaddr} "	\
-	"0 0x00604000\0"
+	"0 0x00204000\0"
 
 /* Command to burn kernel image into NAND FLASH */
 #define MTDKERNELBURN "mtdkernelburn="				\
-	"nand erase 0x00604000 0x00400000;"			\
-	"nand write.jffs2 ${loadaddr} 0x00604000 0x00400000\0"
+	"nand erase 0x00204000 0x00400000;"			\
+	"nand write.jffs2 ${loadaddr} 0x00204000 0x00400000\0"
 
 /* Root filesystem image name and load address */
 #define ROOTFSNAME "rootfile=rootfs.jffs2\0"
-- 
1.7.0.4


From ab648bad8e2705835119ad784b35424ea05ee9e2 Mon Sep 17 00:00:00 2001
From: Bangaragiri G <bangaragiri.g@nxp.com>
Date: Wed, 20 Apr 2011 22:38:21 +0530
Subject: [PATCH 22/28] serial: lpc32xx: Removed whitespaces

The whitespaces in LPC32XX serial driver are removed

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 cpu/arm926ejs/lpc3250/serial.c |  515 ++++++++++++++++++++--------------------
 1 files changed, 257 insertions(+), 258 deletions(-)

diff --git a/cpu/arm926ejs/lpc3250/serial.c b/cpu/arm926ejs/lpc3250/serial.c
index 02765c2..582027c 100644
--- a/cpu/arm926ejs/lpc3250/serial.c
+++ b/cpu/arm926ejs/lpc3250/serial.c
@@ -29,14 +29,14 @@ DECLARE_GLOBAL_DATA_PTR;
 /*
  * ABS function
  */
-int serial_abs(int v1, int v2)
-{
-  if (v1 > v2)
-  {
-    return v1 - v2;
-  }
-
-  return v2 - v1;
+int serial_abs(int v1, int v2)
+{
+  if (v1 > v2)
+  {
+    return v1 - v2;
+  }
+
+  return v2 - v1;
 }
 
 /*
@@ -46,102 +46,102 @@ void serial_getdiv(u32 baudrate,
 			unsigned int *xdiv,
 			unsigned int *ydiv)
 {
-	unsigned int clkrate, savedclkrate, diff, basepclk;
-	int idxx, idyy;
-
-	/* Get the clock rate for the UART block */
-	basepclk = sys_get_rate(CLKPWR_PERIPH_CLK) >> 4;
-
-	/* Find the best divider */
-	*xdiv = *ydiv = 0;
-	savedclkrate = 0;
-	diff = 0xFFFFFFFF;
-	for (idxx = 1; idxx < 0xFF; idxx++)
-	{
-		for (idyy = idxx; idyy < 0xFF; idyy++)
-		{
-			clkrate = (basepclk * idxx) / idyy;
-			if (serial_abs(clkrate, baudrate) < diff)
-			{
-				diff = serial_abs(clkrate, baudrate);
-				savedclkrate = clkrate;
-				*xdiv = idxx;
-				*ydiv = idyy;
-			}
-		}
-	}
+	unsigned int clkrate, savedclkrate, diff, basepclk;
+	int idxx, idyy;
+
+	/* Get the clock rate for the UART block */
+	basepclk = sys_get_rate(CLKPWR_PERIPH_CLK) >> 4;
+
+	/* Find the best divider */
+	*xdiv = *ydiv = 0;
+	savedclkrate = 0;
+	diff = 0xFFFFFFFF;
+	for (idxx = 1; idxx < 0xFF; idxx++)
+	{
+		for (idyy = idxx; idyy < 0xFF; idyy++)
+		{
+			clkrate = (basepclk * idxx) / idyy;
+			if (serial_abs(clkrate, baudrate) < diff)
+			{
+				diff = serial_abs(clkrate, baudrate);
+				savedclkrate = clkrate;
+				*xdiv = idxx;
+				*ydiv = idyy;
+			}
+		}
+	}
 }
 
 #ifdef USE_HIGH_SPEED_UART
-void hsuart_getdiv(u32 baudrate,
-			unsigned int *xdiv)
-{
-  unsigned int clkrate, savedclkrate, diff, basepclk;
-  int idiv;
-  unsigned int divider;
-
-  /* Get the clock rate for the UART block */
-  basepclk = sys_get_rate(CLKPWR_PERIPH_CLK);
-
-  /* Find the best divider */
-  divider = 0;
-  savedclkrate = 0;
-  diff = 0xFFFFFFFF;
-  for (idiv = 0; idiv < 0x100; idiv++)
-  {
-    clkrate = basepclk / (14 * (idiv + 1));
-    if (serial_abs(clkrate, baudrate) < diff)
-    {
-      diff = serial_abs(clkrate, baudrate);
-      savedclkrate = clkrate;
-      divider = idiv;
-    }
-  }
-
-  /* Save computed divider */
-  *xdiv = divider;
-}
-
+void hsuart_getdiv(u32 baudrate,
+			unsigned int *xdiv)
+{
+  unsigned int clkrate, savedclkrate, diff, basepclk;
+  int idiv;
+  unsigned int divider;
+
+  /* Get the clock rate for the UART block */
+  basepclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+
+  /* Find the best divider */
+  divider = 0;
+  savedclkrate = 0;
+  diff = 0xFFFFFFFF;
+  for (idiv = 0; idiv < 0x100; idiv++)
+  {
+    clkrate = basepclk / (14 * (idiv + 1));
+    if (serial_abs(clkrate, baudrate) < diff)
+    {
+      diff = serial_abs(clkrate, baudrate);
+      savedclkrate = clkrate;
+      divider = idiv;
+    }
+  }
+
+  /* Save computed divider */
+  *xdiv = divider;
+}
+
 void serial_setbrg (void)
 {
-	unsigned int xdiv, ydiv;
-    unsigned int divider;
-    UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
-    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
-
-    if (CFG_UART_SEL == UART1) {
-	    /* Find closest high speed baud rate for desired clock frequency */
-	    hsuart_getdiv(gd->baudrate, &divider);
-        phsuregs->rate = divider;
-
-        // Disable flow control
-        phsuregs->ctrl &= ~((1<<14)|(1<<18));
-    } else {
-	    /* Find closest baud rate for desired clock frequency */
-	    serial_getdiv(gd->baudrate, &xdiv, &ydiv);
-
-	    /* Set clock x/y divider for the UART */
-	    if (puregs == UART3)
-	    {
-		    CLKPWR->clkpwr_uart3_clk_ctrl =
-			    CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
-	    }
-	    else if (puregs == UART4)
-	    {
-		    CLKPWR->clkpwr_uart4_clk_ctrl =
-			    CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
-	    }
-	    else if (puregs == UART5)
-	    {
-		    CLKPWR->clkpwr_uart5_clk_ctrl =
-			    CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
-	    }
-	    else if (puregs == UART6)
-	    {
-		    CLKPWR->clkpwr_uart6_clk_ctrl =
-			    CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
-	    }
-    }
+	unsigned int xdiv, ydiv;
+	unsigned int divider;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+	HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+
+	if (CFG_UART_SEL == UART1) {
+		/* Find closest high speed baud rate for desired clock frequency */
+		hsuart_getdiv(gd->baudrate, &divider);
+		phsuregs->rate = divider;
+
+		// Disable flow control
+		phsuregs->ctrl &= ~((1<<14)|(1<<18));
+	} else {
+		/* Find closest baud rate for desired clock frequency */
+		serial_getdiv(gd->baudrate, &xdiv, &ydiv);
+
+		/* Set clock x/y divider for the UART */
+		if (puregs == UART3)
+		{
+			CLKPWR->clkpwr_uart3_clk_ctrl =
+			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+		}
+		else if (puregs == UART4)
+		{
+			CLKPWR->clkpwr_uart4_clk_ctrl =
+			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+		}
+		else if (puregs == UART5)
+		{
+			CLKPWR->clkpwr_uart5_clk_ctrl =
+			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+		}
+		else if (puregs == UART6)
+		{
+			CLKPWR->clkpwr_uart6_clk_ctrl =
+			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
+		}
+	}
 }
 
 /*
@@ -153,75 +153,74 @@ int serial_init (void)
 {
 	volatile unsigned int tmp32;
 	int unum;
-	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
-    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+	HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
 
 	/* UART setup */
-
-    if (phsuregs == UART1) {
-	    /* set baudrate */
-	    serial_setbrg();
-
-        /* setup the buffers */
-        phsuregs->ctrl = (  (2<<19) /*HSU_HRTS_TRIG_32B*/ | 
-                            (3<<16) /* HSU_TMO_INACT_16B*/ |
-                            (0x14<<9) /* HSU_OFFSET(0x14)*/ | 
-                            (4<<2) /* HSU_RX_TL32B */ | 
-                            (0<<0) /* HSU_TX_TL0B */);
-    } else {
-	    /* Enable UART system clock */
-	    if (puregs == UART3)
-	    {
-		    CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART3_EN;
-		    unum = 3;
-	    }
-	    else if (puregs == UART4)
-	    {
-		    CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART4_EN;
-		    unum = 4;
-	    }
-	    else if (puregs == UART5)
-	    {
-		    CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART5_EN;
-		    unum = 5;
-	    }
-	    else if (puregs == UART6)
-	    {
-		    CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART6_EN;
-		    unum = 6;
-	    }
-
-	    /* Place UART in autoclock mode */
-	    tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum);
-	    UARTCNTL->clkmode = (tmp32 |
-		    UART_CLKMODE_LOAD(UART_CLKMODE_AUTO, (unum)));
-
-	    /* UART baud rate generator isn't used, so just set it to divider
-	       by 1 */
-	    puregs->lcr |= UART_LCR_DIVLATCH_EN;
-	    puregs->dll_fifo = 1;
-	    puregs->dlm_ier = 0;
-	    puregs->lcr &= ~UART_LCR_DIVLATCH_EN;
-
-	    /* Setup default UART state for N81 with FIFO mode */
-	    puregs->lcr = UART_LCR_WLEN_8BITS;
-
-	    /* set baudrate */
-	    serial_setbrg();
-
-	    /* Clear FIFOs and set FIFO level */
-	    puregs->iir_fcr = (UART_FCR_RXFIFO_TL16 |
-		    UART_FCR_TXFIFO_TL0 | UART_FCR_FIFO_CTRL |
-		    UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
-		    UART_FCR_RXFIFO_FLUSH);
-	    tmp32 = puregs->iir_fcr;
-	    tmp32 = puregs->lsr;
-
-	    /* Use automatic clocking */
-    //	tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum + 3);
-    //	UARTCNTL->clkmode = tmp32 | UART_CLKMODE_LOAD(
-    //        	UART_CLKMODE_AUTO, (unum + 3));  // TBD delete me
-    }
+	if (phsuregs == UART1) {
+		/* set baudrate */
+		serial_setbrg();
+
+		/* setup the buffers */
+		phsuregs->ctrl = ((2<<19) /*HSU_HRTS_TRIG_32B*/ |
+											(3<<16) /* HSU_TMO_INACT_16B*/ |
+											(0x14<<9) /* HSU_OFFSET(0x14)*/ |
+											(4<<2) /* HSU_RX_TL32B */ |
+											(0<<0) /* HSU_TX_TL0B */);
+	} else {
+		/* Enable UART system clock */
+		if (puregs == UART3)
+		{
+			CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART3_EN;
+			unum = 3;
+		}
+		else if (puregs == UART4)
+		{
+			CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART4_EN;
+			unum = 4;
+		}
+		else if (puregs == UART5)
+		{
+			CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART5_EN;
+			unum = 5;
+		}
+		else if (puregs == UART6)
+		{
+			CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART6_EN;
+			unum = 6;
+		}
+
+		/* Place UART in autoclock mode */
+		tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum);
+		UARTCNTL->clkmode = (tmp32 |
+		UART_CLKMODE_LOAD(UART_CLKMODE_AUTO, (unum)));
+
+		/* UART baud rate generator isn't used, so just set it to divider
+				by 1 */
+		puregs->lcr |= UART_LCR_DIVLATCH_EN;
+		puregs->dll_fifo = 1;
+		puregs->dlm_ier = 0;
+		puregs->lcr &= ~UART_LCR_DIVLATCH_EN;
+
+		/* Setup default UART state for N81 with FIFO mode */
+		puregs->lcr = UART_LCR_WLEN_8BITS;
+
+		/* set baudrate */
+		serial_setbrg();
+
+		/* Clear FIFOs and set FIFO level */
+		puregs->iir_fcr = (UART_FCR_RXFIFO_TL16 |
+											UART_FCR_TXFIFO_TL0 | UART_FCR_FIFO_CTRL |
+											UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
+											UART_FCR_RXFIFO_FLUSH);
+		tmp32 = puregs->iir_fcr;
+		tmp32 = puregs->lsr;
+
+		/* Use automatic clocking */
+		//	tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum + 3);
+		//	UARTCNTL->clkmode = tmp32 | UART_CLKMODE_LOAD(
+		//        	UART_CLKMODE_AUTO, (unum + 3));  // TBD delete me
+	}
 
 	return 0;
 }
@@ -231,21 +230,21 @@ int serial_init (void)
  */
 int serial_getc (void)
 {
-    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
-	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
-
-    if (phsuregs == UART1) {
-        // Wait for a character to come in
-        while ((phsuregs->level & 0xFF) == 0)
-            {}
-        // Send the received character back
-        return ((unsigned char)(phsuregs->txrx_fifo));
-    } else {
-	    /* Wait for a character from the UART */
-	    while ((puregs->lsr & UART_LSR_RDR) == 0);
-
-	    return (int) (puregs->dll_fifo & 0xFF);
-    }
+	HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+
+	if (phsuregs == UART1) {
+		// Wait for a character to come in
+		while ((phsuregs->level & 0xFF) == 0)
+		{}
+		// Send the received character back
+		return ((unsigned char)(phsuregs->txrx_fifo));
+	} else {
+		/* Wait for a character from the UART */
+		while ((puregs->lsr & UART_LSR_RDR) == 0);
+
+		return (int) (puregs->dll_fifo & 0xFF);
+	}
 }
 
 /*
@@ -253,21 +252,21 @@ int serial_getc (void)
  */
 void serial_putc (const char c)
 {
-    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
-	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
-
-    if (phsuregs == UART1) {
-        // Send out the character
-        phsuregs->txrx_fifo = c;
-        
-        // Wait for character to be sent (goes from non-zero to 0)
-        while ((phsuregs->level & 0xFF00) != 0);
-    } else {
-	    /* Wait for FIFO to become empty */
-	    while ((puregs->lsr & UART_LSR_THRE) == 0);
-
-	    puregs->dll_fifo = (u32) c;
-    }
+	HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+
+	if (phsuregs == UART1) {
+		// Send out the character
+		phsuregs->txrx_fifo = c;
+
+		// Wait for character to be sent (goes from non-zero to 0)
+		while ((phsuregs->level & 0xFF00) != 0);
+	} else {
+		/* Wait for FIFO to become empty */
+		while ((puregs->lsr & UART_LSR_THRE) == 0);
+
+		puregs->dll_fifo = (u32) c;
+	}
 
 	/* If \n, also do \r */
 	if (c == '\n')
@@ -281,25 +280,25 @@ void serial_putc (const char c)
  */
 int serial_tstc (void)
 {
-    HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
-	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
-
-    if (phsuregs == UART1) {
-	    /* Wait for a character from the UART */
-	    if ((phsuregs->level & 0xFF) == 0)
-	    {
-            // No characters waiting
-            return 0;
-        }
-    } else {
-	    /* Wait for a character from the UART */
-	    if ((puregs->lsr & UART_LSR_RDR) == 0)
-	    {
-		    return 0;
-	    }
-    }
-
-    // Got here, must be a character waiting
+	HSUART_REGS_T *phsuregs = (HSUART_REGS_T *) CFG_UART_SEL;
+	UART_REGS_T *puregs = (UART_REGS_T *) CFG_UART_SEL;
+
+	if (phsuregs == UART1) {
+		/* Wait for a character from the UART */
+		if ((phsuregs->level & 0xFF) == 0)
+		{
+			// No characters waiting
+			return 0;
+		}
+	} else {
+		/* Wait for a character from the UART */
+		if ((puregs->lsr & UART_LSR_RDR) == 0)
+		{
+			return 0;
+		}
+	}
+
+	// Got here, must be a character waiting
 	return 1;
 }
 
@@ -307,31 +306,31 @@ int serial_tstc (void)
 void serial_setbrg (void)
 {
 	unsigned int xdiv, ydiv;
-
-	/* Find closest baud rate for desired clock frequency */
-	serial_getdiv(gd->baudrate, &xdiv, &ydiv);
-
+
+	/* Find closest baud rate for desired clock frequency */
+	serial_getdiv(gd->baudrate, &xdiv, &ydiv);
+
 	/* Set clock x/y divider for the UART */
 	if (CFG_UART_SEL == UART3)
-	{
-		CLKPWR->clkpwr_uart3_clk_ctrl =
+	{
+		CLKPWR->clkpwr_uart3_clk_ctrl =
 			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
 	}
 	else if (CFG_UART_SEL == UART4)
-	{
-		CLKPWR->clkpwr_uart4_clk_ctrl =
+	{
+		CLKPWR->clkpwr_uart4_clk_ctrl =
 			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
-	}
+	}
 	else if (CFG_UART_SEL == UART5)
-	{
-		CLKPWR->clkpwr_uart5_clk_ctrl =
+	{
+		CLKPWR->clkpwr_uart5_clk_ctrl =
 			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
-	}
+	}
 	else if (CFG_UART_SEL == UART6)
-	{
-		CLKPWR->clkpwr_uart6_clk_ctrl =
+	{
+		CLKPWR->clkpwr_uart6_clk_ctrl =
 			CLKPWR_UART_X_DIV(xdiv) | CLKPWR_UART_Y_DIV(ydiv);
-	}
+	}
 }
 
 /*
@@ -357,48 +356,48 @@ int serial_init (void)
 	{
 		CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART4_EN;
 		unum = 4;
-	}
+	}
 	else if (puregs == UART5)
 	{
 		CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART5_EN;
 		unum = 5;
-	}
+	}
 	else if (puregs == UART6)
 	{
 		CLKPWR->clkpwr_uart_clk_ctrl |= CLKPWR_UARTCLKCTRL_UART6_EN;
 		unum = 6;
-	}
+	}
 
 	/* Place UART in autoclock mode */
 	tmp32 = UARTCNTL->clkmode & ~UART_CLKMODE_MASK(unum);
-	UARTCNTL->clkmode = (tmp32 |
-		UART_CLKMODE_LOAD(UART_CLKMODE_AUTO, (unum)));
-
-	/* UART baud rate generator isn't used, so just set it to divider
-	   by 1 */
-	puregs->lcr |= UART_LCR_DIVLATCH_EN;
-	puregs->dll_fifo = 1;
-	puregs->dlm_ier = 0;
-	puregs->lcr &= ~UART_LCR_DIVLATCH_EN;
-
+	UARTCNTL->clkmode = (tmp32 |
+		UART_CLKMODE_LOAD(UART_CLKMODE_AUTO, (unum)));
+
+	/* UART baud rate generator isn't used, so just set it to divider
+	   by 1 */
+	puregs->lcr |= UART_LCR_DIVLATCH_EN;
+	puregs->dll_fifo = 1;
+	puregs->dlm_ier = 0;
+	puregs->lcr &= ~UART_LCR_DIVLATCH_EN;
+
 	/* Setup default UART state for N81 with FIFO mode */
-	puregs->lcr = UART_LCR_WLEN_8BITS;
+	puregs->lcr = UART_LCR_WLEN_8BITS;
 
 	/* set baudrate */
 	serial_setbrg();
-
-	/* Clear FIFOs and set FIFO level */
-	puregs->iir_fcr = (UART_FCR_RXFIFO_TL16 |
-		UART_FCR_TXFIFO_TL0 | UART_FCR_FIFO_CTRL |
-		UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
-		UART_FCR_RXFIFO_FLUSH);
-	tmp32 = puregs->iir_fcr;
-	tmp32 = puregs->lsr;
-
-	/* Use automatic clocking */
-//	tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum + 3);
-//	UARTCNTL->clkmode = tmp32 | UART_CLKMODE_LOAD(
-//        	UART_CLKMODE_AUTO, (unum + 3));  // TBD delete me
+
+	/* Clear FIFOs and set FIFO level */
+	puregs->iir_fcr = (UART_FCR_RXFIFO_TL16 |
+										UART_FCR_TXFIFO_TL0 | UART_FCR_FIFO_CTRL |
+										UART_FCR_FIFO_EN | UART_FCR_TXFIFO_FLUSH |
+										UART_FCR_RXFIFO_FLUSH);
+	tmp32 = puregs->iir_fcr;
+	tmp32 = puregs->lsr;
+
+	/* Use automatic clocking */
+	//	tmp32 = UARTCNTL->clkmode & UART_CLKMODE_MASK(unum + 3);
+	//	UARTCNTL->clkmode = tmp32 | UART_CLKMODE_LOAD(
+	//        	UART_CLKMODE_AUTO, (unum + 3));  // TBD delete me
 
 	return 0;
 }
@@ -422,7 +421,7 @@ void serial_putc (const char c)
 	/* Wait for FIFO to become empty */
 	while ((CFG_UART_SEL->lsr & UART_LSR_THRE) == 0);
 
-	CFG_UART_SEL->dll_fifo = (u32) c;
+	CFG_UART_SEL->dll_fifo = (u32) c;
 
 	/* If \n, also do \r */
 	if (c == '\n')
-- 
1.7.0.4


From baf05f36eceef35f7c907d12804ff53a48ed3ed0 Mon Sep 17 00:00:00 2001
From: Bangaragiri G <bangaragiri.g@nxp.com>
Date: Wed, 20 Apr 2011 22:42:39 +0530
Subject: [PATCH 23/28] serial: lpc32xx: HSUART fixes

The following HSUART fixes are present in this patch:
- The baud rate divider calculation is fixed (as in kernel)
- The loopback is disabled in serial initialisation function

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 cpu/arm926ejs/lpc3250/serial.c |   54 +++++++++++++++++++++++-----------------
 1 files changed, 31 insertions(+), 23 deletions(-)

diff --git a/cpu/arm926ejs/lpc3250/serial.c b/cpu/arm926ejs/lpc3250/serial.c
index 582027c..eee12fd 100644
--- a/cpu/arm926ejs/lpc3250/serial.c
+++ b/cpu/arm926ejs/lpc3250/serial.c
@@ -76,30 +76,34 @@ void serial_getdiv(u32 baudrate,
 void hsuart_getdiv(u32 baudrate,
 			unsigned int *xdiv)
 {
-  unsigned int clkrate, savedclkrate, diff, basepclk;
-  int idiv;
-  unsigned int divider;
-
-  /* Get the clock rate for the UART block */
-  basepclk = sys_get_rate(CLKPWR_PERIPH_CLK);
-
-  /* Find the best divider */
-  divider = 0;
-  savedclkrate = 0;
-  diff = 0xFFFFFFFF;
-  for (idiv = 0; idiv < 0x100; idiv++)
-  {
-    clkrate = basepclk / (14 * (idiv + 1));
-    if (serial_abs(clkrate, baudrate) < diff)
-    {
-      diff = serial_abs(clkrate, baudrate);
-      savedclkrate = clkrate;
-      divider = idiv;
-    }
-  }
+	unsigned int basepclk, div, goodrate, hsu_rate, l_hsu_rate, comprate;
+	unsigned int rate_diff;
+
+	/* Find the closest divider to get the desired clock rate */
+	basepclk = sys_get_rate(CLKPWR_PERIPH_CLK);
+	div = basepclk / baudrate;
+	goodrate = hsu_rate = (div / 14) - 1;
+	if (hsu_rate != 0)
+		hsu_rate--;
+
+	/* Tweak divider */
+	l_hsu_rate = hsu_rate + 3;
+	rate_diff = 0xFFFFFFFF;
+
+	while (hsu_rate < l_hsu_rate) {
+		comprate = basepclk / ((hsu_rate + 1) * 14);
+		if (serial_abs(comprate, baudrate) < rate_diff) {
+			goodrate = hsu_rate;
+			rate_diff = serial_abs(comprate,baudrate);
+		}
 
-  /* Save computed divider */
-  *xdiv = divider;
+		hsu_rate++;
+	}
+	if (hsu_rate > 0xFF)
+		hsu_rate = 0xFF;
+
+	/* Save computed divider */
+	*xdiv = goodrate;
 }
 
 void serial_setbrg (void)
@@ -161,6 +165,10 @@ int serial_init (void)
 		/* set baudrate */
 		serial_setbrg();
 
+		/* By default, HSUART is set to loopback mode in S1L.
+		 * Disable loopback to work */
+		UARTCNTL->loop &= ~_BIT(0);
+
 		/* setup the buffers */
 		phsuregs->ctrl = ((2<<19) /*HSU_HRTS_TRIG_32B*/ |
 											(3<<16) /* HSU_TMO_INACT_16B*/ |
-- 
1.7.0.4


From ec5d78296b2ce104410d44f956b6360670c1c6c3 Mon Sep 17 00:00:00 2001
From: Kevin Wells <wellsk40@gmail.com>
Date: Wed, 5 Oct 2011 12:24:30 -0700
Subject: [PATCH 24/28] Add support for 32MB and 64MB FDI3250 boards

---
 board/fdi3250/fdi3250.c |   12 ++++++++++--
 1 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/board/fdi3250/fdi3250.c b/board/fdi3250/fdi3250.c
index 7f5ee10..14676e0 100644
--- a/board/fdi3250/fdi3250.c
+++ b/board/fdi3250/fdi3250.c
@@ -146,8 +146,16 @@ int dram_init (void)
 {
 	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
 
-	/* 32M, change this for 64M boards */
-	gd->bd->bi_dram[0].size = 0x02000000; /* 32M */
+	/*
+	 * There are 2 variants of the board each with a different memory
+	 * size. The size can be determined by reading the dynamic config
+	 * register and verifying against the board's known 64M DRAM
+	 * mapping number (0x11).
+	 */
+	if (((EMC->emcdynamicconfig0 >> 7) & 0x1F) == 0x11)
+		gd->bd->bi_dram[0].size = 0x04000000;
+	else
+		gd->bd->bi_dram[0].size = 0x02000000;
 
 	return 0;
 }
-- 
1.7.0.4


From 5e406c04874f7ca3257b5baf1352a8e001eeda0f Mon Sep 17 00:00:00 2001
From: Bangaragiri G <bangaragiri.g@nxp.com>
Date: Tue, 10 Jan 2012 14:41:34 +0000
Subject: [PATCH 25/28] nand:lpc313x:nboot command should skip bad blocks

The nboot command should skip the bad blocks while loading the
image from NAND Flash. This patch is taken from u-boot-2009.03
release.

Reported-by:Henry Li <henryli@xxx.com>
Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 common/cmd_nand.c |    5 ++---
 1 files changed, 2 insertions(+), 3 deletions(-)

diff --git a/common/cmd_nand.c b/common/cmd_nand.c
index 11f9096..f915fb6 100644
--- a/common/cmd_nand.c
+++ b/common/cmd_nand.c
@@ -511,7 +511,7 @@ static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
 	printf("\nLoading from %s, offset 0x%lx\n", nand->name, offset);
 
 	cnt = nand->writesize;
-	r = nand_read(nand, offset, &cnt, (u_char *) addr);
+	r = nand_read_skip_bad(nand, offset, &cnt, (u_char *) addr);
 	if (r) {
 		puts("** Read error\n");
 		show_boot_progress (-56);
@@ -543,8 +543,7 @@ static int nand_load_image(cmd_tbl_t *cmdtp, nand_info_t *nand,
 	}
 	show_boot_progress (57);
 
-	/* FIXME: skip bad blocks */
-	r = nand_read(nand, offset, &cnt, (u_char *) addr);
+	r = nand_read_skip_bad(nand, offset, &cnt, (u_char *) addr);
 	if (r) {
 		puts("** Read error\n");
 		show_boot_progress (-58);
-- 
1.7.0.4


From 26f3812854fd4ab1348705dedfa941f89da0e282 Mon Sep 17 00:00:00 2001
From: JeanPhilippeEIMER <JeanPhilippeEIMER@xxx.com>
Date: Tue, 28 Feb 2012 09:51:31 +0000
Subject: [PATCH 26/28] arm:lpc32xx:NAND Flash ECC correction fixes

In NAND Flash driver, the ECC correcrion function added so that
the ECC can be corrected for the whole page.
in nand_util, the ECC corrected page should return without error.

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 drivers/mtd/nand/lpc32xx_nand.c |   37 ++++++++++++++++++++++++++++++++++++-
 drivers/mtd/nand/nand_util.c    |    4 ++--
 2 files changed, 38 insertions(+), 3 deletions(-)

diff --git a/drivers/mtd/nand/lpc32xx_nand.c b/drivers/mtd/nand/lpc32xx_nand.c
index e6821eb..83af957 100644
--- a/drivers/mtd/nand/lpc32xx_nand.c
+++ b/drivers/mtd/nand/lpc32xx_nand.c
@@ -352,6 +352,41 @@ static void lpc32xx_write_buf(struct mtd_info *mtd, const u_char *buf, int len)
 	lpc32xx_nand_xfer(mtd, buf, len, 0);
 }
 
+
+/**
+ * lpc32xx_correct_data - [NAND Interface] Detect and correct bit error(s)
+ * mtd:	MTD block structure
+ * dat:	raw data read from the chip
+ * read_ecc:	ECC from the chip
+ * calc_ecc:	the ECC calculated from raw data
+ *
+ * Detect and correct a 1 bit error for 256 byte block
+ *
+ */
+int lpc32xx_correct_data(struct mtd_info *mtd, u_char *dat,
+		      u_char *read_ecc, u_char *calc_ecc)
+{
+	uint8_t i, nb_ecc256;
+	int	ret1, ret2 = 0;
+	u_char	*r = read_ecc;
+	u_char	*c = calc_ecc;
+	uint16_t	data_offset = 0;
+
+	nb_ecc256 = (CONFIG_SYS_NAND_ECCSIZE == NAND_LARGE_BLOCK_PAGE_SIZE ? 8 : 2);
+
+	for( i = 0 ; i < nb_ecc256 ; i++ , r += 3, c += 3, data_offset += 256 )
+	{
+		ret1 = nand_correct_data(mtd, dat + data_offset, r, c);
+
+		if( ret1 < 0 )
+			return -EBADMSG;
+		else
+			ret2 += ret1;
+	}
+
+	return(ret2);
+}
+
 /*
  * lpc32xx_read_buf - [DEFAULT] read chip data into buffer
  * mtd:	MTD device structure
@@ -387,7 +422,7 @@ int board_nand_init(struct nand_chip *nand)
 		nand->ecc.layout = &lpc32xx_nand_oob_16;
 
 	nand->ecc.calculate = lpc32xx_ecc_calculate;
-	nand->ecc.correct = nand_correct_data;
+	nand->ecc.correct = lpc32xx_correct_data;
 	nand->ecc.hwctl = lpc32xx_hwecc_enable;
 	nand->cmd_ctrl = lpc32xx_nand_hwcontrol;
 	nand->dev_ready = lpc32xx_nand_ready;
diff --git a/drivers/mtd/nand/nand_util.c b/drivers/mtd/nand/nand_util.c
index 6ba52b3..0912858 100644
--- a/drivers/mtd/nand/nand_util.c
+++ b/drivers/mtd/nand/nand_util.c
@@ -564,7 +564,7 @@ int nand_read_skip_bad(nand_info_t *nand, size_t offset, size_t *length,
 
 	if (len_incl_bad == *length) {
 		rval = nand_read (nand, offset, length, buffer);
-		if (rval != 0)
+		if (rval != 0 && rval != -EUCLEAN)
 			printf ("NAND read from offset %zx failed %d\n",
 				offset, rval);
 
@@ -588,7 +588,7 @@ int nand_read_skip_bad(nand_info_t *nand, size_t offset, size_t *length,
 			read_length = nand->erasesize - block_offset;
 
 		rval = nand_read (nand, offset, &read_length, p_buffer);
-		if (rval != 0) {
+		if (rval != 0 && rval != -EUCLEAN) {
 			printf ("NAND read from offset %zx failed %d\n",
 				offset, rval);
 			*length -= left_to_read;
-- 
1.7.0.4


From 330948c2a14d53bfdf13b5656c7d2a14b88d6486 Mon Sep 17 00:00:00 2001
From: Bangaragiri G <bangaragiri.g@nxp.com>
Date: Mon, 26 Mar 2012 10:58:00 +0000
Subject: [PATCH 27/28] arm:lpc32xx:Fixing whitespaces in EA3250 board file

Fixing the white spaces in ea3250.c file

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 board/ea3250/ea3250.c |   54 ++++++++++++++++++++++++------------------------
 1 files changed, 27 insertions(+), 27 deletions(-)

diff --git a/board/ea3250/ea3250.c b/board/ea3250/ea3250.c
index 99ef996..09d8f46 100644
--- a/board/ea3250/ea3250.c
+++ b/board/ea3250/ea3250.c
@@ -30,7 +30,7 @@
 #include <lpc3250.h>
 #include <net.h>
 #include "ea3250_prv.h"
-		
+
 DECLARE_GLOBAL_DATA_PTR;
 
 /* ISP1301 USB transceiver I2C registers */
@@ -220,7 +220,7 @@ static int i2c_wait_reset(int timeout)
 		timeout--;
 	}
 
-	return (timeout <= 0);	
+	return (timeout <= 0);
 }
 
 
@@ -229,10 +229,10 @@ static int isp1301_get_value(int reg)
 	int n = 0;
 
 	/* send isp1301 address */
-	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT);   
+	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT);
 
 	/* register (offset) to read from */
-	OTG->otg_i2c.otg_i2c_txrx = reg;   
+	OTG->otg_i2c.otg_i2c_txrx = reg;
 
 	/* repeat start */
 	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT | I2C_READ);
@@ -256,24 +256,24 @@ static int isp1301_set_value(int reg, int value)
 	int n = 0;
 
 	/* send isp1301 address */
-	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT);   
+	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT);
 
 	/* offset to write to */
-	OTG->otg_i2c.otg_i2c_txrx = (reg | I2C_WRITE);   
+	OTG->otg_i2c.otg_i2c_txrx = (reg | I2C_WRITE);
 	/* value to write */
-	OTG->otg_i2c.otg_i2c_txrx = (value | I2C_STOP_BIT);  
-  
+	OTG->otg_i2c.otg_i2c_txrx = (value | I2C_STOP_BIT);
+
 	/* wait for transmit done (TDI) */
 	while (((OTG->otg_i2c.otg_i2c_stat & I2C_TDI) != I2C_TDI) && n++ < 100000);
 
 	if (n>= 100000)
 	{
 		printf("isp1301_set_value: ERROR TDI not set\n");
-		return -1;		
+		return -1;
 	}
-  
+
 	/* clear TDI */
-	OTG->otg_i2c.otg_i2c_stat |= I2C_TDI;     
+	OTG->otg_i2c.otg_i2c_stat |= I2C_TDI;
 
 	return 0;
 }
@@ -281,9 +281,9 @@ static int isp1301_set_value(int reg, int value)
 static void isp1301_configure(void)
 {
 	OTG->otg_i2c.otg_i2c_clk_hi = 0x3f;
-	OTG->otg_i2c.otg_i2c_clk_lo = 0x3f; 
+	OTG->otg_i2c.otg_i2c_clk_lo = 0x3f;
 
-	OTG->otg_i2c.otg_i2c_ctrl |= I2C_RESET;	
+	OTG->otg_i2c.otg_i2c_ctrl |= I2C_RESET;
 	i2c_wait_reset(100);
 
 	/* LPC32XX only supports DAT_SE0 USB mode */
@@ -297,12 +297,12 @@ static void isp1301_configure(void)
 		ISP1301_I2C_REG_CLEAR_ADDR), ~MC1_SPEED_REG);
 	isp1301_set_value(ISP1301_I2C_MODE_CONTROL_1, MC1_SPEED_REG);
 	isp1301_set_value((ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);
-	isp1301_set_value(ISP1301_I2C_MODE_CONTROL_2, 
+	isp1301_set_value(ISP1301_I2C_MODE_CONTROL_2,
 		(MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL));
 
 	isp1301_set_value((ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);
 	isp1301_set_value(ISP1301_I2C_MODE_CONTROL_1, MC1_DAT_SE0);
-	isp1301_set_value(ISP1301_I2C_OTG_CONTROL_1, 
+	isp1301_set_value(ISP1301_I2C_OTG_CONTROL_1,
 		(OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN));
 	isp1301_set_value((ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),
 		(OTG1_DM_PULLUP | OTG1_DP_PULLUP));
@@ -314,13 +314,13 @@ static void isp1301_configure(void)
 	CLKPWR->clkpwr_usb_ctrl |= (CLKPWR_USBCTRL_USBDVND_EN);
 
 
-	printf("\nISP1301 Vendor ID  : 0x%04x\n", 
+	printf("\nISP1301 Vendor ID  : 0x%04x\n",
 		(isp1301_get_value(0x00) | (isp1301_get_value(0x01) << 8)));
-	printf("ISP1301 Product ID : 0x%04x\n", 
+	printf("ISP1301 Product ID : 0x%04x\n",
 		(isp1301_get_value(0x02) | (isp1301_get_value(0x03) << 8)));
-	printf("ISP1301 Version ID : 0x%04x\n", 
+	printf("ISP1301 Version ID : 0x%04x\n",
 		(isp1301_get_value(0x14) | (isp1301_get_value(0x15) << 8)));
-	
+
 }
 
 static void usbpll_setup(void)
@@ -335,15 +335,15 @@ static void usbpll_setup(void)
 	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_CLK_EN1;
 
 
-	/* 
-         * Setup PLL.  
+	/*
+         * Setup PLL.
          *
          */
 	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_FDBK_PLUS1(192-1);
 	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_POSTDIV_2POW(0x01);
 	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_PLL_PWRUP;
- 
-	
+
+
 	while ((CLKPWR->clkpwr_usb_ctrl & CLKPWR_USBCTRL_PLL_STS) == 0)
 	{
 		if (n++ >= 100000)
@@ -354,14 +354,14 @@ static void usbpll_setup(void)
 	}
 
 	/* enable PLL output */
-	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_CLK_EN2;		
+	CLKPWR->clkpwr_usb_ctrl |= CLKPWR_USBCTRL_CLK_EN2;
 }
 
 
 int usb_board_init(void)
 {
 	/* enable AHB slave USB clock */
-	CLKPWR->clkpwr_usb_ctrl |= 
+	CLKPWR->clkpwr_usb_ctrl |=
 		(CLKPWR_USBCTRL_HCLK_EN | CLKPWR_USBCTRL_BUS_KEEPER);
 
 	/* enable I2C clock in OTG block if it isn't */
@@ -389,7 +389,7 @@ int usb_board_init(void)
 		|OTG_CLK_I2C_EN|OTG_CLK_HOST_EN)) !=
 	       (OTG_CLK_AHB_EN|OTG_CLK_OTG_EN
 		|OTG_CLK_I2C_EN|OTG_CLK_HOST_EN)) ;
-	
+
 	OTG->otg_sts_ctrl |= OTG_HOST_EN;
 	isp1301_set_value(ISP1301_I2C_OTG_CONTROL_1, OTG1_VBUS_DRV);
 
@@ -400,7 +400,7 @@ int usb_board_stop(void)
 {
 	/* vbus off */
 	isp1301_set_value(
-		(ISP1301_I2C_OTG_CONTROL_1| ISP1301_I2C_REG_CLEAR_ADDR), 
+		(ISP1301_I2C_OTG_CONTROL_1| ISP1301_I2C_REG_CLEAR_ADDR),
 		OTG1_VBUS_DRV);
 
 	OTG->otg_sts_ctrl &= ~OTG_HOST_EN;
-- 
1.7.0.4


From 82cc6ba228f1689e0b9d2c2960f18a6363348280 Mon Sep 17 00:00:00 2001
From: RyanBryngelson <RyanBryngelson@xxx.com>
Date: Mon, 26 Mar 2012 11:02:47 +0000
Subject: [PATCH 28/28] arm:lpc32xx:Fixing the ISP1301 I2C function

When transmitting a byte via I2C? bits 8 and 9 issue start and stop
conditions respectively. The function that writes to configuration
registers in the ISP1301 OTG PHY doesn't mask off invalid data bits
(bits 8 through 31) so start/stop conditions are being mistakenly
issued. Although the ISP1301 seemingly tolerated this behavior the
"functionally equivalent" STOTG04E did not.
The fix is simply to mask off the invalid data from register and data
values

Signed-off-by: Bangaragiri G <bangaragiri.g@nxp.com>
---
 board/ea3250/ea3250.c |    6 +++---
 1 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/board/ea3250/ea3250.c b/board/ea3250/ea3250.c
index 09d8f46..462f749 100644
--- a/board/ea3250/ea3250.c
+++ b/board/ea3250/ea3250.c
@@ -232,7 +232,7 @@ static int isp1301_get_value(int reg)
 	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT);
 
 	/* register (offset) to read from */
-	OTG->otg_i2c.otg_i2c_txrx = reg;
+	OTG->otg_i2c.otg_i2c_txrx = (reg & 0xff);
 
 	/* repeat start */
 	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT | I2C_READ);
@@ -259,9 +259,9 @@ static int isp1301_set_value(int reg, int value)
 	OTG->otg_i2c.otg_i2c_txrx = ((ISP1301_I2C_ADDR << 1) | I2C_START_BIT);
 
 	/* offset to write to */
-	OTG->otg_i2c.otg_i2c_txrx = (reg | I2C_WRITE);
+	OTG->otg_i2c.otg_i2c_txrx = ((reg & 0xff) | I2C_WRITE);
 	/* value to write */
-	OTG->otg_i2c.otg_i2c_txrx = (value | I2C_STOP_BIT);
+	OTG->otg_i2c.otg_i2c_txrx = ((value & 0xff) | I2C_STOP_BIT);
 
 	/* wait for transmit done (TDI) */
 	while (((OTG->otg_i2c.otg_i2c_stat & I2C_TDI) != I2C_TDI) && n++ < 100000);
-- 
1.7.0.4

